[
  {
    "title": "Language Grammar — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/grammar.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Language Grammar\n Edit on GitHub\nLanguage Grammar\nparser grammarSolidityParser\n\nSolidity is a statically typed, contract-oriented, high-level language for implementing smart contracts on the Ethereum platform.\n\nrulesource-unit\n\nOn top level, Solidity allows pragmas, import directives, and definitions of contracts, interfaces, libraries, structs, enums and constants.\n\npragma\npragma-token\n;\nimport-directive\nusing-directive\ncontract-definition\ninterface-definition\nlibrary-definition\nfunction-definition\nconstant-variable-declaration\nstruct-definition\nenum-definition\nuser-defined-value-type-definition\nerror-definition\nevent-definition\neof\n\nruleimport-directive\n\nImport directives import identifiers from different files.\n\nimport\npath\nas\nidentifier\nsymbol-aliases\nfrom\npath\n*\nas\nidentifier\nfrom\npath\n;\n\nrulepath\n\nPath of a file to be imported.\n\nnon-empty-string-literal\n\nrulesymbol-aliases\n\nList of aliases for symbols to be imported.\n\n{\nidentifier\nas\nidentifier\n,\n}\n\nrulecontract-definition\n\nTop-level definition of a contract.\n\nabstract\ncontract\nidentifier\nis\ninheritance-specifier\n,\n{\ncontract-body-element\n}\n\nruleinterface-definition\n\nTop-level definition of an interface.\n\ninterface\nidentifier\nis\ninheritance-specifier\n,\n{\ncontract-body-element\n}\n\nrulelibrary-definition\n\nTop-level definition of a library.\n\nlibrary\nidentifier\n{\ncontract-body-element\n}\n\nruleinheritance-specifier\n\nInheritance specifier for contracts and interfaces. Can optionally supply base constructor arguments.\n\nidentifier-path\ncall-argument-list\n\nrulecontract-body-element\n\nDeclarations that can be used in contracts, interfaces and libraries.\n\nNote that interfaces and libraries may not contain constructors, interfaces may not contain state variables and libraries may not contain fallback, receive functions nor non-constant state variables.\n\nconstructor-definition\nfunction-definition\nmodifier-definition\nfallback-function-definition\nreceive-function-definition\nstruct-definition\nenum-definition\nuser-defined-value-type-definition\nstate-variable-declaration\nevent-definition\nerror-definition\nusing-directive\n\nrulecall-argument-list\n\nArguments when calling a function or a similar callable object. The arguments are either given as comma separated list or as map of named arguments.\n\n(\nexpression\n,\n{\nidentifier\n:\nexpression\n,\n}\n)\n\nruleidentifier-path\n\nQualified name.\n\nidentifier\n.\n\nrulemodifier-invocation\n\nCall to a modifier. If the modifier takes no arguments, the argument list can be skipped entirely (including opening and closing parentheses).\n\nidentifier-path\ncall-argument-list\n\nrulevisibility\n\nVisibility for functions and function types.\n\ninternal\nexternal\nprivate\npublic\n\nruleparameter-list\n\nA list of parameters, such as function arguments or return values.\n\ntype-name\ndata-location\nidentifier\n,\n\nruleconstructor-definition\n\nDefinition of a constructor. Must always supply an implementation. Note that specifying internal or public visibility is deprecated.\n\nconstructor\n(\nparameter-list\n)\nmodifier-invocation\npayable\ninternal\npublic\nblock\n\nrulestate-mutability\n\nState mutability for function types. The default mutability ‘non-payable’ is assumed if no mutability is specified.\n\npure\nview\npayable\n\nruleoverride-specifier\n\nAn override specifier used for functions, modifiers or state variables. In cases where there are ambiguous declarations in several base contracts being overridden, a complete list of base contracts has to be given.\n\noverride\n(\nidentifier-path\n,\n)\n\nrulefunction-definition\n\nThe definition of contract, library, interface or free functions. Depending on the context in which the function is defined, further restrictions may apply, e.g. functions in interfaces have to be unimplemented, i.e. may not contain a body block.\n\nfunction\nidentifier\nfallback\nreceive\n(\nparameter-list\n)\nvisibility\nstate-mutability\nmodifier-invocation\nvirtual\noverride-specifier\nreturns\n(\nparameter-list\n)\n;\nblock\n\nrulemodifier-definition\n\nThe definition of a modifier. Note that within the body block of a modifier, the underscore cannot be used as identifier, but is used as placeholder statement for the body of a function to which the modifier is applied.\n\nmodifier\nidentifier\n(\nparameter-list\n)\nvirtual\noverride-specifier\n;\nblock\n\nrulefallback-function-definition\n\nDefinition of the special fallback function.\n\nfallback\n(\nparameter-list\n)\nexternal\nstate-mutability\nmodifier-invocation\nvirtual\noverride-specifier\nreturns\n(\nparameter-list\n)\n;\nblock\n\nrulereceive-function-definition\n\nDefinition of the special receive function.\n\nreceive\n(\n)\nexternal\npayable\nmodifier-invocation\nvirtual\noverride-specifier\n;\nblock\n\nrulestruct-definition\n\nDefinition of a struct. Can occur at top-level within a source unit or within a contract, library or interface.\n\nstruct\nidentifier\n{\nstruct-member\n}\n\nrulestruct-member\n\nThe declaration of a named struct member.\n\ntype-name\nidentifier\n;\n\nruleenum-definition\n\nDefinition of an enum. Can occur at top-level within a source unit or within a contract, library or interface.\n\nenum\nidentifier\n{\nidentifier\n,\n}\n\nruleuser-defined-value-type-definition\n\nDefinition of a user defined value type. Can occur at top-level within a source unit or within a contract, library or interface.\n\ntype\nidentifier\nis\nelementary-type-name\n;\n\nrulestate-variable-declaration\n\nThe declaration of a state variable.\n\ntype-name\npublic\nprivate\ninternal\nconstant\noverride-specifier\nimmutable\nidentifier\n=\nexpression\n;\n\nruleconstant-variable-declaration\n\nThe declaration of a constant variable.\n\ntype-name\nconstant\nidentifier\n=\nexpression\n;\n\nruleevent-parameter\n\nParameter of an event.\n\ntype-name\nindexed\nidentifier\n\nruleevent-definition\n\nDefinition of an event. Can occur in contracts, libraries or interfaces.\n\nevent\nidentifier\n(\nevent-parameter\n,\n)\nanonymous\n;\n\nruleerror-parameter\n\nParameter of an error.\n\ntype-name\nidentifier\n\nruleerror-definition\n\nDefinition of an error.\n\nerror\nidentifier\n(\nerror-parameter\n,\n)\n;\n\nruleuser-definable-operator\n\nOperators that users are allowed to implement for some types with using for.\n\n&\n~\n|\n^\n+\n/\n%\n*\n-\n==\n>\n>=\n<\n<=\n!=\n\nruleusing-directive\n\nUsing directive to attach library functions and free functions to types. Can occur within contracts and libraries and at the file level.\n\nusing\nidentifier-path\n{\nidentifier-path\nas\nuser-definable-operator\n,\n}\nfor\n*\ntype-name\nglobal\n;\n\nruletype-name\n\nA type name can be an elementary type, a function type, a mapping type, a user-defined type (e.g. a contract or struct) or an array type.\n\nelementary-type-name\nfunction-type-name\nmapping-type\nidentifier-path\ntype-name\n[\nexpression\n]\n\nruleelementary-type-name\n\naddress\naddress\npayable\nbool\nstring\nbytes\nsigned-integer-type\nunsigned-integer-type\nfixed-bytes\nfixed\nufixed\n\nrulefunction-type-name\n\nfunction\n(\nparameter-list\n)\nvisibility\nstate-mutability\nreturns\n(\nparameter-list\n)\n\nrulevariable-declaration\n\nThe declaration of a single variable.\n\ntype-name\ndata-location\nidentifier\n\nruledata-location\n\nmemory\nstorage\ncalldata\n\nruleexpression\n\nComplex expression. Can be an index access, an index range access, a member access, a function call (with optional function call options), a type conversion, an unary or binary expression, a comparison or assignment, a ternary expression, a new-expression (i.e. a contract creation or the allocation of a dynamic memory array), a tuple, an inline array or a primary expression (i.e. an identifier, literal or type name).\n\nexpression\n[\nexpression\n]\nexpression\n[\nexpression\n:\nexpression\n]\nexpression\n.\nidentifier\naddress\nexpression\n{\nidentifier\n:\nexpression\n,\n}\nexpression\ncall-argument-list\npayable\ncall-argument-list\ntype\n(\ntype-name\n)\n++\n--\n!\n~\ndelete\n-\nexpression\nexpression\n++\n--\nexpression\n**\nexpression\nexpression\n*\n/\n%\nexpression\nexpression\n+\n-\nexpression\nexpression\n<<\n>>\n>>>\nexpression\nexpression\n&\nexpression\nexpression\n^\nexpression\nexpression\n|\nexpression\nexpression\n<\n>\n<=\n>=\nexpression\nexpression\n==\n!=\nexpression\nexpression\n&&\nexpression\nexpression\n||\nexpression\nexpression\n?\nexpression\n:\nexpression\nexpression\n=\n|=\n^=\n&=\n<<=\n>>=\n>>>=\n+=\n-=\n*=\n/=\n%=\nexpression\nnew\ntype-name\ntuple-expression\ninline-array-expression\nidentifier\nliteral\nliteral-with-sub-denomination\nelementary-type-name\n\nruletuple-expression\n\n(\nexpression\n,\n)\n\nruleinline-array-expression\n\nAn inline array expression denotes a statically sized array of the common type of the contained expressions.\n\n[\nexpression\n,\n]\n\nruleidentifier\n\nBesides regular non-keyword Identifiers, some keywords like ‘from’ and ‘error’ can also be used as identifiers.\n\nidentifier\nfrom\nerror\nrevert\nglobal\n\nruleliteral\n\nstring-literal\nnumber-literal\nboolean-literal\nhex-string-literal\nunicode-string-literal\n\nruleliteral-with-sub-denomination\n\nnumber-literal\nsub-denomination\n\nruleboolean-literal\n\ntrue\nfalse\n\nrulestring-literal\n\nA full string literal consists of either one or several consecutive quoted strings.\n\nnon-empty-string-literal\nempty-string-literal\n\nrulehex-string-literal\n\nA full hex string literal that consists of either one or several consecutive hex strings.\n\nhex-string\n\nruleunicode-string-literal\n\nA full unicode string literal that consists of either one or several consecutive unicode strings.\n\nunicode-string-literal\n\nrulenumber-literal\n\nNumber literals can be decimal or hexadecimal numbers with an optional unit.\n\ndecimal-number\nhex-number\n\nruleblock\n\nA curly-braced block of statements. Opens its own scope.\n\n{\nstatement\nunchecked-block\n}\n\nruleunchecked-block\n\nunchecked\nblock\n\nrulestatement\n\nblock\nvariable-declaration-statement\nexpression-statement\nif-statement\nfor-statement\nwhile-statement\ndo-while-statement\ncontinue-statement\nbreak-statement\ntry-statement\nreturn-statement\nemit-statement\nrevert-statement\nassembly-statement\n\nruleif-statement\n\nIf statement with optional else part.\n\nif\n(\nexpression\n)\nstatement\nelse\nstatement\n\nrulefor-statement\n\nFor statement with optional init, condition and post-loop part.\n\nfor\n(\nvariable-declaration-statement\nexpression-statement\n;\nexpression-statement\n;\nexpression\n)\nstatement\n\nrulewhile-statement\n\nwhile\n(\nexpression\n)\nstatement\n\nruledo-while-statement\n\ndo\nstatement\nwhile\n(\nexpression\n)\n;\n\nrulecontinue-statement\n\nA continue statement. Only allowed inside for, while or do-while loops.\n\ncontinue\n;\n\nrulebreak-statement\n\nA break statement. Only allowed inside for, while or do-while loops.\n\nbreak\n;\n\nruletry-statement\n\nA try statement. The contained expression needs to be an external function call or a contract creation.\n\ntry\nexpression\nreturns\n(\nparameter-list\n)\nblock\ncatch-clause\n\nrulecatch-clause\n\nThe catch clause of a try statement.\n\ncatch\nidentifier\n(\nparameter-list\n)\nblock\n\nrulereturn-statement\n\nreturn\nexpression\n;\n\nruleemit-statement\n\nAn emit statement. The contained expression needs to refer to an event.\n\nemit\nexpression\ncall-argument-list\n;\n\nrulerevert-statement\n\nA revert statement. The contained expression needs to refer to an error.\n\nrevert\nexpression\ncall-argument-list\n;\n\nruleassembly-statement\n\nAn inline assembly block. The contents of an inline assembly block use a separate scanner/lexer, i.e. the set of keywords and allowed identifiers is different inside an inline assembly block.\n\nassembly\n'\"evmasm\"'\nassembly-flags\n{\nyul-statement\n}\n\nruleassembly-flags\n\nAssembly flags. Comma-separated list of double-quoted strings as flags.\n\n(\nassembly-flag-string\n,\n)\n\nrulevariable-declaration-tuple\n\nA tuple of variable names to be used in variable declarations. May contain empty fields.\n\n(\n,\nvariable-declaration\n,\nvariable-declaration\n)\n\nrulevariable-declaration-statement\n\nA variable declaration statement. A single variable may be declared without initial value, whereas a tuple of variables can only be declared with initial value.\n\nvariable-declaration\n=\nexpression\nvariable-declaration-tuple\n=\nexpression\n;\n\nruleexpression-statement\n\nexpression\n;\n\nrulemapping-type\n\nmapping\n(\nmapping-key-type\nidentifier\n=>\ntype-name\nidentifier\n)\n\nrulemapping-key-type\n\nOnly elementary types or user defined types are viable as mapping keys.\n\nelementary-type-name\nidentifier-path\n\nruleyul-statement\n\nA Yul statement within an inline assembly block. continue and break statements are only valid within for loops. leave statements are only valid within function bodies.\n\nyul-block\nyul-variable-declaration\nyul-assignment\nyul-function-call\nyul-if-statement\nyul-for-statement\nyul-switch-statement\nleave\nbreak\ncontinue\nyul-function-definition\n\nruleyul-block\n\n{\nyul-statement\n}\n\nruleyul-variable-declaration\n\nThe declaration of one or more Yul variables with optional initial value. If multiple variables are declared, only a function call is a valid initial value.\n\nlet\nyul-identifier\n:=\nyul-expression\nlet\nyul-identifier\n,\n:=\nyul-function-call\n\nruleyul-assignment\n\nAny expression can be assigned to a single Yul variable, whereas multi-assignments require a function call on the right-hand side.\n\nyul-path\n:=\nyul-expression\nyul-path\n,\nyul-path\n:=\nyul-function-call\n\nruleyul-if-statement\n\nif\nyul-expression\nyul-block\n\nruleyul-for-statement\n\nfor\nyul-block\nyul-expression\nyul-block\nyul-block\n\nruleyul-switch-statement\n\nA Yul switch statement can consist of only a default-case (deprecated) or one or more non-default cases optionally followed by a default-case.\n\nswitch\nyul-expression\ncase\nyul-literal\nyul-block\ndefault\nyul-block\ndefault\nyul-block\n\nruleyul-function-definition\n\nfunction\nyul-identifier\n(\nyul-identifier\n,\n)\n->\nyul-identifier\n,\nyul-block\n\nruleyul-path\n\nWhile only identifiers without dots can be declared within inline assembly, paths containing dots can refer to declarations outside the inline assembly block.\n\nyul-identifier\n.\nyul-identifier\nyul-evm-builtin\n\nruleyul-function-call\n\nA call to a function with return values can only occur as right-hand side of an assignment or a variable declaration.\n\nyul-identifier\nyul-evm-builtin\n(\nyul-expression\n,\n)\n\nruleyul-boolean\n\ntrue\nfalse\n\nruleyul-literal\n\nyul-decimal-number\nyul-string-literal\nyul-hex-number\nyul-boolean\nhex-string\n\nruleyul-expression\n\nyul-path\nyul-function-call\nyul-literal\n\nlexer grammarSolidityLexer\nrulefixed-bytes\n\nBytes types of fixed length.\n\n'bytes1'\n'bytes2'\n'bytes3'\n'bytes4'\n'bytes5'\n'bytes6'\n'bytes7'\n'bytes8'\n'bytes9'\n'bytes10'\n'bytes11'\n'bytes12'\n'bytes13'\n'bytes14'\n'bytes15'\n'bytes16'\n'bytes17'\n'bytes18'\n'bytes19'\n'bytes20'\n'bytes21'\n'bytes22'\n'bytes23'\n'bytes24'\n'bytes25'\n'bytes26'\n'bytes27'\n'bytes28'\n'bytes29'\n'bytes30'\n'bytes31'\n'bytes32'\n\nrulesub-denomination\n\nUnit denomination for numbers.\n\n'wei'\n'gwei'\n'ether'\n'seconds'\n'minutes'\n'hours'\n'days'\n'weeks'\n'years'\n\nrulesigned-integer-type\n\nSized signed integer types. int is an alias of int256.\n\n'int'\n'int8'\n'int16'\n'int24'\n'int32'\n'int40'\n'int48'\n'int56'\n'int64'\n'int72'\n'int80'\n'int88'\n'int96'\n'int104'\n'int112'\n'int120'\n'int128'\n'int136'\n'int144'\n'int152'\n'int160'\n'int168'\n'int176'\n'int184'\n'int192'\n'int200'\n'int208'\n'int216'\n'int224'\n'int232'\n'int240'\n'int248'\n'int256'\n\nruleunsigned-integer-type\n\nSized unsigned integer types. uint is an alias of uint256.\n\n'uint'\n'uint8'\n'uint16'\n'uint24'\n'uint32'\n'uint40'\n'uint48'\n'uint56'\n'uint64'\n'uint72'\n'uint80'\n'uint88'\n'uint96'\n'uint104'\n'uint112'\n'uint120'\n'uint128'\n'uint136'\n'uint144'\n'uint152'\n'uint160'\n'uint168'\n'uint176'\n'uint184'\n'uint192'\n'uint200'\n'uint208'\n'uint216'\n'uint224'\n'uint232'\n'uint240'\n'uint248'\n'uint256'\n\nrulenon-empty-string-literal\n\nA non-empty quoted string literal restricted to printable characters.\n\n'\"'\ndouble-quoted-printable\nescape-sequence\n'\"'\n'\\''\nsingle-quoted-printable\nescape-sequence\n'\\''\n\nruleempty-string-literal\n\nAn empty string literal\n\n'\"'\n'\"'\n'\\''\n'\\''\n\nrulesingle-quoted-printable\n\nAny printable character except single quote or back slash.\n\n[\\u0020-\\u0026\\u0028-\\u005B\\u005D-\\u007E]\n\nruledouble-quoted-printable\n\nAny printable character except double quote or back slash.\n\n[\\u0020-\\u0021\\u0023-\\u005B\\u005D-\\u007E]\n\nruleescape-sequence\n\nEscape sequence. Apart from common single character escape sequences, line breaks can be escaped as well as four hex digit unicode escapes \\uXXXX and two digit hex escape sequences \\xXX are allowed.\n\n'\\\\'\n['\"\\\\nrt\\n\\r]\n'u'\n[0-9A-Fa-f]\n[0-9A-Fa-f]\n[0-9A-Fa-f]\n[0-9A-Fa-f]\n'x'\n[0-9A-Fa-f]\n[0-9A-Fa-f]\n\nruleunicode-string-literal\n\nA single quoted string literal allowing arbitrary unicode characters.\n\n'unicode'\n'\"'\n~[\"\\r\\n\\\\]\nescape-sequence\n'\"'\n'\\''\n~['\\r\\n\\\\]\nescape-sequence\n'\\''\n\nrulehex-string\n\nHex strings need to consist of an even number of hex digits that may be grouped using underscores.\n\n'hex'\n'\"'\n[0-9A-Fa-f]\n[0-9A-Fa-f]\n'_'\n'\"'\n'\\''\n[0-9A-Fa-f]\n[0-9A-Fa-f]\n'_'\n'\\''\n\nrulehex-number\n\nHex numbers consist of a prefix and an arbitrary number of hex digits that may be delimited by underscores.\n\n'0'\n'x'\n[0-9A-Fa-f]\n'_'\n\nruledecimal-number\n\nA decimal number literal consists of decimal digits that may be delimited by underscores and an optional positive or negative exponent. If the digits contain a decimal point, the literal has fixed point type.\n\n[0-9]\n'_'\n[0-9]\n'_'\n'.'\n[0-9]\n'_'\n[eE]\n'-'\n[0-9]\n'_'\n\nruleidentifier\n\nAn identifier in solidity has to start with a letter, a dollar-sign or an underscore and may additionally contain numbers after the first symbol.\n\n[a-zA-Z$_]\n[a-zA-Z0-9$_]\n\nruleyul-evm-builtin\n\nBuiltin functions in the EVM Yul dialect.\n\n'stop'\n'add'\n'sub'\n'mul'\n'div'\n'sdiv'\n'mod'\n'smod'\n'exp'\n'not'\n'lt'\n'gt'\n'slt'\n'sgt'\n'eq'\n'iszero'\n'and'\n'or'\n'xor'\n'byte'\n'shl'\n'shr'\n'sar'\n'addmod'\n'mulmod'\n'signextend'\n'keccak256'\n'pop'\n'mload'\n'mstore'\n'mstore8'\n'sload'\n'sstore'\n'msize'\n'gas'\n'address'\n'balance'\n'selfbalance'\n'caller'\n'callvalue'\n'calldataload'\n'calldatasize'\n'calldatacopy'\n'extcodesize'\n'extcodecopy'\n'returndatasize'\n'returndatacopy'\n'extcodehash'\n'create'\n'create2'\n'call'\n'callcode'\n'delegatecall'\n'staticcall'\n'return'\n'revert'\n'selfdestruct'\n'invalid'\n'log0'\n'log1'\n'log2'\n'log3'\n'log4'\n'chainid'\n'origin'\n'gasprice'\n'blockhash'\n'coinbase'\n'timestamp'\n'number'\n'difficulty'\n'prevrandao'\n'gaslimit'\n'basefee'\n\nruleyul-identifier\n\nYul identifiers consist of letters, dollar signs, underscores and numbers, but may not start with a number. In inline assembly there cannot be dots in user-defined identifiers. Instead see yulPath for expressions consisting of identifiers with dots.\n\n[a-zA-Z$_]\n[a-zA-Z0-9$_]\n\nruleyul-hex-number\n\nHex literals in Yul consist of a prefix and one or more hexadecimal digits.\n\n'0'\n'x'\n[0-9a-fA-F]\n\nruleyul-decimal-number\n\nDecimal literals in Yul may be zero or any sequence of decimal digits without leading zeroes.\n\n'0'\n[1-9]\n[0-9]\n\nruleyul-string-literal\n\nString literals in Yul consist of one or more double-quoted or single-quoted strings that may contain escape sequences and printable characters except unescaped line breaks or unescaped double-quotes or single-quotes, respectively.\n\n'\"'\ndouble-quoted-printable\nescape-sequence\n'\"'\n'\\''\nsingle-quoted-printable\nescape-sequence\n'\\''\n\nrulepragma-token\n\nPragma token. Can contain any kind of symbol except a semicolon. Note that currently the solidity parser only allows a subset of this.\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Cheatsheet — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/cheatsheet.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nInline Assembly\nCheatsheet\nOrder of Precedence of Operators\nABI Encoding and Decoding Functions\nMembers of bytes and string\nMembers of address\nBlock and Transaction Properties\nValidations and Assertions\nMathematical and Cryptographic Functions\nContract-related\nType Information\nFunction Visibility Specifiers\nModifiers\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Cheatsheet\n Edit on GitHub\nCheatsheet\nOrder of Precedence of Operators\n\nThe following is the order of precedence for operators, listed in order of evaluation.\n\nPrecedence\n\n\t\n\nDescription\n\n\t\n\nOperator\n\n\n\n\n1\n\n\t\n\nPostfix increment and decrement\n\n\t\n\n++, --\n\n\n\n\nNew expression\n\n\t\n\nnew <typename>\n\n\n\n\nArray subscripting\n\n\t\n\n<array>[<index>]\n\n\n\n\nMember access\n\n\t\n\n<object>.<member>\n\n\n\n\nFunction-like call\n\n\t\n\n<func>(<args...>)\n\n\n\n\nParentheses\n\n\t\n\n(<statement>)\n\n\n\n\n2\n\n\t\n\nPrefix increment and decrement\n\n\t\n\n++, --\n\n\n\n\nUnary minus\n\n\t\n\n-\n\n\n\n\nUnary operations\n\n\t\n\ndelete\n\n\n\n\nLogical NOT\n\n\t\n\n!\n\n\n\n\nBitwise NOT\n\n\t\n\n~\n\n\n\n\n3\n\n\t\n\nExponentiation\n\n\t\n\n**\n\n\n\n\n4\n\n\t\n\nMultiplication, division and modulo\n\n\t\n\n*, /, %\n\n\n\n\n5\n\n\t\n\nAddition and subtraction\n\n\t\n\n+, -\n\n\n\n\n6\n\n\t\n\nBitwise shift operators\n\n\t\n\n<<, >>\n\n\n\n\n7\n\n\t\n\nBitwise AND\n\n\t\n\n&\n\n\n\n\n8\n\n\t\n\nBitwise XOR\n\n\t\n\n^\n\n\n\n\n9\n\n\t\n\nBitwise OR\n\n\t\n\n|\n\n\n\n\n10\n\n\t\n\nInequality operators\n\n\t\n\n<, >, <=, >=\n\n\n\n\n11\n\n\t\n\nEquality operators\n\n\t\n\n==, !=\n\n\n\n\n12\n\n\t\n\nLogical AND\n\n\t\n\n&&\n\n\n\n\n13\n\n\t\n\nLogical OR\n\n\t\n\n||\n\n\n\n\n14\n\n\t\n\nTernary operator\n\n\t\n\n<conditional> ? <if-true> : <if-false>\n\n\n\n\nAssignment operators\n\n\t\n\n=, |=, ^=, &=, <<=, >>=, +=, -=, *=, /=, %=\n\n\n\n\n15\n\n\t\n\nComma operator\n\n\t\n\n,\n\nABI Encoding and Decoding Functions\n\nabi.decode(bytes memory encodedData, (...)) returns (...): ABI-decodes the provided data. The types are given in parentheses as second argument. Example: (uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))\n\nabi.encode(...) returns (bytes memory): ABI-encodes the given arguments\n\nabi.encodePacked(...) returns (bytes memory): Performs packed encoding of the given arguments. Note that this encoding can be ambiguous!\n\nabi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory): ABI-encodes the given arguments starting from the second and prepends the given four-byte selector\n\nabi.encodeCall(function functionPointer, (...)) returns (bytes memory): ABI-encodes a call to functionPointer with the arguments found in the tuple. Performs a full type-check, ensuring the types match the function signature. Result equals abi.encodeWithSelector(functionPointer.selector, (...))\n\nabi.encodeWithSignature(string memory signature, ...) returns (bytes memory): Equivalent to abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)\n\nMembers of bytes and string\n\nbytes.concat(...) returns (bytes memory): Concatenates variable number of arguments to one byte array\n\nstring.concat(...) returns (string memory): Concatenates variable number of arguments to one string array\n\nMembers of address\n\n<address>.balance (uint256): balance of the Address in Wei\n\n<address>.code (bytes memory): code at the Address (can be empty)\n\n<address>.codehash (bytes32): the codehash of the Address\n\n<address payable>.send(uint256 amount) returns (bool): send given amount of Wei to Address, returns false on failure\n\n<address payable>.transfer(uint256 amount): send given amount of Wei to Address, throws on failure\n\nBlock and Transaction Properties\n\nblockhash(uint blockNumber) returns (bytes32): hash of the given block - only works for 256 most recent blocks\n\nblock.basefee (uint): current block’s base fee (EIP-3198 and EIP-1559)\n\nblock.chainid (uint): current chain id\n\nblock.coinbase (address payable): current block miner’s address\n\nblock.difficulty (uint): current block difficulty (EVM < Paris). For other EVM versions it behaves as a deprecated alias for block.prevrandao that will be removed in the next breaking release\n\nblock.gaslimit (uint): current block gaslimit\n\nblock.number (uint): current block number\n\nblock.prevrandao (uint): random number provided by the beacon chain (EVM >= Paris) (see EIP-4399 )\n\nblock.timestamp (uint): current block timestamp in seconds since Unix epoch\n\ngasleft() returns (uint256): remaining gas\n\nmsg.data (bytes): complete calldata\n\nmsg.sender (address): sender of the message (current call)\n\nmsg.sig (bytes4): first four bytes of the calldata (i.e. function identifier)\n\nmsg.value (uint): number of wei sent with the message\n\ntx.gasprice (uint): gas price of the transaction\n\ntx.origin (address): sender of the transaction (full call chain)\n\nValidations and Assertions\n\nassert(bool condition): abort execution and revert state changes if condition is false (use for internal error)\n\nrequire(bool condition): abort execution and revert state changes if condition is false (use for malformed input or error in external component)\n\nrequire(bool condition, string memory message): abort execution and revert state changes if condition is false (use for malformed input or error in external component). Also provide error message.\n\nrevert(): abort execution and revert state changes\n\nrevert(string memory message): abort execution and revert state changes providing an explanatory string\n\nMathematical and Cryptographic Functions\n\nkeccak256(bytes memory) returns (bytes32): compute the Keccak-256 hash of the input\n\nsha256(bytes memory) returns (bytes32): compute the SHA-256 hash of the input\n\nripemd160(bytes memory) returns (bytes20): compute the RIPEMD-160 hash of the input\n\necrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address): recover address associated with the public key from elliptic curve signature, return zero on error\n\naddmod(uint x, uint y, uint k) returns (uint): compute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.\n\nmulmod(uint x, uint y, uint k) returns (uint): compute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.\n\nContract-related\n\nthis (current contract’s type): the current contract, explicitly convertible to address or address payable\n\nsuper: a contract one level higher in the inheritance hierarchy\n\nselfdestruct(address payable recipient): destroy the current contract, sending its funds to the given address\n\nType Information\n\ntype(C).name (string): the name of the contract\n\ntype(C).creationCode (bytes memory): creation bytecode of the given contract, see Type Information.\n\ntype(C).runtimeCode (bytes memory): runtime bytecode of the given contract, see Type Information.\n\ntype(I).interfaceId (bytes4): value containing the EIP-165 interface identifier of the given interface, see Type Information.\n\ntype(T).min (T): the minimum value representable by the integer type T, see Type Information.\n\ntype(T).max (T): the maximum value representable by the integer type T, see Type Information.\n\nFunction Visibility Specifiers\n\nopen in Remix\n\nfunction myFunction() <visibility specifier> returns (bool) {\n    return true;\n}\n\n\npublic: visible externally and internally (creates a getter function for storage/state variables)\n\nprivate: only visible in the current contract\n\nexternal: only visible externally (only for functions) - i.e. can only be message-called (via this.func)\n\ninternal: only visible internally\n\nModifiers\n\npure for functions: Disallows modification or access of state.\n\nview for functions: Disallows modification of state.\n\npayable for functions: Allows them to receive Ether together with a call.\n\nconstant for state variables: Disallows assignment (except initialisation), does not occupy storage slot.\n\nimmutable for state variables: Allows assignment at construction time and is constant when deployed. Is stored in code.\n\nanonymous for events: Does not store event signature as topic.\n\nindexed for event parameters: Stores the parameter as topic.\n\nvirtual for functions and modifiers: Allows the function’s or modifier’s behavior to be changed in derived contracts.\n\noverride: States that this function, modifier or public state variable changes the behavior of a function or modifier in a base contract.\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Inline Assembly — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/assembly.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nInline Assembly\nExample\nAccess to External Variables, Functions and Libraries\nThings to Avoid\nConventions in Solidity\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Inline Assembly\n Edit on GitHub\nInline Assembly\n\nYou can interleave Solidity statements with inline assembly in a language close to the one of the Ethereum Virtual Machine. This gives you more fine-grained control, which is especially useful when you are enhancing the language by writing libraries.\n\nThe language used for inline assembly in Solidity is called Yul and it is documented in its own section. This section will only cover how the inline assembly code can interface with the surrounding Solidity code.\n\nWarning\n\nInline assembly is a way to access the Ethereum Virtual Machine at a low level. This bypasses several important safety features and checks of Solidity. You should only use it for tasks that need it, and only if you are confident with using it.\n\nAn inline assembly block is marked by assembly { ... }, where the code inside the curly braces is code in the Yul language.\n\nThe inline assembly code can access local Solidity variables as explained below.\n\nDifferent inline assembly blocks share no namespace, i.e. it is not possible to call a Yul function or access a Yul variable defined in a different inline assembly block.\n\nExample\n\nThe following example provides library code to access the code of another contract and load it into a bytes variable. This is possible with “plain Solidity” too, by using <address>.code. But the point here is that reusable assembly libraries can enhance the Solidity language without a compiler change.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\nlibrary GetCode {\n    function at(address addr) public view returns (bytes memory code) {\n        assembly {\n            // retrieve the size of the code, this needs assembly\n            let size := extcodesize(addr)\n            // allocate output byte array - this could also be done without assembly\n            // by using code = new bytes(size)\n            code := mload(0x40)\n            // new \"memory end\" including padding\n            mstore(0x40, add(code, and(add(add(size, 0x20), 0x1f), not(0x1f))))\n            // store length in memory\n            mstore(code, size)\n            // actually retrieve the code, this needs assembly\n            extcodecopy(addr, add(code, 0x20), 0, size)\n        }\n    }\n}\n\n\nInline assembly is also beneficial in cases where the optimizer fails to produce efficient code, for example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\n\nlibrary VectorSum {\n    // This function is less efficient because the optimizer currently fails to\n    // remove the bounds checks in array access.\n    function sumSolidity(uint[] memory data) public pure returns (uint sum) {\n        for (uint i = 0; i < data.length; ++i)\n            sum += data[i];\n    }\n\n    // We know that we only access the array in bounds, so we can avoid the check.\n    // 0x20 needs to be added to an array because the first slot contains the\n    // array length.\n    function sumAsm(uint[] memory data) public pure returns (uint sum) {\n        for (uint i = 0; i < data.length; ++i) {\n            assembly {\n                sum := add(sum, mload(add(add(data, 0x20), mul(i, 0x20))))\n            }\n        }\n    }\n\n    // Same as above, but accomplish the entire code within inline assembly.\n    function sumPureAsm(uint[] memory data) public pure returns (uint sum) {\n        assembly {\n            // Load the length (first 32 bytes)\n            let len := mload(data)\n\n            // Skip over the length field.\n            //\n            // Keep temporary variable so it can be incremented in place.\n            //\n            // NOTE: incrementing data would result in an unusable\n            //       data variable after this assembly block\n            let dataElementLocation := add(data, 0x20)\n\n            // Iterate until the bound is not met.\n            for\n                { let end := add(dataElementLocation, mul(len, 0x20)) }\n                lt(dataElementLocation, end)\n                { dataElementLocation := add(dataElementLocation, 0x20) }\n            {\n                sum := add(sum, mload(dataElementLocation))\n            }\n        }\n    }\n}\n\nAccess to External Variables, Functions and Libraries\n\nYou can access Solidity variables and other identifiers by using their name.\n\nLocal variables of value type are directly usable in inline assembly. They can both be read and assigned to.\n\nLocal variables that refer to memory evaluate to the address of the variable in memory, not the value itself. Such variables can also be assigned to, but note that an assignment will only change the pointer and not the data and that it is your responsibility to respect Solidity’s memory management. See Conventions in Solidity.\n\nSimilarly, local variables that refer to statically-sized calldata arrays or calldata structs evaluate to the address of the variable in calldata, not the value itself. The variable can also be assigned a new offset, but note that no validation is performed to ensure that the variable will not point beyond calldatasize().\n\nFor external function pointers the address and the function selector can be accessed using x.address and x.selector. The selector consists of four right-aligned bytes. Both values can be assigned to. For example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.10 <0.9.0;\n\ncontract C {\n    // Assigns a new selector and address to the return variable @fun\n    function combineToFunctionPointer(address newAddress, uint newSelector) public pure returns (function() external fun) {\n        assembly {\n            fun.selector := newSelector\n            fun.address  := newAddress\n        }\n    }\n}\n\n\nFor dynamic calldata arrays, you can access their calldata offset (in bytes) and length (number of elements) using x.offset and x.length. Both expressions can also be assigned to, but as for the static case, no validation will be performed to ensure that the resulting data area is within the bounds of calldatasize().\n\nFor local storage variables or state variables, a single Yul identifier is not sufficient, since they do not necessarily occupy a single full storage slot. Therefore, their “address” is composed of a slot and a byte-offset inside that slot. To retrieve the slot pointed to by the variable x, you use x.slot, and to retrieve the byte-offset you use x.offset. Using x itself will result in an error.\n\nYou can also assign to the .slot part of a local storage variable pointer. For these (structs, arrays or mappings), the .offset part is always zero. It is not possible to assign to the .slot or .offset part of a state variable, though.\n\nLocal Solidity variables are available for assignments, for example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract C {\n    uint b;\n    function f(uint x) public view returns (uint r) {\n        assembly {\n            // We ignore the storage slot offset, we know it is zero\n            // in this special case.\n            r := mul(x, sload(b.slot))\n        }\n    }\n}\n\n\nWarning\n\nIf you access variables of a type that spans less than 256 bits (for example uint64, address, or bytes16), you cannot make any assumptions about bits not part of the encoding of the type. Especially, do not assume them to be zero. To be safe, always clear the data properly before you use it in a context where this is important: uint32 x = f(); assembly { x := and(x, 0xffffffff) /* now use x */ } To clean signed types, you can use the signextend opcode: assembly { signextend(<num_bytes_of_x_minus_one>, x) }\n\nSince Solidity 0.6.0, the name of a inline assembly variable may not shadow any declaration visible in the scope of the inline assembly block (including variable, contract and function declarations).\n\nSince Solidity 0.7.0, variables and functions declared inside the inline assembly block may not contain ., but using . is valid to access Solidity variables from outside the inline assembly block.\n\nThings to Avoid\n\nInline assembly might have a quite high-level look, but it actually is extremely low-level. Function calls, loops, ifs and switches are converted by simple rewriting rules and after that, the only thing the assembler does for you is re-arranging functional-style opcodes, counting stack height for variable access and removing stack slots for assembly-local variables when the end of their block is reached.\n\nConventions in Solidity\nValues of Typed Variables\n\nIn contrast to EVM assembly, Solidity has types which are narrower than 256 bits, e.g. uint24. For efficiency, most arithmetic operations ignore the fact that types can be shorter than 256 bits, and the higher-order bits are cleaned when necessary, i.e., shortly before they are written to memory or before comparisons are performed. This means that if you access such a variable from within inline assembly, you might have to manually clean the higher-order bits first.\n\nMemory Management\n\nSolidity manages memory in the following way. There is a “free memory pointer” at position 0x40 in memory. If you want to allocate memory, use the memory starting from where this pointer points at and update it. There is no guarantee that the memory has not been used before and thus you cannot assume that its contents are zero bytes. There is no built-in mechanism to release or free allocated memory. Here is an assembly snippet you can use for allocating memory that follows the process outlined above:\n\nopen in Remix\n\nfunction allocate(length) -> pos {\n  pos := mload(0x40)\n  mstore(0x40, add(pos, length))\n}\n\n\nThe first 64 bytes of memory can be used as “scratch space” for short-term allocation. The 32 bytes after the free memory pointer (i.e., starting at 0x60) are meant to be zero permanently and is used as the initial value for empty dynamic memory arrays. This means that the allocatable memory starts at 0x80, which is the initial value of the free memory pointer.\n\nElements in memory arrays in Solidity always occupy multiples of 32 bytes (this is even true for bytes1[], but not for bytes and string). Multi-dimensional memory arrays are pointers to memory arrays. The length of a dynamic array is stored at the first slot of the array and followed by the array elements.\n\nWarning\n\nStatically-sized memory arrays do not have a length field, but it might be added later to allow better convertibility between statically and dynamically-sized arrays; so, do not rely on this.\n\nMemory Safety\n\nWithout the use of inline assembly, the compiler can rely on memory to remain in a well-defined state at all times. This is especially relevant for the new code generation pipeline via Yul IR: this code generation path can move local variables from stack to memory to avoid stack-too-deep errors and perform additional memory optimizations, if it can rely on certain assumptions about memory use.\n\nWhile we recommend to always respect Solidity’s memory model, inline assembly allows you to use memory in an incompatible way. Therefore, moving stack variables to memory and additional memory optimizations are, by default, globally disabled in the presence of any inline assembly block that contains a memory operation or assigns to Solidity variables in memory.\n\nHowever, you can specifically annotate an assembly block to indicate that it in fact respects Solidity’s memory model as follows:\n\nopen in Remix\n\nassembly (\"memory-safe\") {\n    ...\n}\n\n\nIn particular, a memory-safe assembly block may only access the following memory ranges:\n\nMemory allocated by yourself using a mechanism like the allocate function described above.\n\nMemory allocated by Solidity, e.g. memory within the bounds of a memory array you reference.\n\nThe scratch space between memory offset 0 and 64 mentioned above.\n\nTemporary memory that is located after the value of the free memory pointer at the beginning of the assembly block, i.e. memory that is “allocated” at the free memory pointer without updating the free memory pointer.\n\nFurthermore, if the assembly block assigns to Solidity variables in memory, you need to assure that accesses to the Solidity variables only access these memory ranges.\n\nSince this is mainly about the optimizer, these restrictions still need to be followed, even if the assembly block reverts or terminates. As an example, the following assembly snippet is not memory safe, because the value of returndatasize() may exceed the 64 byte scratch space:\n\nopen in Remix\n\nassembly {\n  returndatacopy(0, 0, returndatasize())\n  revert(0, returndatasize())\n}\n\n\nOn the other hand, the following code is memory safe, because memory beyond the location pointed to by the free memory pointer can safely be used as temporary scratch space:\n\nopen in Remix\n\nassembly (\"memory-safe\") {\n  let p := mload(0x40)\n  returndatacopy(p, 0, returndatasize())\n  revert(p, returndatasize())\n}\n\n\nNote that you do not need to update the free memory pointer if there is no following allocation, but you can only use memory starting from the current offset given by the free memory pointer.\n\nIf the memory operations use a length of zero, it is also fine to just use any offset (not only if it falls into the scratch space):\n\nopen in Remix\n\nassembly (\"memory-safe\") {\n  revert(0, 0)\n}\n\n\nNote that not only memory operations in inline assembly itself can be memory-unsafe, but also assignments to Solidity variables of reference type in memory. For example the following is not memory-safe:\n\nopen in Remix\n\nbytes memory x;\nassembly {\n  x := 0x40\n}\nx[0x20] = 0x42;\n\n\nInline assembly that neither involves any operations that access memory nor assigns to any Solidity variables in memory is automatically considered memory-safe and does not need to be annotated.\n\nWarning\n\nIt is your responsibility to make sure that the assembly actually satisfies the memory model. If you annotate an assembly block as memory-safe, but violate one of the memory assumptions, this will lead to incorrect and undefined behavior that cannot easily be discovered by testing.\n\nIn case you are developing a library that is meant to be compatible across multiple versions of Solidity, you can use a special comment to annotate an assembly block as memory-safe:\n\nopen in Remix\n\n/// @solidity memory-safe-assembly\nassembly {\n    ...\n}\n\n\nNote that we will disallow the annotation via comment in a future breaking release; so, if you are not concerned with backward-compatibility with older compiler versions, prefer using the dialect string.\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Contracts — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/contracts.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nCreating Contracts\nVisibility and Getters\nFunction Modifiers\nConstant and Immutable State Variables\nFunctions\nEvents\nErrors and the Revert Statement\nInheritance\nAbstract Contracts\nInterfaces\nLibraries\nUsing For\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Contracts\n Edit on GitHub\nContracts\n\nContracts in Solidity are similar to classes in object-oriented languages. They contain persistent data in state variables, and functions that can modify these variables. Calling a function on a different contract (instance) will perform an EVM function call and thus switch the context such that state variables in the calling contract are inaccessible. A contract and its functions need to be called for anything to happen. There is no “cron” concept in Ethereum to call a function at a particular event automatically.\n\nCreating Contracts\n\nContracts can be created “from outside” via Ethereum transactions or from within Solidity contracts.\n\nIDEs, such as Remix, make the creation process seamless using UI elements.\n\nOne way to create contracts programmatically on Ethereum is via the JavaScript API web3.js. It has a function called web3.eth.Contract to facilitate contract creation.\n\nWhen a contract is created, its constructor (a function declared with the constructor keyword) is executed once.\n\nA constructor is optional. Only one constructor is allowed, which means overloading is not supported.\n\nAfter the constructor has executed, the final code of the contract is stored on the blockchain. This code includes all public and external functions and all functions that are reachable from there through function calls. The deployed code does not include the constructor code or internal functions only called from the constructor.\n\nInternally, constructor arguments are passed ABI encoded after the code of the contract itself, but you do not have to care about this if you use web3.js.\n\nIf a contract wants to create another contract, the source code (and the binary) of the created contract has to be known to the creator. This means that cyclic creation dependencies are impossible.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\n\ncontract OwnedToken {\n    // `TokenCreator` is a contract type that is defined below.\n    // It is fine to reference it as long as it is not used\n    // to create a new contract.\n    TokenCreator creator;\n    address owner;\n    bytes32 name;\n\n    // This is the constructor which registers the\n    // creator and the assigned name.\n    constructor(bytes32 name_) {\n        // State variables are accessed via their name\n        // and not via e.g. `this.owner`. Functions can\n        // be accessed directly or through `this.f`,\n        // but the latter provides an external view\n        // to the function. Especially in the constructor,\n        // you should not access functions externally,\n        // because the function does not exist yet.\n        // See the next section for details.\n        owner = msg.sender;\n\n        // We perform an explicit type conversion from `address`\n        // to `TokenCreator` and assume that the type of\n        // the calling contract is `TokenCreator`, there is\n        // no real way to verify that.\n        // This does not create a new contract.\n        creator = TokenCreator(msg.sender);\n        name = name_;\n    }\n\n    function changeName(bytes32 newName) public {\n        // Only the creator can alter the name.\n        // We compare the contract based on its\n        // address which can be retrieved by\n        // explicit conversion to address.\n        if (msg.sender == address(creator))\n            name = newName;\n    }\n\n    function transfer(address newOwner) public {\n        // Only the current owner can transfer the token.\n        if (msg.sender != owner) return;\n\n        // We ask the creator contract if the transfer\n        // should proceed by using a function of the\n        // `TokenCreator` contract defined below. If\n        // the call fails (e.g. due to out-of-gas),\n        // the execution also fails here.\n        if (creator.isTokenTransferOK(owner, newOwner))\n            owner = newOwner;\n    }\n}\n\n\ncontract TokenCreator {\n    function createToken(bytes32 name)\n        public\n        returns (OwnedToken tokenAddress)\n    {\n        // Create a new `Token` contract and return its address.\n        // From the JavaScript side, the return type\n        // of this function is `address`, as this is\n        // the closest type available in the ABI.\n        return new OwnedToken(name);\n    }\n\n    function changeName(OwnedToken tokenAddress, bytes32 name) public {\n        // Again, the external type of `tokenAddress` is\n        // simply `address`.\n        tokenAddress.changeName(name);\n    }\n\n    // Perform checks to determine if transferring a token to the\n    // `OwnedToken` contract should proceed\n    function isTokenTransferOK(address currentOwner, address newOwner)\n        public\n        pure\n        returns (bool ok)\n    {\n        // Check an arbitrary condition to see if transfer should proceed\n        return keccak256(abi.encodePacked(currentOwner, newOwner))[0] == 0x7f;\n    }\n}\n\nVisibility and Getters\nState Variable Visibility\npublic\n\nPublic state variables differ from internal ones only in that the compiler automatically generates getter functions for them, which allows other contracts to read their values. When used within the same contract, the external access (e.g. this.x) invokes the getter while internal access (e.g. x) gets the variable value directly from storage. Setter functions are not generated so other contracts cannot directly modify their values.\n\ninternal\n\nInternal state variables can only be accessed from within the contract they are defined in and in derived contracts. They cannot be accessed externally. This is the default visibility level for state variables.\n\nprivate\n\nPrivate state variables are like internal ones but they are not visible in derived contracts.\n\nWarning\n\nMaking something private or internal only prevents other contracts from reading or modifying the information, but it will still be visible to the whole world outside of the blockchain.\n\nFunction Visibility\n\nSolidity knows two kinds of function calls: external ones that do create an actual EVM message call and internal ones that do not. Furthermore, internal functions can be made inaccessible to derived contracts. This gives rise to four types of visibility for functions.\n\nexternal\n\nExternal functions are part of the contract interface, which means they can be called from other contracts and via transactions. An external function f cannot be called internally (i.e. f() does not work, but this.f() works).\n\npublic\n\nPublic functions are part of the contract interface and can be either called internally or via message calls.\n\ninternal\n\nInternal functions can only be accessed from within the current contract or contracts deriving from it. They cannot be accessed externally. Since they are not exposed to the outside through the contract’s ABI, they can take parameters of internal types like mappings or storage references.\n\nprivate\n\nPrivate functions are like internal ones but they are not visible in derived contracts.\n\nWarning\n\nMaking something private or internal only prevents other contracts from reading or modifying the information, but it will still be visible to the whole world outside of the blockchain.\n\nThe visibility specifier is given after the type for state variables and between parameter list and return parameter list for functions.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f(uint a) private pure returns (uint b) { return a + 1; }\n    function setData(uint a) internal { data = a; }\n    uint public data;\n}\n\n\nIn the following example, D, can call c.getData() to retrieve the value of data in state storage, but is not able to call f. Contract E is derived from C and, thus, can call compute.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    uint private data;\n\n    function f(uint a) private pure returns(uint b) { return a + 1; }\n    function setData(uint a) public { data = a; }\n    function getData() public view returns(uint) { return data; }\n    function compute(uint a, uint b) internal pure returns (uint) { return a + b; }\n}\n\n// This will not compile\ncontract D {\n    function readData() public {\n        C c = new C();\n        uint local = c.f(7); // error: member `f` is not visible\n        c.setData(3);\n        local = c.getData();\n        local = c.compute(3, 5); // error: member `compute` is not visible\n    }\n}\n\ncontract E is C {\n    function g() public {\n        C c = new C();\n        uint val = compute(3, 5); // access to internal member (from derived to parent contract)\n    }\n}\n\nGetter Functions\n\nThe compiler automatically creates getter functions for all public state variables. For the contract given below, the compiler will generate a function called data that does not take any arguments and returns a uint, the value of the state variable data. State variables can be initialized when they are declared.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    uint public data = 42;\n}\n\ncontract Caller {\n    C c = new C();\n    function f() public view returns (uint) {\n        return c.data();\n    }\n}\n\n\nThe getter functions have external visibility. If the symbol is accessed internally (i.e. without this.), it evaluates to a state variable. If it is accessed externally (i.e. with this.), it evaluates to a function.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract C {\n    uint public data;\n    function x() public returns (uint) {\n        data = 3; // internal access\n        return this.data(); // external access\n    }\n}\n\n\nIf you have a public state variable of array type, then you can only retrieve single elements of the array via the generated getter function. This mechanism exists to avoid high gas costs when returning an entire array. You can use arguments to specify which individual element to return, for example myArray(0). If you want to return an entire array in one call, then you need to write a function, for example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract arrayExample {\n    // public state variable\n    uint[] public myArray;\n\n    // Getter function generated by the compiler\n    /*\n    function myArray(uint i) public view returns (uint) {\n        return myArray[i];\n    }\n    */\n\n    // function that returns entire array\n    function getArray() public view returns (uint[] memory) {\n        return myArray;\n    }\n}\n\n\nNow you can use getArray() to retrieve the entire array, instead of myArray(i), which returns a single element per call.\n\nThe next example is more complex:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract Complex {\n    struct Data {\n        uint a;\n        bytes3 b;\n        mapping(uint => uint) map;\n        uint[3] c;\n        uint[] d;\n        bytes e;\n    }\n    mapping(uint => mapping(bool => Data[])) public data;\n}\n\n\nIt generates a function of the following form. The mapping and arrays (with the exception of byte arrays) in the struct are omitted because there is no good way to select individual struct members or provide a key for the mapping:\n\nopen in Remix\n\nfunction data(uint arg1, bool arg2, uint arg3)\n    public\n    returns (uint a, bytes3 b, bytes memory e)\n{\n    a = data[arg1][arg2][arg3].a;\n    b = data[arg1][arg2][arg3].b;\n    e = data[arg1][arg2][arg3].e;\n}\n\nFunction Modifiers\n\nModifiers can be used to change the behavior of functions in a declarative way. For example, you can use a modifier to automatically check a condition prior to executing the function.\n\nModifiers are inheritable properties of contracts and may be overridden by derived contracts, but only if they are marked virtual. For details, please see Modifier Overriding.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1 <0.9.0;\n// This will report a warning due to deprecated selfdestruct\n\ncontract owned {\n    constructor() { owner = payable(msg.sender); }\n    address payable owner;\n\n    // This contract only defines a modifier but does not use\n    // it: it will be used in derived contracts.\n    // The function body is inserted where the special symbol\n    // `_;` in the definition of a modifier appears.\n    // This means that if the owner calls this function, the\n    // function is executed and otherwise, an exception is\n    // thrown.\n    modifier onlyOwner {\n        require(\n            msg.sender == owner,\n            \"Only owner can call this function.\"\n        );\n        _;\n    }\n}\n\ncontract destructible is owned {\n    // This contract inherits the `onlyOwner` modifier from\n    // `owned` and applies it to the `destroy` function, which\n    // causes that calls to `destroy` only have an effect if\n    // they are made by the stored owner.\n    function destroy() public onlyOwner {\n        selfdestruct(owner);\n    }\n}\n\ncontract priced {\n    // Modifiers can receive arguments:\n    modifier costs(uint price) {\n        if (msg.value >= price) {\n            _;\n        }\n    }\n}\n\ncontract Register is priced, destructible {\n    mapping(address => bool) registeredAddresses;\n    uint price;\n\n    constructor(uint initialPrice) { price = initialPrice; }\n\n    // It is important to also provide the\n    // `payable` keyword here, otherwise the function will\n    // automatically reject all Ether sent to it.\n    function register() public payable costs(price) {\n        registeredAddresses[msg.sender] = true;\n    }\n\n    function changePrice(uint price_) public onlyOwner {\n        price = price_;\n    }\n}\n\ncontract Mutex {\n    bool locked;\n    modifier noReentrancy() {\n        require(\n            !locked,\n            \"Reentrant call.\"\n        );\n        locked = true;\n        _;\n        locked = false;\n    }\n\n    /// This function is protected by a mutex, which means that\n    /// reentrant calls from within `msg.sender.call` cannot call `f` again.\n    /// The `return 7` statement assigns 7 to the return value but still\n    /// executes the statement `locked = false` in the modifier.\n    function f() public noReentrancy returns (uint) {\n        (bool success,) = msg.sender.call(\"\");\n        require(success);\n        return 7;\n    }\n}\n\n\nIf you want to access a modifier m defined in a contract C, you can use C.m to reference it without virtual lookup. It is only possible to use modifiers defined in the current contract or its base contracts. Modifiers can also be defined in libraries but their use is limited to functions of the same library.\n\nMultiple modifiers are applied to a function by specifying them in a whitespace-separated list and are evaluated in the order presented.\n\nModifiers cannot implicitly access or change the arguments and return values of functions they modify. Their values can only be passed to them explicitly at the point of invocation.\n\nIn function modifiers, it is necessary to specify when you want the function to which the modifier is applied to be run. The placeholder statement (denoted by a single underscore character _) is used to denote where the body of the function being modified should be inserted. Note that the placeholder operator is different from using underscores as leading or trailing characters in variable names, which is a stylistic choice.\n\nExplicit returns from a modifier or function body only leave the current modifier or function body. Return variables are assigned and control flow continues after the _ in the preceding modifier.\n\nWarning\n\nIn an earlier version of Solidity, return statements in functions having modifiers behaved differently.\n\nAn explicit return from a modifier with return; does not affect the values returned by the function. The modifier can, however, choose not to execute the function body at all and in that case the return variables are set to their default values just as if the function had an empty body.\n\nThe _ symbol can appear in the modifier multiple times. Each occurrence is replaced with the function body, and the function returns the return value of the final occurrence.\n\nArbitrary expressions are allowed for modifier arguments and in this context, all symbols visible from the function are visible in the modifier. Symbols introduced in the modifier are not visible in the function (as they might change by overriding).\n\nConstant and Immutable State Variables\n\nState variables can be declared as constant or immutable. In both cases, the variables cannot be modified after the contract has been constructed. For constant variables, the value has to be fixed at compile-time, while for immutable, it can still be assigned at construction time.\n\nIt is also possible to define constant variables at the file level.\n\nThe compiler does not reserve a storage slot for these variables, and every occurrence is replaced by the respective value.\n\nCompared to regular state variables, the gas costs of constant and immutable variables are much lower. For a constant variable, the expression assigned to it is copied to all the places where it is accessed and also re-evaluated each time. This allows for local optimizations. Immutable variables are evaluated once at construction time and their value is copied to all the places in the code where they are accessed. For these values, 32 bytes are reserved, even if they would fit in fewer bytes. Due to this, constant values can sometimes be cheaper than immutable values.\n\nNot all types for constants and immutables are implemented at this time. The only supported types are strings (only for constants) and value types.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.21;\n\nuint constant X = 32**22 + 8;\n\ncontract C {\n    string constant TEXT = \"abc\";\n    bytes32 constant MY_HASH = keccak256(\"abc\");\n    uint immutable decimals = 18;\n    uint immutable maxBalance;\n    address immutable owner = msg.sender;\n\n    constructor(uint decimals_, address ref) {\n        if (decimals_ != 0)\n            // Immutables are only immutable when deployed.\n            // At construction time they can be assigned to any number of times.\n            decimals = decimals_;\n\n        // Assignments to immutables can even access the environment.\n        maxBalance = ref.balance;\n    }\n\n    function isBalanceTooHigh(address other) public view returns (bool) {\n        return other.balance > maxBalance;\n    }\n}\n\nConstant\n\nFor constant variables, the value has to be a constant at compile time and it has to be assigned where the variable is declared. Any expression that accesses storage, blockchain data (e.g. block.timestamp, address(this).balance or block.number) or execution data (msg.value or gasleft()) or makes calls to external contracts is disallowed. Expressions that might have a side-effect on memory allocation are allowed, but those that might have a side-effect on other memory objects are not. The built-in functions keccak256, sha256, ripemd160, ecrecover, addmod and mulmod are allowed (even though, with the exception of keccak256, they do call external contracts).\n\nThe reason behind allowing side-effects on the memory allocator is that it should be possible to construct complex objects like e.g. lookup-tables. This feature is not yet fully usable.\n\nImmutable\n\nVariables declared as immutable are a bit less restricted than those declared as constant: Immutable variables can be assigned a value at construction time. The value can be changed at any time before deployment and then it becomes permanent.\n\nOne additional restriction is that immutables can only be assigned to inside expressions for which there is no possibility of being executed after creation. This excludes all modifier definitions and functions other than constructors.\n\nThere are no restrictions on reading immutable variables. The read is even allowed to happen before the variable is written to for the first time because variables in Solidity always have a well-defined initial value. For this reason it is also allowed to never explicitly assign a value to an immutable.\n\nWarning\n\nWhen accessing immutables at construction time, please keep the initialization order in mind. Even if you provide an explicit initializer, some expressions may end up being evaluated before that initializer, especially when they are at a different level in inheritance hierarchy.\n\nNote\n\nBefore Solidity 0.8.21 initialization of immutable variables was more restrictive. Such variables had to be initialized exactly once at construction time and could not be read before then.\n\nThe contract creation code generated by the compiler will modify the contract’s runtime code before it is returned by replacing all references to immutables with the values assigned to them. This is important if you are comparing the runtime code generated by the compiler with the one actually stored in the blockchain. The compiler outputs where these immutables are located in the deployed bytecode in the immutableReferences field of the compiler JSON standard output.\n\nFunctions\n\nFunctions can be defined inside and outside of contracts.\n\nFunctions outside of a contract, also called “free functions”, always have implicit internal visibility. Their code is included in all contracts that call them, similar to internal library functions.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1 <0.9.0;\n\nfunction sum(uint[] memory arr) pure returns (uint s) {\n    for (uint i = 0; i < arr.length; i++)\n        s += arr[i];\n}\n\ncontract ArrayExample {\n    bool found;\n    function f(uint[] memory arr) public {\n        // This calls the free function internally.\n        // The compiler will add its code to the contract.\n        uint s = sum(arr);\n        require(s >= 10);\n        found = true;\n    }\n}\n\n\nNote\n\nFunctions defined outside a contract are still always executed in the context of a contract. They still can call other contracts, send them Ether and destroy the contract that called them, among other things. The main difference to functions defined inside a contract is that free functions do not have direct access to the variable this, storage variables and functions not in their scope.\n\nFunction Parameters and Return Variables\n\nFunctions take typed parameters as input and may, unlike in many other languages, also return an arbitrary number of values as output.\n\nFunction Parameters\n\nFunction parameters are declared the same way as variables, and the name of unused parameters can be omitted.\n\nFor example, if you want your contract to accept one kind of external call with two integers, you would use something like the following:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract Simple {\n    uint sum;\n    function taker(uint a, uint b) public {\n        sum = a + b;\n    }\n}\n\n\nFunction parameters can be used as any other local variable and they can also be assigned to.\n\nReturn Variables\n\nFunction return variables are declared with the same syntax after the returns keyword.\n\nFor example, suppose you want to return two results: the sum and the product of two integers passed as function parameters, then you use something like:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract Simple {\n    function arithmetic(uint a, uint b)\n        public\n        pure\n        returns (uint sum, uint product)\n    {\n        sum = a + b;\n        product = a * b;\n    }\n}\n\n\nThe names of return variables can be omitted. Return variables can be used as any other local variable and they are initialized with their default value and have that value until they are (re-)assigned.\n\nYou can either explicitly assign to return variables and then leave the function as above, or you can provide return values (either a single or multiple ones) directly with the return statement:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract Simple {\n    function arithmetic(uint a, uint b)\n        public\n        pure\n        returns (uint sum, uint product)\n    {\n        return (a + b, a * b);\n    }\n}\n\n\nIf you use an early return to leave a function that has return variables, you must provide return values together with the return statement.\n\nNote\n\nYou cannot return some types from non-internal functions. This includes the types listed below and any composite types that recursively contain them:\n\nmappings,\n\ninternal function types,\n\nreference types with location set to storage,\n\nmulti-dimensional arrays (applies only to ABI coder v1),\n\nstructs (applies only to ABI coder v1).\n\nThis restriction does not apply to library functions because of their different internal ABI.\n\nReturning Multiple Values\n\nWhen a function has multiple return types, the statement return (v0, v1, ..., vn) can be used to return multiple values. The number of components must be the same as the number of return variables and their types have to match, potentially after an implicit conversion.\n\nState Mutability\nView Functions\n\nFunctions can be declared view in which case they promise not to modify the state.\n\nNote\n\nIf the compiler’s EVM target is Byzantium or newer (default) the opcode STATICCALL is used when view functions are called, which enforces the state to stay unmodified as part of the EVM execution. For library view functions DELEGATECALL is used, because there is no combined DELEGATECALL and STATICCALL. This means library view functions do not have run-time checks that prevent state modifications. This should not impact security negatively because library code is usually known at compile-time and the static checker performs compile-time checks.\n\nThe following statements are considered modifying the state:\n\nWriting to state variables.\n\nEmitting events.\n\nCreating other contracts.\n\nUsing selfdestruct.\n\nSending Ether via calls.\n\nCalling any function not marked view or pure.\n\nUsing low-level calls.\n\nUsing inline assembly that contains certain opcodes.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract C {\n    function f(uint a, uint b) public view returns (uint) {\n        return a * (b + 42) + block.timestamp;\n    }\n}\n\n\nNote\n\nconstant on functions used to be an alias to view, but this was dropped in version 0.5.0.\n\nNote\n\nGetter methods are automatically marked view.\n\nNote\n\nPrior to version 0.5.0, the compiler did not use the STATICCALL opcode for view functions. This enabled state modifications in view functions through the use of invalid explicit type conversions. By using STATICCALL for view functions, modifications to the state are prevented on the level of the EVM.\n\nPure Functions\n\nFunctions can be declared pure in which case they promise not to read from or modify the state. In particular, it should be possible to evaluate a pure function at compile-time given only its inputs and msg.data, but without any knowledge of the current blockchain state. This means that reading from immutable variables can be a non-pure operation.\n\nNote\n\nIf the compiler’s EVM target is Byzantium or newer (default) the opcode STATICCALL is used, which does not guarantee that the state is not read, but at least that it is not modified.\n\nIn addition to the list of state modifying statements explained above, the following are considered reading from the state:\n\nReading from state variables.\n\nAccessing address(this).balance or <address>.balance.\n\nAccessing any of the members of block, tx, msg (with the exception of msg.sig and msg.data).\n\nCalling any function not marked pure.\n\nUsing inline assembly that contains certain opcodes.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract C {\n    function f(uint a, uint b) public pure returns (uint) {\n        return a * (b + 42);\n    }\n}\n\n\nPure functions are able to use the revert() and require() functions to revert potential state changes when an error occurs.\n\nReverting a state change is not considered a “state modification”, as only changes to the state made previously in code that did not have the view or pure restriction are reverted and that code has the option to catch the revert and not pass it on.\n\nThis behavior is also in line with the STATICCALL opcode.\n\nWarning\n\nIt is not possible to prevent functions from reading the state at the level of the EVM, it is only possible to prevent them from writing to the state (i.e. only view can be enforced at the EVM level, pure can not).\n\nNote\n\nPrior to version 0.5.0, the compiler did not use the STATICCALL opcode for pure functions. This enabled state modifications in pure functions through the use of invalid explicit type conversions. By using STATICCALL for pure functions, modifications to the state are prevented on the level of the EVM.\n\nNote\n\nPrior to version 0.4.17 the compiler did not enforce that pure is not reading the state. It is a compile-time type check, which can be circumvented doing invalid explicit conversions between contract types, because the compiler can verify that the type of the contract does not do state-changing operations, but it cannot check that the contract that will be called at runtime is actually of that type.\n\nSpecial Functions\nReceive Ether Function\n\nA contract can have at most one receive function, declared using receive() external payable { ... } (without the function keyword). This function cannot have arguments, cannot return anything and must have external visibility and payable state mutability. It can be virtual, can override and can have modifiers.\n\nThe receive function is executed on a call to the contract with empty calldata. This is the function that is executed on plain Ether transfers (e.g. via .send() or .transfer()). If no such function exists, but a payable fallback function exists, the fallback function will be called on a plain Ether transfer. If neither a receive Ether nor a payable fallback function is present, the contract cannot receive Ether through a transaction that does not represent a payable function call and throws an exception.\n\nIn the worst case, the receive function can only rely on 2300 gas being available (for example when send or transfer is used), leaving little room to perform other operations except basic logging. The following operations will consume more gas than the 2300 gas stipend:\n\nWriting to storage\n\nCreating a contract\n\nCalling an external function which consumes a large amount of gas\n\nSending Ether\n\nWarning\n\nWhen Ether is sent directly to a contract (without a function call, i.e. sender uses send or transfer) but the receiving contract does not define a receive Ether function or a payable fallback function, an exception will be thrown, sending back the Ether (this was different before Solidity v0.4.0). If you want your contract to receive Ether, you have to implement a receive Ether function (using payable fallback functions for receiving Ether is not recommended, since the fallback is invoked and would not fail for interface confusions on the part of the sender).\n\nWarning\n\nA contract without a receive Ether function can receive Ether as a recipient of a coinbase transaction (aka miner block reward) or as a destination of a selfdestruct.\n\nA contract cannot react to such Ether transfers and thus also cannot reject them. This is a design choice of the EVM and Solidity cannot work around it.\n\nIt also means that address(this).balance can be higher than the sum of some manual accounting implemented in a contract (i.e. having a counter updated in the receive Ether function).\n\nBelow you can see an example of a Sink contract that uses function receive.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\n// This contract keeps all Ether sent to it with no way\n// to get it back.\ncontract Sink {\n    event Received(address, uint);\n    receive() external payable {\n        emit Received(msg.sender, msg.value);\n    }\n}\n\nFallback Function\n\nA contract can have at most one fallback function, declared using either fallback () external [payable] or fallback (bytes calldata input) external [payable] returns (bytes memory output) (both without the function keyword). This function must have external visibility. A fallback function can be virtual, can override and can have modifiers.\n\nThe fallback function is executed on a call to the contract if none of the other functions match the given function signature, or if no data was supplied at all and there is no receive Ether function. The fallback function always receives data, but in order to also receive Ether it must be marked payable.\n\nIf the version with parameters is used, input will contain the full data sent to the contract (equal to msg.data) and can return data in output. The returned data will not be ABI-encoded. Instead it will be returned without modifications (not even padding).\n\nIn the worst case, if a payable fallback function is also used in place of a receive function, it can only rely on 2300 gas being available (see receive Ether function for a brief description of the implications of this).\n\nLike any function, the fallback function can execute complex operations as long as there is enough gas passed on to it.\n\nWarning\n\nA payable fallback function is also executed for plain Ether transfers, if no receive Ether function is present. It is recommended to always define a receive Ether function as well, if you define a payable fallback function to distinguish Ether transfers from interface confusions.\n\nNote\n\nIf you want to decode the input data, you can check the first four bytes for the function selector and then you can use abi.decode together with the array slice syntax to decode ABI-encoded data: (c, d) = abi.decode(input[4:], (uint256, uint256)); Note that this should only be used as a last resort and proper functions should be used instead.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.2 <0.9.0;\n\ncontract Test {\n    uint x;\n    // This function is called for all messages sent to\n    // this contract (there is no other function).\n    // Sending Ether to this contract will cause an exception,\n    // because the fallback function does not have the `payable`\n    // modifier.\n    fallback() external { x = 1; }\n}\n\ncontract TestPayable {\n    uint x;\n    uint y;\n    // This function is called for all messages sent to\n    // this contract, except plain Ether transfers\n    // (there is no other function except the receive function).\n    // Any call with non-empty calldata to this contract will execute\n    // the fallback function (even if Ether is sent along with the call).\n    fallback() external payable { x = 1; y = msg.value; }\n\n    // This function is called for plain Ether transfers, i.e.\n    // for every call with empty calldata.\n    receive() external payable { x = 2; y = msg.value; }\n}\n\ncontract Caller {\n    function callTest(Test test) public returns (bool) {\n        (bool success,) = address(test).call(abi.encodeWithSignature(\"nonExistingFunction()\"));\n        require(success);\n        // results in test.x becoming == 1.\n\n        // address(test) will not allow to call ``send`` directly, since ``test`` has no payable\n        // fallback function.\n        // It has to be converted to the ``address payable`` type to even allow calling ``send`` on it.\n        address payable testPayable = payable(address(test));\n\n        // If someone sends Ether to that contract,\n        // the transfer will fail, i.e. this returns false here.\n        return testPayable.send(2 ether);\n    }\n\n    function callTestPayable(TestPayable test) public returns (bool) {\n        (bool success,) = address(test).call(abi.encodeWithSignature(\"nonExistingFunction()\"));\n        require(success);\n        // results in test.x becoming == 1 and test.y becoming 0.\n        (success,) = address(test).call{value: 1}(abi.encodeWithSignature(\"nonExistingFunction()\"));\n        require(success);\n        // results in test.x becoming == 1 and test.y becoming 1.\n\n        // If someone sends Ether to that contract, the receive function in TestPayable will be called.\n        // Since that function writes to storage, it takes more gas than is available with a\n        // simple ``send`` or ``transfer``. Because of that, we have to use a low-level call.\n        (success,) = address(test).call{value: 2 ether}(\"\");\n        require(success);\n        // results in test.x becoming == 2 and test.y becoming 2 ether.\n\n        return true;\n    }\n}\n\nFunction Overloading\n\nA contract can have multiple functions of the same name but with different parameter types. This process is called “overloading” and also applies to inherited functions. The following example shows overloading of the function f in the scope of contract A.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract A {\n    function f(uint value) public pure returns (uint out) {\n        out = value;\n    }\n\n    function f(uint value, bool really) public pure returns (uint out) {\n        if (really)\n            out = value;\n    }\n}\n\n\nOverloaded functions are also present in the external interface. It is an error if two externally visible functions differ by their Solidity types but not by their external types.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\n// This will not compile\ncontract A {\n    function f(B value) public pure returns (B out) {\n        out = value;\n    }\n\n    function f(address value) public pure returns (address out) {\n        out = value;\n    }\n}\n\ncontract B {\n}\n\n\nBoth f function overloads above end up accepting the address type for the ABI although they are considered different inside Solidity.\n\nOverload resolution and Argument matching\n\nOverloaded functions are selected by matching the function declarations in the current scope to the arguments supplied in the function call. Functions are selected as overload candidates if all arguments can be implicitly converted to the expected types. If there is not exactly one candidate, resolution fails.\n\nNote\n\nReturn parameters are not taken into account for overload resolution.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract A {\n    function f(uint8 val) public pure returns (uint8 out) {\n        out = val;\n    }\n\n    function f(uint256 val) public pure returns (uint256 out) {\n        out = val;\n    }\n}\n\n\nCalling f(50) would create a type error since 50 can be implicitly converted both to uint8 and uint256 types. On another hand f(256) would resolve to f(uint256) overload as 256 cannot be implicitly converted to uint8.\n\nEvents\n\nSolidity events give an abstraction on top of the EVM’s logging functionality. Applications can subscribe and listen to these events through the RPC interface of an Ethereum client.\n\nEvents can be defined at file level or as inheritable members of contracts (including interfaces and libraries). When you call them, they cause the arguments to be stored in the transaction’s log - a special data structure in the blockchain. These logs are associated with the address of the contract that emitted them, are incorporated into the blockchain, and stay there as long as a block is accessible (forever as of now, but this might change in the future). The Log and its event data is not accessible from within contracts (not even from the contract that created them).\n\nIt is possible to request a Merkle proof for logs, so if an external entity supplies a contract with such a proof, it can check that the log actually exists inside the blockchain. You have to supply block headers because the contract can only see the last 256 block hashes.\n\nYou can add the attribute indexed to up to three parameters which adds them to a special data structure known as “topics” instead of the data part of the log. A topic can only hold a single word (32 bytes) so if you use a reference type for an indexed argument, the Keccak-256 hash of the value is stored as a topic instead.\n\nAll parameters without the indexed attribute are ABI-encoded into the data part of the log.\n\nTopics allow you to search for events, for example when filtering a sequence of blocks for certain events. You can also filter events by the address of the contract that emitted the event.\n\nFor example, the code below uses the web3.js subscribe(\"logs\") method to filter logs that match a topic with a certain address value:\n\nvar options = {\n    fromBlock: 0,\n    address: web3.eth.defaultAccount,\n    topics: [\"0x0000000000000000000000000000000000000000000000000000000000000000\", null, null]\n};\nweb3.eth.subscribe('logs', options, function (error, result) {\n    if (!error)\n        console.log(result);\n})\n    .on(\"data\", function (log) {\n        console.log(log);\n    })\n    .on(\"changed\", function (log) {\n});\n\n\nThe hash of the signature of the event is one of the topics, except if you declared the event with the anonymous specifier. This means that it is not possible to filter for specific anonymous events by name, you can only filter by the contract address. The advantage of anonymous events is that they are cheaper to deploy and call. It also allows you to declare four indexed arguments rather than three.\n\nNote\n\nSince the transaction log only stores the event data and not the type, you have to know the type of the event, including which parameter is indexed and if the event is anonymous in order to correctly interpret the data. In particular, it is possible to “fake” the signature of another event using an anonymous event.\n\nMembers of Events\n\nevent.selector: For non-anonymous events, this is a bytes32 value containing the keccak256 hash of the event signature, as used in the default topic.\n\nExample\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.21 <0.9.0;\n\ncontract ClientReceipt {\n    event Deposit(\n        address indexed from,\n        bytes32 indexed id,\n        uint value\n    );\n\n    function deposit(bytes32 id) public payable {\n        // Events are emitted using `emit`, followed by\n        // the name of the event and the arguments\n        // (if any) in parentheses. Any such invocation\n        // (even deeply nested) can be detected from\n        // the JavaScript API by filtering for `Deposit`.\n        emit Deposit(msg.sender, id, msg.value);\n    }\n}\n\n\nThe use in the JavaScript API is as follows:\n\nvar abi = /* abi as generated by the compiler */;\nvar ClientReceipt = web3.eth.contract(abi);\nvar clientReceipt = ClientReceipt.at(\"0x1234...ab67\" /* address */);\n\nvar depositEvent = clientReceipt.Deposit();\n\n// watch for changes\ndepositEvent.watch(function(error, result){\n    // result contains non-indexed arguments and topics\n    // given to the `Deposit` call.\n    if (!error)\n        console.log(result);\n});\n\n\n// Or pass a callback to start watching immediately\nvar depositEvent = clientReceipt.Deposit(function(error, result) {\n    if (!error)\n        console.log(result);\n});\n\n\nThe output of the above looks like the following (trimmed):\n\n{\n   \"returnValues\": {\n       \"from\": \"0x1111…FFFFCCCC\",\n       \"id\": \"0x50…sd5adb20\",\n       \"value\": \"0x420042\"\n   },\n   \"raw\": {\n       \"data\": \"0x7f…91385\",\n       \"topics\": [\"0xfd4…b4ead7\", \"0x7f…1a91385\"]\n   }\n}\n\nAdditional Resources for Understanding Events\n\nJavaScript documentation\n\nExample usage of events\n\nHow to access them in js\n\nErrors and the Revert Statement\n\nErrors in Solidity provide a convenient and gas-efficient way to explain to the user why an operation failed. They can be defined inside and outside of contracts (including interfaces and libraries).\n\nThey have to be used together with the revert statement which causes all changes in the current call to be reverted and passes the error data back to the caller.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// Insufficient balance for transfer. Needed `required` but only\n/// `available` available.\n/// @param available balance available.\n/// @param required requested amount to transfer.\nerror InsufficientBalance(uint256 available, uint256 required);\n\ncontract TestToken {\n    mapping(address => uint) balance;\n    function transfer(address to, uint256 amount) public {\n        if (amount > balance[msg.sender])\n            revert InsufficientBalance({\n                available: balance[msg.sender],\n                required: amount\n            });\n        balance[msg.sender] -= amount;\n        balance[to] += amount;\n    }\n    // ...\n}\n\n\nErrors cannot be overloaded or overridden but are inherited. The same error can be defined in multiple places as long as the scopes are distinct. Instances of errors can only be created using revert statements.\n\nThe error creates data that is then passed to the caller with the revert operation to either return to the off-chain component or catch it in a try/catch statement. Note that an error can only be caught when coming from an external call, reverts happening in internal calls or inside the same function cannot be caught.\n\nIf you do not provide any parameters, the error only needs four bytes of data and you can use NatSpec as above to further explain the reasons behind the error, which is not stored on chain. This makes this a very cheap and convenient error-reporting feature at the same time.\n\nMore specifically, an error instance is ABI-encoded in the same way as a function call to a function of the same name and types would be and then used as the return data in the revert opcode. This means that the data consists of a 4-byte selector followed by ABI-encoded data. The selector consists of the first four bytes of the keccak256-hash of the signature of the error type.\n\nNote\n\nIt is possible for a contract to revert with different errors of the same name or even with errors defined in different places that are indistinguishable by the caller. For the outside, i.e. the ABI, only the name of the error is relevant, not the contract or file where it is defined.\n\nThe statement require(condition, \"description\"); would be equivalent to if (!condition) revert Error(\"description\") if you could define error Error(string). Note, however, that Error is a built-in type and cannot be defined in user-supplied code.\n\nSimilarly, a failing assert or similar conditions will revert with an error of the built-in type Panic(uint256).\n\nNote\n\nError data should only be used to give an indication of failure, but not as a means for control-flow. The reason is that the revert data of inner calls is propagated back through the chain of external calls by default. This means that an inner call can “forge” revert data that looks like it could have come from the contract that called it.\n\nMembers of Errors\n\nerror.selector: A bytes4 value containing the error selector.\n\nInheritance\n\nSolidity supports multiple inheritance including polymorphism.\n\nPolymorphism means that a function call (internal and external) always executes the function of the same name (and parameter types) in the most derived contract in the inheritance hierarchy. This has to be explicitly enabled on each function in the hierarchy using the virtual and override keywords. See Function Overriding for more details.\n\nIt is possible to call functions further up in the inheritance hierarchy internally by explicitly specifying the contract using ContractName.functionName() or using super.functionName() if you want to call the function one level higher up in the flattened inheritance hierarchy (see below).\n\nWhen a contract inherits from other contracts, only a single contract is created on the blockchain, and the code from all the base contracts is compiled into the created contract. This means that all internal calls to functions of base contracts also just use internal function calls (super.f(..) will use JUMP and not a message call).\n\nState variable shadowing is considered as an error. A derived contract can only declare a state variable x, if there is no visible state variable with the same name in any of its bases.\n\nThe general inheritance system is very similar to Python’s, especially concerning multiple inheritance, but there are also some differences.\n\nDetails are given in the following example.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n// This will report a warning due to deprecated selfdestruct\n\ncontract Owned {\n    constructor() { owner = payable(msg.sender); }\n    address payable owner;\n}\n\n\n// Use `is` to derive from another contract. Derived\n// contracts can access all non-private members including\n// internal functions and state variables. These cannot be\n// accessed externally via `this`, though.\ncontract Destructible is Owned {\n    // The keyword `virtual` means that the function can change\n    // its behavior in derived classes (\"overriding\").\n    function destroy() virtual public {\n        if (msg.sender == owner) selfdestruct(owner);\n    }\n}\n\n\n// These abstract contracts are only provided to make the\n// interface known to the compiler. Note the function\n// without body. If a contract does not implement all\n// functions it can only be used as an interface.\nabstract contract Config {\n    function lookup(uint id) public virtual returns (address adr);\n}\n\n\nabstract contract NameReg {\n    function register(bytes32 name) public virtual;\n    function unregister() public virtual;\n}\n\n\n// Multiple inheritance is possible. Note that `Owned` is\n// also a base class of `Destructible`, yet there is only a single\n// instance of `Owned` (as for virtual inheritance in C++).\ncontract Named is Owned, Destructible {\n    constructor(bytes32 name) {\n        Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);\n        NameReg(config.lookup(1)).register(name);\n    }\n\n    // Functions can be overridden by another function with the same name and\n    // the same number/types of inputs.  If the overriding function has different\n    // types of output parameters, that causes an error.\n    // Both local and message-based function calls take these overrides\n    // into account.\n    // If you want the function to override, you need to use the\n    // `override` keyword. You need to specify the `virtual` keyword again\n    // if you want this function to be overridden again.\n    function destroy() public virtual override {\n        if (msg.sender == owner) {\n            Config config = Config(0xD5f9D8D94886E70b06E474c3fB14Fd43E2f23970);\n            NameReg(config.lookup(1)).unregister();\n            // It is still possible to call a specific\n            // overridden function.\n            Destructible.destroy();\n        }\n    }\n}\n\n\n// If a constructor takes an argument, it needs to be\n// provided in the header or modifier-invocation-style at\n// the constructor of the derived contract (see below).\ncontract PriceFeed is Owned, Destructible, Named(\"GoldFeed\") {\n    function updateInfo(uint newInfo) public {\n        if (msg.sender == owner) info = newInfo;\n    }\n\n    // Here, we only specify `override` and not `virtual`.\n    // This means that contracts deriving from `PriceFeed`\n    // cannot change the behavior of `destroy` anymore.\n    function destroy() public override(Destructible, Named) { Named.destroy(); }\n    function get() public view returns(uint r) { return info; }\n\n    uint info;\n}\n\n\nNote that above, we call Destructible.destroy() to “forward” the destruction request. The way this is done is problematic, as seen in the following example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n// This will report a warning due to deprecated selfdestruct\n\ncontract owned {\n    constructor() { owner = payable(msg.sender); }\n    address payable owner;\n}\n\ncontract Destructible is owned {\n    function destroy() public virtual {\n        if (msg.sender == owner) selfdestruct(owner);\n    }\n}\n\ncontract Base1 is Destructible {\n    function destroy() public virtual override { /* do cleanup 1 */ Destructible.destroy(); }\n}\n\ncontract Base2 is Destructible {\n    function destroy() public virtual override { /* do cleanup 2 */ Destructible.destroy(); }\n}\n\ncontract Final is Base1, Base2 {\n    function destroy() public override(Base1, Base2) { Base2.destroy(); }\n}\n\n\nA call to Final.destroy() will call Base2.destroy because we specify it explicitly in the final override, but this function will bypass Base1.destroy. The way around this is to use super:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n// This will report a warning due to deprecated selfdestruct\n\ncontract owned {\n    constructor() { owner = payable(msg.sender); }\n    address payable owner;\n}\n\ncontract Destructible is owned {\n    function destroy() virtual public {\n        if (msg.sender == owner) selfdestruct(owner);\n    }\n}\n\ncontract Base1 is Destructible {\n    function destroy() public virtual override { /* do cleanup 1 */ super.destroy(); }\n}\n\n\ncontract Base2 is Destructible {\n    function destroy() public virtual override { /* do cleanup 2 */ super.destroy(); }\n}\n\ncontract Final is Base1, Base2 {\n    function destroy() public override(Base1, Base2) { super.destroy(); }\n}\n\n\nIf Base2 calls a function of super, it does not simply call this function on one of its base contracts. Rather, it calls this function on the next base contract in the final inheritance graph, so it will call Base1.destroy() (note that the final inheritance sequence is – starting with the most derived contract: Final, Base2, Base1, Destructible, owned). The actual function that is called when using super is not known in the context of the class where it is used, although its type is known. This is similar for ordinary virtual method lookup.\n\nFunction Overriding\n\nBase functions can be overridden by inheriting contracts to change their behavior if they are marked as virtual. The overriding function must then use the override keyword in the function header. The overriding function may only change the visibility of the overridden function from external to public. The mutability may be changed to a more strict one following the order: nonpayable can be overridden by view and pure. view can be overridden by pure. payable is an exception and cannot be changed to any other mutability.\n\nThe following example demonstrates changing mutability and visibility:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Base\n{\n    function foo() virtual external view {}\n}\n\ncontract Middle is Base {}\n\ncontract Inherited is Middle\n{\n    function foo() override public pure {}\n}\n\n\nFor multiple inheritance, the most derived base contracts that define the same function must be specified explicitly after the override keyword. In other words, you have to specify all base contracts that define the same function and have not yet been overridden by another base contract (on some path through the inheritance graph). Additionally, if a contract inherits the same function from multiple (unrelated) bases, it has to explicitly override it:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Base1\n{\n    function foo() virtual public {}\n}\n\ncontract Base2\n{\n    function foo() virtual public {}\n}\n\ncontract Inherited is Base1, Base2\n{\n    // Derives from multiple bases defining foo(), so we must explicitly\n    // override it\n    function foo() public override(Base1, Base2) {}\n}\n\n\nAn explicit override specifier is not required if the function is defined in a common base contract or if there is a unique function in a common base contract that already overrides all other functions.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract A { function f() public pure{} }\ncontract B is A {}\ncontract C is A {}\n// No explicit override required\ncontract D is B, C {}\n\n\nMore formally, it is not required to override a function (directly or indirectly) inherited from multiple bases if there is a base contract that is part of all override paths for the signature, and (1) that base implements the function and no paths from the current contract to the base mentions a function with that signature or (2) that base does not implement the function and there is at most one mention of the function in all paths from the current contract to that base.\n\nIn this sense, an override path for a signature is a path through the inheritance graph that starts at the contract under consideration and ends at a contract mentioning a function with that signature that does not override.\n\nIf you do not mark a function that overrides as virtual, derived contracts can no longer change the behavior of that function.\n\nNote\n\nFunctions with the private visibility cannot be virtual.\n\nNote\n\nFunctions without implementation have to be marked virtual outside of interfaces. In interfaces, all functions are automatically considered virtual.\n\nNote\n\nStarting from Solidity 0.8.8, the override keyword is not required when overriding an interface function, except for the case where the function is defined in multiple bases.\n\nPublic state variables can override external functions if the parameter and return types of the function matches the getter function of the variable:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract A\n{\n    function f() external view virtual returns(uint) { return 5; }\n}\n\ncontract B is A\n{\n    uint public override f;\n}\n\n\nNote\n\nWhile public state variables can override external functions, they themselves cannot be overridden.\n\nModifier Overriding\n\nFunction modifiers can override each other. This works in the same way as function overriding (except that there is no overloading for modifiers). The virtual keyword must be used on the overridden modifier and the override keyword must be used in the overriding modifier:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Base\n{\n    modifier foo() virtual {_;}\n}\n\ncontract Inherited is Base\n{\n    modifier foo() override {_;}\n}\n\n\nIn case of multiple inheritance, all direct base contracts must be specified explicitly:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract Base1\n{\n    modifier foo() virtual {_;}\n}\n\ncontract Base2\n{\n    modifier foo() virtual {_;}\n}\n\ncontract Inherited is Base1, Base2\n{\n    modifier foo() override(Base1, Base2) {_;}\n}\n\nConstructors\n\nA constructor is an optional function declared with the constructor keyword which is executed upon contract creation, and where you can run contract initialisation code.\n\nBefore the constructor code is executed, state variables are initialised to their specified value if you initialise them inline, or their default value if you do not.\n\nAfter the constructor has run, the final code of the contract is deployed to the blockchain. The deployment of the code costs additional gas linear to the length of the code. This code includes all functions that are part of the public interface and all functions that are reachable from there through function calls. It does not include the constructor code or internal functions that are only called from the constructor.\n\nIf there is no constructor, the contract will assume the default constructor, which is equivalent to constructor() {}. For example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\nabstract contract A {\n    uint public a;\n\n    constructor(uint a_) {\n        a = a_;\n    }\n}\n\ncontract B is A(1) {\n    constructor() {}\n}\n\n\nYou can use internal parameters in a constructor (for example storage pointers). In this case, the contract has to be marked abstract, because these parameters cannot be assigned valid values from outside but only through the constructors of derived contracts.\n\nWarning\n\nPrior to version 0.4.22, constructors were defined as functions with the same name as the contract. This syntax was deprecated and is not allowed anymore in version 0.5.0.\n\nWarning\n\nPrior to version 0.7.0, you had to specify the visibility of constructors as either internal or public.\n\nArguments for Base Constructors\n\nThe constructors of all the base contracts will be called following the linearization rules explained below. If the base constructors have arguments, derived contracts need to specify all of them. This can be done in two ways:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Base {\n    uint x;\n    constructor(uint x_) { x = x_; }\n}\n\n// Either directly specify in the inheritance list...\ncontract Derived1 is Base(7) {\n    constructor() {}\n}\n\n// or through a \"modifier\" of the derived constructor...\ncontract Derived2 is Base {\n    constructor(uint y) Base(y * y) {}\n}\n\n// or declare abstract...\nabstract contract Derived3 is Base {\n}\n\n// and have the next concrete derived contract initialize it.\ncontract DerivedFromDerived is Derived3 {\n    constructor() Base(10 + 10) {}\n}\n\n\nOne way is directly in the inheritance list (is Base(7)). The other is in the way a modifier is invoked as part of the derived constructor (Base(y * y)). The first way to do it is more convenient if the constructor argument is a constant and defines the behavior of the contract or describes it. The second way has to be used if the constructor arguments of the base depend on those of the derived contract. Arguments have to be given either in the inheritance list or in modifier-style in the derived constructor. Specifying arguments in both places is an error.\n\nIf a derived contract does not specify the arguments to all of its base contracts’ constructors, it must be declared abstract. In that case, when another contract derives from it, that other contract’s inheritance list or constructor must provide the necessary parameters for all base classes that haven’t had their parameters specified (otherwise, that other contract must be declared abstract as well). For example, in the above code snippet, see Derived3 and DerivedFromDerived.\n\nMultiple Inheritance and Linearization\n\nLanguages that allow multiple inheritance have to deal with several problems. One is the Diamond Problem. Solidity is similar to Python in that it uses “C3 Linearization” to force a specific order in the directed acyclic graph (DAG) of base classes. This results in the desirable property of monotonicity but disallows some inheritance graphs. Especially, the order in which the base classes are given in the is directive is important: You have to list the direct base contracts in the order from “most base-like” to “most derived”. Note that this order is the reverse of the one used in Python.\n\nAnother simplifying way to explain this is that when a function is called that is defined multiple times in different contracts, the given bases are searched from right to left (left to right in Python) in a depth-first manner, stopping at the first match. If a base contract has already been searched, it is skipped.\n\nIn the following code, Solidity will give the error “Linearization of inheritance graph impossible”.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract X {}\ncontract A is X {}\n// This will not compile\ncontract C is A, X {}\n\n\nThe reason for this is that C requests X to override A (by specifying A, X in this order), but A itself requests to override X, which is a contradiction that cannot be resolved.\n\nDue to the fact that you have to explicitly override a function that is inherited from multiple bases without a unique override, C3 linearization is not too important in practice.\n\nOne area where inheritance linearization is especially important and perhaps not as clear is when there are multiple constructors in the inheritance hierarchy. The constructors will always be executed in the linearized order, regardless of the order in which their arguments are provided in the inheriting contract’s constructor. For example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n\ncontract Base1 {\n    constructor() {}\n}\n\ncontract Base2 {\n    constructor() {}\n}\n\n// Constructors are executed in the following order:\n//  1 - Base1\n//  2 - Base2\n//  3 - Derived1\ncontract Derived1 is Base1, Base2 {\n    constructor() Base1() Base2() {}\n}\n\n// Constructors are executed in the following order:\n//  1 - Base2\n//  2 - Base1\n//  3 - Derived2\ncontract Derived2 is Base2, Base1 {\n    constructor() Base2() Base1() {}\n}\n\n// Constructors are still executed in the following order:\n//  1 - Base2\n//  2 - Base1\n//  3 - Derived3\ncontract Derived3 is Base2, Base1 {\n    constructor() Base1() Base2() {}\n}\n\nInheriting Different Kinds of Members of the Same Name\n\nThe only situations where, due to inheritance, a contract may contain multiple definitions sharing the same name are:\n\nOverloading of functions.\n\nOverriding of virtual functions.\n\nOverriding of external virtual functions by state variable getters.\n\nOverriding of virtual modifiers.\n\nOverloading of events.\n\nAbstract Contracts\n\nContracts must be marked as abstract when at least one of their functions is not implemented or when they do not provide arguments for all of their base contract constructors. Even if this is not the case, a contract may still be marked abstract, such as when you do not intend for the contract to be created directly. Abstract contracts are similar to Interfaces but an interface is more limited in what it can declare.\n\nAn abstract contract is declared using the abstract keyword as shown in the following example. Note that this contract needs to be defined as abstract, because the function utterance() is declared, but no implementation was provided (no implementation body { } was given).\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\nabstract contract Feline {\n    function utterance() public virtual returns (bytes32);\n}\n\n\nSuch abstract contracts can not be instantiated directly. This is also true, if an abstract contract itself does implement all defined functions. The usage of an abstract contract as a base class is shown in the following example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\nabstract contract Feline {\n    function utterance() public pure virtual returns (bytes32);\n}\n\ncontract Cat is Feline {\n    function utterance() public pure override returns (bytes32) { return \"miaow\"; }\n}\n\n\nIf a contract inherits from an abstract contract and does not implement all non-implemented functions by overriding, it needs to be marked as abstract as well.\n\nNote that a function without implementation is different from a Function Type even though their syntax looks very similar.\n\nExample of function without implementation (a function declaration):\n\nopen in Remix\n\nfunction foo(address) external returns (address);\n\n\nExample of a declaration of a variable whose type is a function type:\n\nopen in Remix\n\nfunction(address) external returns (address) foo;\n\n\nAbstract contracts decouple the definition of a contract from its implementation providing better extensibility and self-documentation and facilitating patterns like the Template method and removing code duplication. Abstract contracts are useful in the same way that defining methods in an interface is useful. It is a way for the designer of the abstract contract to say “any child of mine must implement this method”.\n\nNote\n\nAbstract contracts cannot override an implemented virtual function with an unimplemented one.\n\nInterfaces\n\nInterfaces are similar to abstract contracts, but they cannot have any functions implemented. There are further restrictions:\n\nThey cannot inherit from other contracts, but they can inherit from other interfaces.\n\nAll declared functions must be external in the interface, even if they are public in the contract.\n\nThey cannot declare a constructor.\n\nThey cannot declare state variables.\n\nThey cannot declare modifiers.\n\nSome of these restrictions might be lifted in the future.\n\nInterfaces are basically limited to what the Contract ABI can represent, and the conversion between the ABI and an interface should be possible without any information loss.\n\nInterfaces are denoted by their own keyword:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.2 <0.9.0;\n\ninterface Token {\n    enum TokenType { Fungible, NonFungible }\n    struct Coin { string obverse; string reverse; }\n    function transfer(address recipient, uint amount) external;\n}\n\n\nContracts can inherit interfaces as they would inherit other contracts.\n\nAll functions declared in interfaces are implicitly virtual and any functions that override them do not need the override keyword. This does not automatically mean that an overriding function can be overridden again - this is only possible if the overriding function is marked virtual.\n\nInterfaces can inherit from other interfaces. This has the same rules as normal inheritance.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.2 <0.9.0;\n\ninterface ParentA {\n    function test() external returns (uint256);\n}\n\ninterface ParentB {\n    function test() external returns (uint256);\n}\n\ninterface SubInterface is ParentA, ParentB {\n    // Must redefine test in order to assert that the parent\n    // meanings are compatible.\n    function test() external override(ParentA, ParentB) returns (uint256);\n}\n\n\nTypes defined inside interfaces and other contract-like structures can be accessed from other contracts: Token.TokenType or Token.Coin.\n\nWarning\n\nInterfaces have supported enum types since Solidity version 0.5.0, make sure the pragma version specifies this version as a minimum.\n\nLibraries\n\nLibraries are similar to contracts, but their purpose is that they are deployed only once at a specific address and their code is reused using the DELEGATECALL (CALLCODE until Homestead) feature of the EVM. This means that if library functions are called, their code is executed in the context of the calling contract, i.e. this points to the calling contract, and especially the storage from the calling contract can be accessed. As a library is an isolated piece of source code, it can only access state variables of the calling contract if they are explicitly supplied (it would have no way to name them, otherwise). Library functions can only be called directly (i.e. without the use of DELEGATECALL) if they do not modify the state (i.e. if they are view or pure functions), because libraries are assumed to be stateless. In particular, it is not possible to destroy a library.\n\nNote\n\nUntil version 0.4.20, it was possible to destroy libraries by circumventing Solidity’s type system. Starting from that version, libraries contain a mechanism that disallows state-modifying functions to be called directly (i.e. without DELEGATECALL).\n\nLibraries can be seen as implicit base contracts of the contracts that use them. They will not be explicitly visible in the inheritance hierarchy, but calls to library functions look just like calls to functions of explicit base contracts (using qualified access like L.f()). Of course, calls to internal functions use the internal calling convention, which means that all internal types can be passed and types stored in memory will be passed by reference and not copied. To realize this in the EVM, the code of internal library functions that are called from a contract and all functions called from therein will at compile time be included in the calling contract, and a regular JUMP call will be used instead of a DELEGATECALL.\n\nNote\n\nThe inheritance analogy breaks down when it comes to public functions. Calling a public library function with L.f() results in an external call (DELEGATECALL to be precise). In contrast, A.f() is an internal call when A is a base contract of the current contract.\n\nThe following example illustrates how to use libraries (but using a manual method, be sure to check out using for for a more advanced example to implement a set).\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\n\n// We define a new struct datatype that will be used to\n// hold its data in the calling contract.\nstruct Data {\n    mapping(uint => bool) flags;\n}\n\nlibrary Set {\n    // Note that the first parameter is of type \"storage\n    // reference\" and thus only its storage address and not\n    // its contents is passed as part of the call.  This is a\n    // special feature of library functions.  It is idiomatic\n    // to call the first parameter `self`, if the function can\n    // be seen as a method of that object.\n    function insert(Data storage self, uint value)\n        public\n        returns (bool)\n    {\n        if (self.flags[value])\n            return false; // already there\n        self.flags[value] = true;\n        return true;\n    }\n\n    function remove(Data storage self, uint value)\n        public\n        returns (bool)\n    {\n        if (!self.flags[value])\n            return false; // not there\n        self.flags[value] = false;\n        return true;\n    }\n\n    function contains(Data storage self, uint value)\n        public\n        view\n        returns (bool)\n    {\n        return self.flags[value];\n    }\n}\n\n\ncontract C {\n    Data knownValues;\n\n    function register(uint value) public {\n        // The library functions can be called without a\n        // specific instance of the library, since the\n        // \"instance\" will be the current contract.\n        require(Set.insert(knownValues, value));\n    }\n    // In this contract, we can also directly access knownValues.flags, if we want.\n}\n\n\nOf course, you do not have to follow this way to use libraries: they can also be used without defining struct data types. Functions also work without any storage reference parameters, and they can have multiple storage reference parameters and in any position.\n\nThe calls to Set.contains, Set.insert and Set.remove are all compiled as calls (DELEGATECALL) to an external contract/library. If you use libraries, be aware that an actual external function call is performed. msg.sender, msg.value and this will retain their values in this call, though (prior to Homestead, because of the use of CALLCODE, msg.sender and msg.value changed, though).\n\nThe following example shows how to use types stored in memory and internal functions in libraries in order to implement custom types without the overhead of external function calls:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\n\nstruct bigint {\n    uint[] limbs;\n}\n\nlibrary BigInt {\n    function fromUint(uint x) internal pure returns (bigint memory r) {\n        r.limbs = new uint[](1);\n        r.limbs[0] = x;\n    }\n\n    function add(bigint memory a, bigint memory b) internal pure returns (bigint memory r) {\n        r.limbs = new uint[](max(a.limbs.length, b.limbs.length));\n        uint carry = 0;\n        for (uint i = 0; i < r.limbs.length; ++i) {\n            uint limbA = limb(a, i);\n            uint limbB = limb(b, i);\n            unchecked {\n                r.limbs[i] = limbA + limbB + carry;\n\n                if (limbA + limbB < limbA || (limbA + limbB == type(uint).max && carry > 0))\n                    carry = 1;\n                else\n                    carry = 0;\n            }\n        }\n        if (carry > 0) {\n            // too bad, we have to add a limb\n            uint[] memory newLimbs = new uint[](r.limbs.length + 1);\n            uint i;\n            for (i = 0; i < r.limbs.length; ++i)\n                newLimbs[i] = r.limbs[i];\n            newLimbs[i] = carry;\n            r.limbs = newLimbs;\n        }\n    }\n\n    function limb(bigint memory a, uint index) internal pure returns (uint) {\n        return index < a.limbs.length ? a.limbs[index] : 0;\n    }\n\n    function max(uint a, uint b) private pure returns (uint) {\n        return a > b ? a : b;\n    }\n}\n\ncontract C {\n    using BigInt for bigint;\n\n    function f() public pure {\n        bigint memory x = BigInt.fromUint(7);\n        bigint memory y = BigInt.fromUint(type(uint).max);\n        bigint memory z = x.add(y);\n        assert(z.limb(1) > 0);\n    }\n}\n\n\nIt is possible to obtain the address of a library by converting the library type to the address type, i.e. using address(LibraryName).\n\nAs the compiler does not know the address where the library will be deployed, the compiled hex code will contain placeholders of the form __$30bbc0abd4d6364515865950d3e0d10953$__. The placeholder is a 34 character prefix of the hex encoding of the keccak256 hash of the fully qualified library name, which would be for example libraries/bigint.sol:BigInt if the library was stored in a file called bigint.sol in a libraries/ directory. Such bytecode is incomplete and should not be deployed. Placeholders need to be replaced with actual addresses. You can do that by either passing them to the compiler when the library is being compiled or by using the linker to update an already compiled binary. See Library Linking for information on how to use the commandline compiler for linking.\n\nIn comparison to contracts, libraries are restricted in the following ways:\n\nthey cannot have state variables\n\nthey cannot inherit nor be inherited\n\nthey cannot receive Ether\n\nthey cannot be destroyed\n\n(These might be lifted at a later point.)\n\nFunction Signatures and Selectors in Libraries\n\nWhile external calls to public or external library functions are possible, the calling convention for such calls is considered to be internal to Solidity and not the same as specified for the regular contract ABI. External library functions support more argument types than external contract functions, for example recursive structs and storage pointers. For that reason, the function signatures used to compute the 4-byte selector are computed following an internal naming schema and arguments of types not supported in the contract ABI use an internal encoding.\n\nThe following identifiers are used for the types in the signatures:\n\nValue types, non-storage string and non-storage bytes use the same identifiers as in the contract ABI.\n\nNon-storage array types follow the same convention as in the contract ABI, i.e. <type>[] for dynamic arrays and <type>[M] for fixed-size arrays of M elements.\n\nNon-storage structs are referred to by their fully qualified name, i.e. C.S for contract C { struct S { ... } }.\n\nStorage pointer mappings use mapping(<keyType> => <valueType>) storage where <keyType> and <valueType> are the identifiers for the key and value types of the mapping, respectively.\n\nOther storage pointer types use the type identifier of their corresponding non-storage type, but append a single space followed by storage to it.\n\nThe argument encoding is the same as for the regular contract ABI, except for storage pointers, which are encoded as a uint256 value referring to the storage slot to which they point.\n\nSimilarly to the contract ABI, the selector consists of the first four bytes of the Keccak256-hash of the signature. Its value can be obtained from Solidity using the .selector member as follows:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.14 <0.9.0;\n\nlibrary L {\n    function f(uint256) external {}\n}\n\ncontract C {\n    function g() public pure returns (bytes4) {\n        return L.f.selector;\n    }\n}\n\nCall Protection For Libraries\n\nAs mentioned in the introduction, if a library’s code is executed using a CALL instead of a DELEGATECALL or CALLCODE, it will revert unless a view or pure function is called.\n\nThe EVM does not provide a direct way for a contract to detect whether it was called using CALL or not, but a contract can use the ADDRESS opcode to find out “where” it is currently running. The generated code compares this address to the address used at construction time to determine the mode of calling.\n\nMore specifically, the runtime code of a library always starts with a push instruction, which is a zero of 20 bytes at compilation time. When the deploy code runs, this constant is replaced in memory by the current address and this modified code is stored in the contract. At runtime, this causes the deploy time address to be the first constant to be pushed onto the stack and the dispatcher code compares the current address against this constant for any non-view and non-pure function.\n\nThis means that the actual code stored on chain for a library is different from the code reported by the compiler as deployedBytecode.\n\nUsing For\n\nThe directive using A for B can be used to attach functions (A) as operators to user-defined value types or as member functions to any type (B). The member functions receive the object they are called on as their first parameter (like the self variable in Python). The operator functions receive operands as parameters.\n\nIt is valid either at file level or inside a contract, at contract level.\n\nThe first part, A, can be one of:\n\nA list of functions, optionally with an operator name assigned (e.g. using {f, g as +, h, L.t} for uint). If no operator is specified, the function can be either a library function or a free function and is attached to the type as a member function. Otherwise it must be a free function and it becomes the definition of that operator on the type.\n\nThe name of a library (e.g. using L for uint) - all non-private functions of the library are attached to the type as member functions\n\nAt file level, the second part, B, has to be an explicit type (without data location specifier). Inside contracts, you can also use * in place of the type (e.g. using L for *;), which has the effect that all functions of the library L are attached to all types.\n\nIf you specify a library, all non-private functions in the library get attached, even those where the type of the first parameter does not match the type of the object. The type is checked at the point the function is called and function overload resolution is performed.\n\nIf you use a list of functions (e.g. using {f, g, h, L.t} for uint), then the type (uint) has to be implicitly convertible to the first parameter of each of these functions. This check is performed even if none of these functions are called. Note that private library functions can only be specified when using for is inside a library.\n\nIf you define an operator (e.g. using {f as +} for T), then the type (T) must be a user-defined value type and the definition must be a pure function. Operator definitions must be global. The following operators can be defined this way:\n\nCategory\n\n\t\n\nOperator\n\n\t\n\nPossible signatures\n\n\n\n\nBitwise\n\n\t\n\n&\n\n\t\n\nfunction (T, T) pure returns (T)\n\n\n\n\n|\n\n\t\n\nfunction (T, T) pure returns (T)\n\n\n\n\n^\n\n\t\n\nfunction (T, T) pure returns (T)\n\n\n\n\n~\n\n\t\n\nfunction (T) pure returns (T)\n\n\n\n\nArithmetic\n\n\t\n\n+\n\n\t\n\nfunction (T, T) pure returns (T)\n\n\n\n\n-\n\n\t\n\nfunction (T, T) pure returns (T)\n\n\n\n\nfunction (T) pure returns (T)\n\n\n\n\n*\n\n\t\n\nfunction (T, T) pure returns (T)\n\n\n\n\n/\n\n\t\n\nfunction (T, T) pure returns (T)\n\n\n\n\n%\n\n\t\n\nfunction (T, T) pure returns (T)\n\n\n\n\nComparison\n\n\t\n\n==\n\n\t\n\nfunction (T, T) pure returns (bool)\n\n\n\n\n!=\n\n\t\n\nfunction (T, T) pure returns (bool)\n\n\n\n\n<\n\n\t\n\nfunction (T, T) pure returns (bool)\n\n\n\n\n<=\n\n\t\n\nfunction (T, T) pure returns (bool)\n\n\n\n\n>\n\n\t\n\nfunction (T, T) pure returns (bool)\n\n\n\n\n>=\n\n\t\n\nfunction (T, T) pure returns (bool)\n\nNote that unary and binary - need separate definitions. The compiler will choose the right definition based on how the operator is invoked.\n\nThe using A for B; directive is active only within the current scope (either the contract or the current module/source unit), including within all of its functions, and has no effect outside of the contract or module in which it is used.\n\nWhen the directive is used at file level and applied to a user-defined type which was defined at file level in the same file, the word global can be added at the end. This will have the effect that the functions and operators are attached to the type everywhere the type is available (including other files), not only in the scope of the using statement.\n\nLet us rewrite the set example from the Libraries section in this way, using file-level functions instead of library functions.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.13;\n\nstruct Data { mapping(uint => bool) flags; }\n// Now we attach functions to the type.\n// The attached functions can be used throughout the rest of the module.\n// If you import the module, you have to\n// repeat the using directive there, for example as\n//   import \"flags.sol\" as Flags;\n//   using {Flags.insert, Flags.remove, Flags.contains}\n//     for Flags.Data;\nusing {insert, remove, contains} for Data;\n\nfunction insert(Data storage self, uint value)\n    returns (bool)\n{\n    if (self.flags[value])\n        return false; // already there\n    self.flags[value] = true;\n    return true;\n}\n\nfunction remove(Data storage self, uint value)\n    returns (bool)\n{\n    if (!self.flags[value])\n        return false; // not there\n    self.flags[value] = false;\n    return true;\n}\n\nfunction contains(Data storage self, uint value)\n    view\n    returns (bool)\n{\n    return self.flags[value];\n}\n\n\ncontract C {\n    Data knownValues;\n\n    function register(uint value) public {\n        // Here, all variables of type Data have\n        // corresponding member functions.\n        // The following function call is identical to\n        // `Set.insert(knownValues, value)`\n        require(knownValues.insert(value));\n    }\n}\n\n\nIt is also possible to extend built-in types in that way. In this example, we will use a library.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.13;\n\nlibrary Search {\n    function indexOf(uint[] storage self, uint value)\n        public\n        view\n        returns (uint)\n    {\n        for (uint i = 0; i < self.length; i++)\n            if (self[i] == value) return i;\n        return type(uint).max;\n    }\n}\nusing Search for uint[];\n\ncontract C {\n    uint[] data;\n\n    function append(uint value) public {\n        data.push(value);\n    }\n\n    function replace(uint from, uint to) public {\n        // This performs the library function call\n        uint index = data.indexOf(from);\n        if (index == type(uint).max)\n            data.push(to);\n        else\n            data[index] = to;\n    }\n}\n\n\nNote that all external library calls are actual EVM function calls. This means that if you pass memory or value types, a copy will be performed, even in case of the self variable. The only situation where no copy will be performed is when storage reference variables are used or when internal library functions are called.\n\nAnother example shows how to define a custom operator for a user-defined type:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.19;\n\ntype UFixed16x2 is uint16;\n\nusing {\n    add as +,\n    div as /\n} for UFixed16x2 global;\n\nuint32 constant SCALE = 100;\n\nfunction add(UFixed16x2 a, UFixed16x2 b) pure returns (UFixed16x2) {\n    return UFixed16x2.wrap(UFixed16x2.unwrap(a) + UFixed16x2.unwrap(b));\n}\n\nfunction div(UFixed16x2 a, UFixed16x2 b) pure returns (UFixed16x2) {\n    uint32 a32 = UFixed16x2.unwrap(a);\n    uint32 b32 = UFixed16x2.unwrap(b);\n    uint32 result32 = a32 * SCALE / b32;\n    require(result32 <= type(uint16).max, \"Divide overflow\");\n    return UFixed16x2.wrap(uint16(a32 * SCALE / b32));\n}\n\ncontract Math {\n    function avg(UFixed16x2 a, UFixed16x2 b) public pure returns (UFixed16x2) {\n        return (a + b) / UFixed16x2.wrap(200);\n    }\n}\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Expressions and Control Structures — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/control-structures.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nControl Structures\nFunction Calls\nCreating Contracts via new\nOrder of Evaluation of Expressions\nAssignment\nScoping and Declarations\nChecked or Unchecked Arithmetic\nError handling: Assert, Require, Revert and Exceptions\nContracts\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Expressions and Control Structures\n Edit on GitHub\nExpressions and Control Structures\nControl Structures\n\nMost of the control structures known from curly-braces languages are available in Solidity:\n\nThere is: if, else, while, do, for, break, continue, return, with the usual semantics known from C or JavaScript.\n\nSolidity also supports exception handling in the form of try/catch-statements, but only for external function calls and contract creation calls. Errors can be created using the revert statement.\n\nParentheses can not be omitted for conditionals, but curly braces can be omitted around single-statement bodies.\n\nNote that there is no type conversion from non-boolean to boolean types as there is in C and JavaScript, so if (1) { ... } is not valid Solidity.\n\nFunction Calls\nInternal Function Calls\n\nFunctions of the current contract can be called directly (“internally”), also recursively, as seen in this nonsensical example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\n// This will report a warning\ncontract C {\n    function g(uint a) public pure returns (uint ret) { return a + f(); }\n    function f() internal pure returns (uint ret) { return g(7) + f(); }\n}\n\n\nThese function calls are translated into simple jumps inside the EVM. This has the effect that the current memory is not cleared, i.e. passing memory references to internally-called functions is very efficient. Only functions of the same contract instance can be called internally.\n\nYou should still avoid excessive recursion, as every internal function call uses up at least one stack slot and there are only 1024 slots available.\n\nExternal Function Calls\n\nFunctions can also be called using the this.g(8); and c.g(2); notation, where c is a contract instance and g is a function belonging to c. Calling the function g via either way results in it being called “externally”, using a message call and not directly via jumps. Please note that function calls on this cannot be used in the constructor, as the actual contract has not been created yet.\n\nFunctions of other contracts have to be called externally. For an external call, all function arguments have to be copied to memory.\n\nNote\n\nA function call from one contract to another does not create its own transaction, it is a message call as part of the overall transaction.\n\nWhen calling functions of other contracts, you can specify the amount of Wei or gas sent with the call with the special options {value: 10, gas: 10000}. Note that it is discouraged to specify gas values explicitly, since the gas costs of opcodes can change in the future. Any Wei you send to the contract is added to the total balance of that contract:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.2 <0.9.0;\n\ncontract InfoFeed {\n    function info() public payable returns (uint ret) { return 42; }\n}\n\ncontract Consumer {\n    InfoFeed feed;\n    function setFeed(InfoFeed addr) public { feed = addr; }\n    function callFeed() public { feed.info{value: 10, gas: 800}(); }\n}\n\n\nYou need to use the modifier payable with the info function because otherwise, the value option would not be available.\n\nWarning\n\nBe careful that feed.info{value: 10, gas: 800} only locally sets the value and amount of gas sent with the function call, and the parentheses at the end perform the actual call. So feed.info{value: 10, gas: 800} does not call the function and the value and gas settings are lost, only feed.info{value: 10, gas: 800}() performs the function call.\n\nDue to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity uses the extcodesize opcode to check that the contract that is about to be called actually exists (it contains code) and causes an exception if it does not. This check is skipped if the return data will be decoded after the call and thus the ABI decoder will catch the case of a non-existing contract.\n\nNote that this check is not performed in case of low-level calls which operate on addresses rather than contract instances.\n\nNote\n\nBe careful when using high-level calls to precompiled contracts, since the compiler considers them non-existing according to the above logic even though they execute code and can return data.\n\nFunction calls also cause exceptions if the called contract itself throws an exception or goes out of gas.\n\nWarning\n\nAny interaction with another contract imposes a potential danger, especially if the source code of the contract is not known in advance. The current contract hands over control to the called contract and that may potentially do just about anything. Even if the called contract inherits from a known parent contract, the inheriting contract is only required to have a correct interface. The implementation of the contract, however, can be completely arbitrary and thus, pose a danger. In addition, be prepared in case it calls into other contracts of your system or even back into the calling contract before the first call returns. This means that the called contract can change state variables of the calling contract via its functions. Write your functions in a way that, for example, calls to external functions happen after any changes to state variables in your contract so your contract is not vulnerable to a reentrancy exploit.\n\nNote\n\nBefore Solidity 0.6.2, the recommended way to specify the value and gas was to use f.value(x).gas(g)(). This was deprecated in Solidity 0.6.2 and is no longer possible since Solidity 0.7.0.\n\nFunction Calls with Named Parameters\n\nFunction call arguments can be given by name, in any order, if they are enclosed in { } as can be seen in the following example. The argument list has to coincide by name with the list of parameters from the function declaration, but can be in arbitrary order.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract C {\n    mapping(uint => uint) data;\n\n    function f() public {\n        set({value: 2, key: 3});\n    }\n\n    function set(uint key, uint value) public {\n        data[key] = value;\n    }\n}\n\nOmitted Names in Function Definitions\n\nThe names of parameters and return values in the function declaration can be omitted. Those items with omitted names will still be present on the stack, but they are inaccessible by name. An omitted return value name can still return a value to the caller by use of the return statement.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\ncontract C {\n    // omitted name for parameter\n    function func(uint k, uint) public pure returns(uint) {\n        return k;\n    }\n}\n\nCreating Contracts via new\n\nA contract can create other contracts using the new keyword. The full code of the contract being created has to be known when the creating contract is compiled so recursive creation-dependencies are not possible.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\ncontract D {\n    uint public x;\n    constructor(uint a) payable {\n        x = a;\n    }\n}\n\ncontract C {\n    D d = new D(4); // will be executed as part of C's constructor\n\n    function createD(uint arg) public {\n        D newD = new D(arg);\n        newD.x();\n    }\n\n    function createAndEndowD(uint arg, uint amount) public payable {\n        // Send ether along with the creation\n        D newD = new D{value: amount}(arg);\n        newD.x();\n    }\n}\n\n\nAs seen in the example, it is possible to send Ether while creating an instance of D using the value option, but it is not possible to limit the amount of gas. If the creation fails (due to out-of-stack, not enough balance or other problems), an exception is thrown.\n\nSalted contract creations / create2\n\nWhen creating a contract, the address of the contract is computed from the address of the creating contract and a counter that is increased with each contract creation.\n\nIf you specify the option salt (a bytes32 value), then contract creation will use a different mechanism to come up with the address of the new contract:\n\nIt will compute the address from the address of the creating contract, the given salt value, the (creation) bytecode of the created contract and the constructor arguments.\n\nIn particular, the counter (“nonce”) is not used. This allows for more flexibility in creating contracts: You are able to derive the address of the new contract before it is created. Furthermore, you can rely on this address also in case the creating contracts creates other contracts in the meantime.\n\nThe main use-case here is contracts that act as judges for off-chain interactions, which only need to be created if there is a dispute.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\ncontract D {\n    uint public x;\n    constructor(uint a) {\n        x = a;\n    }\n}\n\ncontract C {\n    function createDSalted(bytes32 salt, uint arg) public {\n        // This complicated expression just tells you how the address\n        // can be pre-computed. It is just there for illustration.\n        // You actually only need ``new D{salt: salt}(arg)``.\n        address predictedAddress = address(uint160(uint(keccak256(abi.encodePacked(\n            bytes1(0xff),\n            address(this),\n            salt,\n            keccak256(abi.encodePacked(\n                type(D).creationCode,\n                abi.encode(arg)\n            ))\n        )))));\n\n        D d = new D{salt: salt}(arg);\n        require(address(d) == predictedAddress);\n    }\n}\n\n\nWarning\n\nThere are some peculiarities in relation to salted creation. A contract can be re-created at the same address after having been destroyed. Yet, it is possible for that newly created contract to have a different deployed bytecode even though the creation bytecode has been the same (which is a requirement because otherwise the address would change). This is due to the fact that the constructor can query external state that might have changed between the two creations and incorporate that into the deployed bytecode before it is stored.\n\nOrder of Evaluation of Expressions\n\nThe evaluation order of expressions is not specified (more formally, the order in which the children of one node in the expression tree are evaluated is not specified, but they are of course evaluated before the node itself). It is only guaranteed that statements are executed in order and short-circuiting for boolean expressions is done.\n\nAssignment\nDestructuring Assignments and Returning Multiple Values\n\nSolidity internally allows tuple types, i.e. a list of objects of potentially different types whose number is a constant at compile-time. Those tuples can be used to return multiple values at the same time. These can then either be assigned to newly declared variables or to pre-existing variables (or LValues in general).\n\nTuples are not proper types in Solidity, they can only be used to form syntactic groupings of expressions.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract C {\n    uint index;\n\n    function f() public pure returns (uint, bool, uint) {\n        return (7, true, 2);\n    }\n\n    function g() public {\n        // Variables declared with type and assigned from the returned tuple,\n        // not all elements have to be specified (but the number must match).\n        (uint x, , uint y) = f();\n        // Common trick to swap values -- does not work for non-value storage types.\n        (x, y) = (y, x);\n        // Components can be left out (also for variable declarations).\n        (index, , ) = f(); // Sets the index to 7\n    }\n}\n\n\nIt is not possible to mix variable declarations and non-declaration assignments, i.e. the following is not valid: (x, uint y) = (1, 2);\n\nNote\n\nPrior to version 0.5.0 it was possible to assign to tuples of smaller size, either filling up on the left or on the right side (which ever was empty). This is now disallowed, so both sides have to have the same number of components.\n\nWarning\n\nBe careful when assigning to multiple variables at the same time when reference types are involved, because it could lead to unexpected copying behavior.\n\nComplications for Arrays and Structs\n\nThe semantics of assignments are more complicated for non-value types like arrays and structs, including bytes and string, see Data location and assignment behavior for details.\n\nIn the example below the call to g(x) has no effect on x because it creates an independent copy of the storage value in memory. However, h(x) successfully modifies x because only a reference and not a copy is passed.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\ncontract C {\n    uint[20] x;\n\n    function f() public {\n        g(x);\n        h(x);\n    }\n\n    function g(uint[20] memory y) internal pure {\n        y[2] = 3;\n    }\n\n    function h(uint[20] storage y) internal {\n        y[3] = 4;\n    }\n}\n\nScoping and Declarations\n\nA variable which is declared will have an initial default value whose byte-representation is all zeros. The “default values” of variables are the typical “zero-state” of whatever the type is. For example, the default value for a bool is false. The default value for the uint or int types is 0. For statically-sized arrays and bytes1 to bytes32, each individual element will be initialized to the default value corresponding to its type. For dynamically-sized arrays, bytes and string, the default value is an empty array or string. For the enum type, the default value is its first member.\n\nScoping in Solidity follows the widespread scoping rules of C99 (and many other languages): Variables are visible from the point right after their declaration until the end of the smallest { }-block that contains the declaration. As an exception to this rule, variables declared in the initialization part of a for-loop are only visible until the end of the for-loop.\n\nVariables that are parameter-like (function parameters, modifier parameters, catch parameters, …) are visible inside the code block that follows - the body of the function/modifier for a function and modifier parameter and the catch block for a catch parameter.\n\nVariables and other items declared outside of a code block, for example functions, contracts, user-defined types, etc., are visible even before they were declared. This means you can use state variables before they are declared and call functions recursively.\n\nAs a consequence, the following examples will compile without warnings, since the two variables have the same name but disjoint scopes.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\ncontract C {\n    function minimalScoping() pure public {\n        {\n            uint same;\n            same = 1;\n        }\n\n        {\n            uint same;\n            same = 3;\n        }\n    }\n}\n\n\nAs a special example of the C99 scoping rules, note that in the following, the first assignment to x will actually assign the outer and not the inner variable. In any case, you will get a warning about the outer variable being shadowed.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n// This will report a warning\ncontract C {\n    function f() pure public returns (uint) {\n        uint x = 1;\n        {\n            x = 2; // this will assign to the outer variable\n            uint x;\n        }\n        return x; // x has value 2\n    }\n}\n\n\nWarning\n\nBefore version 0.5.0 Solidity followed the same scoping rules as JavaScript, that is, a variable declared anywhere within a function would be in scope for the entire function, regardless where it was declared. The following example shows a code snippet that used to compile but leads to an error starting from version 0.5.0.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n// This will not compile\ncontract C {\n    function f() pure public returns (uint) {\n        x = 2;\n        uint x;\n        return x;\n    }\n}\n\nChecked or Unchecked Arithmetic\n\nAn overflow or underflow is the situation where the resulting value of an arithmetic operation, when executed on an unrestricted integer, falls outside the range of the result type.\n\nPrior to Solidity 0.8.0, arithmetic operations would always wrap in case of under- or overflow leading to widespread use of libraries that introduce additional checks.\n\nSince Solidity 0.8.0, all arithmetic operations revert on over- and underflow by default, thus making the use of these libraries unnecessary.\n\nTo obtain the previous behavior, an unchecked block can be used:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.0;\ncontract C {\n    function f(uint a, uint b) pure public returns (uint) {\n        // This subtraction will wrap on underflow.\n        unchecked { return a - b; }\n    }\n    function g(uint a, uint b) pure public returns (uint) {\n        // This subtraction will revert on underflow.\n        return a - b;\n    }\n}\n\n\nThe call to f(2, 3) will return 2**256-1, while g(2, 3) will cause a failing assertion.\n\nThe unchecked block can be used everywhere inside a block, but not as a replacement for a block. It also cannot be nested.\n\nThe setting only affects the statements that are syntactically inside the block. Functions called from within an unchecked block do not inherit the property.\n\nNote\n\nTo avoid ambiguity, you cannot use _; inside an unchecked block.\n\nThe following operators will cause a failing assertion on overflow or underflow and will wrap without an error if used inside an unchecked block:\n\n++, --, +, binary -, unary -, *, /, %, **\n\n+=, -=, *=, /=, %=\n\nWarning\n\nIt is not possible to disable the check for division by zero or modulo by zero using the unchecked block.\n\nNote\n\nBitwise operators do not perform overflow or underflow checks. This is particularly visible when using bitwise shifts (<<, >>, <<=, >>=) in place of integer division and multiplication by a power of 2. For example type(uint256).max << 3 does not revert even though type(uint256).max * 8 would.\n\nNote\n\nThe second statement in int x = type(int).min; -x; will result in an overflow because the negative range can hold one more value than the positive range.\n\nExplicit type conversions will always truncate and never cause a failing assertion with the exception of a conversion from an integer to an enum type.\n\nError handling: Assert, Require, Revert and Exceptions\n\nSolidity uses state-reverting exceptions to handle errors. Such an exception undoes all changes made to the state in the current call (and all its sub-calls) and flags an error to the caller.\n\nWhen exceptions happen in a sub-call, they “bubble up” (i.e., exceptions are rethrown) automatically unless they are caught in a try/catch statement. Exceptions to this rule are send and the low-level functions call, delegatecall and staticcall: they return false as their first return value in case of an exception instead of “bubbling up”.\n\nWarning\n\nThe low-level functions call, delegatecall and staticcall return true as their first return value if the account called is non-existent, as part of the design of the EVM. Account existence must be checked prior to calling if needed.\n\nExceptions can contain error data that is passed back to the caller in the form of error instances. The built-in errors Error(string) and Panic(uint256) are used by special functions, as explained below. Error is used for “regular” error conditions while Panic is used for errors that should not be present in bug-free code.\n\nPanic via assert and Error via require\n\nThe convenience functions assert and require can be used to check for conditions and throw an exception if the condition is not met.\n\nThe assert function creates an error of type Panic(uint256). The same error is created by the compiler in certain situations as listed below.\n\nAssert should only be used to test for internal errors, and to check invariants. Properly functioning code should never create a Panic, not even on invalid external input. If this happens, then there is a bug in your contract which you should fix. Language analysis tools can evaluate your contract to identify the conditions and function calls which will cause a Panic.\n\nA Panic exception is generated in the following situations. The error code supplied with the error data indicates the kind of panic.\n\n0x00: Used for generic compiler inserted panics.\n\n0x01: If you call assert with an argument that evaluates to false.\n\n0x11: If an arithmetic operation results in underflow or overflow outside of an unchecked { ... } block.\n\n0x12; If you divide or modulo by zero (e.g. 5 / 0 or 23 % 0).\n\n0x21: If you convert a value that is too big or negative into an enum type.\n\n0x22: If you access a storage byte array that is incorrectly encoded.\n\n0x31: If you call .pop() on an empty array.\n\n0x32: If you access an array, bytesN or an array slice at an out-of-bounds or negative index (i.e. x[i] where i >= x.length or i < 0).\n\n0x41: If you allocate too much memory or create an array that is too large.\n\n0x51: If you call a zero-initialized variable of internal function type.\n\nThe require function either creates an error without any data or an error of type Error(string). It should be used to ensure valid conditions that cannot be detected until execution time. This includes conditions on inputs or return values from calls to external contracts.\n\nNote\n\nIt is currently not possible to use custom errors in combination with require. Please use if (!condition) revert CustomError(); instead.\n\nAn Error(string) exception (or an exception without data) is generated by the compiler in the following situations:\n\nCalling require(x) where x evaluates to false.\n\nIf you use revert() or revert(\"description\").\n\nIf you perform an external function call targeting a contract that contains no code.\n\nIf your contract receives Ether via a public function without payable modifier (including the constructor and the fallback function).\n\nIf your contract receives Ether via a public getter function.\n\nFor the following cases, the error data from the external call (if provided) is forwarded. This means that it can either cause an Error or a Panic (or whatever else was given):\n\nIf a .transfer() fails.\n\nIf you call a function via a message call but it does not finish properly (i.e., it runs out of gas, has no matching function, or throws an exception itself), except when a low level operation call, send, delegatecall, callcode or staticcall is used. The low level operations never throw exceptions but indicate failures by returning false.\n\nIf you create a contract using the new keyword but the contract creation does not finish properly.\n\nYou can optionally provide a message string for require, but not for assert.\n\nNote\n\nIf you do not provide a string argument to require, it will revert with empty error data, not even including the error selector.\n\nThe following example shows how you can use require to check conditions on inputs and assert for internal error checking.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract Sharer {\n    function sendHalf(address payable addr) public payable returns (uint balance) {\n        require(msg.value % 2 == 0, \"Even value required.\");\n        uint balanceBeforeTransfer = address(this).balance;\n        addr.transfer(msg.value / 2);\n        // Since transfer throws an exception on failure and\n        // cannot call back here, there should be no way for us to\n        // still have half of the Ether.\n        assert(address(this).balance == balanceBeforeTransfer - msg.value / 2);\n        return address(this).balance;\n    }\n}\n\n\nInternally, Solidity performs a revert operation (instruction 0xfd). This causes the EVM to revert all changes made to the state. The reason for reverting is that there is no safe way to continue execution, because an expected effect did not occur. Because we want to keep the atomicity of transactions, the safest action is to revert all changes and make the whole transaction (or at least call) without effect.\n\nIn both cases, the caller can react on such failures using try/catch, but the changes in the callee will always be reverted.\n\nNote\n\nPanic exceptions used to use the invalid opcode before Solidity 0.8.0, which consumed all gas available to the call. Exceptions that use require used to consume all gas until before the Metropolis release.\n\nrevert\n\nA direct revert can be triggered using the revert statement and the revert function.\n\nThe revert statement takes a custom error as direct argument without parentheses:\n\nrevert CustomError(arg1, arg2);\n\nFor backward-compatibility reasons, there is also the revert() function, which uses parentheses and accepts a string:\n\nrevert(); revert(“description”);\n\nThe error data will be passed back to the caller and can be caught there. Using revert() causes a revert without any error data while revert(\"description\") will create an Error(string) error.\n\nUsing a custom error instance will usually be much cheaper than a string description, because you can use the name of the error to describe it, which is encoded in only four bytes. A longer description can be supplied via NatSpec which does not incur any costs.\n\nThe following example shows how to use an error string and a custom error instance together with revert and the equivalent require:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\ncontract VendingMachine {\n    address owner;\n    error Unauthorized();\n    function buy(uint amount) public payable {\n        if (amount > msg.value / 2 ether)\n            revert(\"Not enough Ether provided.\");\n        // Alternative way to do it:\n        require(\n            amount <= msg.value / 2 ether,\n            \"Not enough Ether provided.\"\n        );\n        // Perform the purchase.\n    }\n    function withdraw() public {\n        if (msg.sender != owner)\n            revert Unauthorized();\n\n        payable(msg.sender).transfer(address(this).balance);\n    }\n}\n\n\nThe two ways if (!condition) revert(...); and require(condition, ...); are equivalent as long as the arguments to revert and require do not have side-effects, for example if they are just strings.\n\nNote\n\nThe require function is evaluated just as any other function. This means that all arguments are evaluated before the function itself is executed. In particular, in require(condition, f()) the function f is executed even if condition is true.\n\nThe provided string is abi-encoded as if it were a call to a function Error(string). In the above example, revert(\"Not enough Ether provided.\"); returns the following hexadecimal as error return data:\n\nopen in Remix\n\n0x08c379a0                                                         // Function selector for Error(string)\n0x0000000000000000000000000000000000000000000000000000000000000020 // Data offset\n0x000000000000000000000000000000000000000000000000000000000000001a // String length\n0x4e6f7420656e6f7567682045746865722070726f76696465642e000000000000 // String data\n\n\nThe provided message can be retrieved by the caller using try/catch as shown below.\n\nNote\n\nThere used to be a keyword called throw with the same semantics as revert() which was deprecated in version 0.4.13 and removed in version 0.5.0.\n\ntry/catch\n\nA failure in an external call can be caught using a try/catch statement, as follows:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.1;\n\ninterface DataFeed { function getData(address token) external returns (uint value); }\n\ncontract FeedConsumer {\n    DataFeed feed;\n    uint errorCount;\n    function rate(address token) public returns (uint value, bool success) {\n        // Permanently disable the mechanism if there are\n        // more than 10 errors.\n        require(errorCount < 10);\n        try feed.getData(token) returns (uint v) {\n            return (v, true);\n        } catch Error(string memory /*reason*/) {\n            // This is executed in case\n            // revert was called inside getData\n            // and a reason string was provided.\n            errorCount++;\n            return (0, false);\n        } catch Panic(uint /*errorCode*/) {\n            // This is executed in case of a panic,\n            // i.e. a serious error like division by zero\n            // or overflow. The error code can be used\n            // to determine the kind of error.\n            errorCount++;\n            return (0, false);\n        } catch (bytes memory /*lowLevelData*/) {\n            // This is executed in case revert() was used.\n            errorCount++;\n            return (0, false);\n        }\n    }\n}\n\n\nThe try keyword has to be followed by an expression representing an external function call or a contract creation (new ContractName()). Errors inside the expression are not caught (for example if it is a complex expression that also involves internal function calls), only a revert happening inside the external call itself. The returns part (which is optional) that follows declares return variables matching the types returned by the external call. In case there was no error, these variables are assigned and the contract’s execution continues inside the first success block. If the end of the success block is reached, execution continues after the catch blocks.\n\nSolidity supports different kinds of catch blocks depending on the type of error:\n\ncatch Error(string memory reason) { ... }: This catch clause is executed if the error was caused by revert(\"reasonString\") or require(false, \"reasonString\") (or an internal error that causes such an exception).\n\ncatch Panic(uint errorCode) { ... }: If the error was caused by a panic, i.e. by a failing assert, division by zero, invalid array access, arithmetic overflow and others, this catch clause will be run.\n\ncatch (bytes memory lowLevelData) { ... }: This clause is executed if the error signature does not match any other clause, if there was an error while decoding the error message, or if no error data was provided with the exception. The declared variable provides access to the low-level error data in that case.\n\ncatch { ... }: If you are not interested in the error data, you can just use catch { ... } (even as the only catch clause) instead of the previous clause.\n\nIt is planned to support other types of error data in the future. The strings Error and Panic are currently parsed as is and are not treated as identifiers.\n\nIn order to catch all error cases, you have to have at least the clause catch { ...} or the clause catch (bytes memory lowLevelData) { ... }.\n\nThe variables declared in the returns and the catch clause are only in scope in the block that follows.\n\nNote\n\nIf an error happens during the decoding of the return data inside a try/catch-statement, this causes an exception in the currently executing contract and because of that, it is not caught in the catch clause. If there is an error during decoding of catch Error(string memory reason) and there is a low-level catch clause, this error is caught there.\n\nNote\n\nIf execution reaches a catch-block, then the state-changing effects of the external call have been reverted. If execution reaches the success block, the effects were not reverted. If the effects have been reverted, then execution either continues in a catch block or the execution of the try/catch statement itself reverts (for example due to decoding failures as noted above or due to not providing a low-level catch clause).\n\nNote\n\nThe reason behind a failed call can be manifold. Do not assume that the error message is coming directly from the called contract: The error might have happened deeper down in the call chain and the called contract just forwarded it. Also, it could be due to an out-of-gas situation and not a deliberate error condition: The caller always retains at least 1/64th of the gas in a call and thus even if the called contract goes out of gas, the caller still has some gas left.\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Types — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/types.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nValue Types\nReference Types\nMapping Types\nOperators\nConversions between Elementary Types\nConversions between Literals and Elementary Types\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Types\n Edit on GitHub\nTypes\n\nSolidity is a statically typed language, which means that the type of each variable (state and local) needs to be specified. Solidity provides several elementary types which can be combined to form complex types.\n\nIn addition, types can interact with each other in expressions containing operators. For a quick reference of the various operators, see Order of Precedence of Operators.\n\nThe concept of “undefined” or “null” values does not exist in Solidity, but newly declared variables always have a default value dependent on its type. To handle any unexpected values, you should use the revert function to revert the whole transaction, or return a tuple with a second bool value denoting success.\n\nValue Types\n\nThe following are called value types because their variables will always be passed by value, i.e. they are always copied when they are used as function arguments or in assignments.\n\nBooleans\n\nbool: The possible values are constants true and false.\n\nOperators:\n\n! (logical negation)\n\n&& (logical conjunction, “and”)\n\n|| (logical disjunction, “or”)\n\n== (equality)\n\n!= (inequality)\n\nThe operators || and && apply the common short-circuiting rules. This means that in the expression f(x) || g(y), if f(x) evaluates to true, g(y) will not be evaluated even if it may have side-effects.\n\nIntegers\n\nint / uint: Signed and unsigned integers of various sizes. Keywords uint8 to uint256 in steps of 8 (unsigned of 8 up to 256 bits) and int8 to int256. uint and int are aliases for uint256 and int256, respectively.\n\nOperators:\n\nComparisons: <=, <, ==, !=, >=, > (evaluate to bool)\n\nBit operators: &, |, ^ (bitwise exclusive or), ~ (bitwise negation)\n\nShift operators: << (left shift), >> (right shift)\n\nArithmetic operators: +, -, unary - (only for signed integers), *, /, % (modulo), ** (exponentiation)\n\nFor an integer type X, you can use type(X).min and type(X).max to access the minimum and maximum value representable by the type.\n\nWarning\n\nIntegers in Solidity are restricted to a certain range. For example, with uint32, this is 0 up to 2**32 - 1. There are two modes in which arithmetic is performed on these types: The “wrapping” or “unchecked” mode and the “checked” mode. By default, arithmetic is always “checked”, meaning that if an operation’s result falls outside the value range of the type, the call is reverted through a failing assertion. You can switch to “unchecked” mode using unchecked { ... }. More details can be found in the section about unchecked.\n\nComparisons\n\nThe value of a comparison is the one obtained by comparing the integer value.\n\nBit operations\n\nBit operations are performed on the two’s complement representation of the number. This means that, for example ~int256(0) == int256(-1).\n\nShifts\n\nThe result of a shift operation has the type of the left operand, truncating the result to match the type. The right operand must be of unsigned type, trying to shift by a signed type will produce a compilation error.\n\nShifts can be “simulated” using multiplication by powers of two in the following way. Note that the truncation to the type of the left operand is always performed at the end, but not mentioned explicitly.\n\nx << y is equivalent to the mathematical expression x * 2**y.\n\nx >> y is equivalent to the mathematical expression x / 2**y, rounded towards negative infinity.\n\nWarning\n\nBefore version 0.5.0 a right shift x >> y for negative x was equivalent to the mathematical expression x / 2**y rounded towards zero, i.e., right shifts used rounding up (towards zero) instead of rounding down (towards negative infinity).\n\nNote\n\nOverflow checks are never performed for shift operations as they are done for arithmetic operations. Instead, the result is always truncated.\n\nAddition, Subtraction and Multiplication\n\nAddition, subtraction and multiplication have the usual semantics, with two different modes in regard to over- and underflow:\n\nBy default, all arithmetic is checked for under- or overflow, but this can be disabled using the unchecked block, resulting in wrapping arithmetic. More details can be found in that section.\n\nThe expression -x is equivalent to (T(0) - x) where T is the type of x. It can only be applied to signed types. The value of -x can be positive if x is negative. There is another caveat also resulting from two’s complement representation:\n\nIf you have int x = type(int).min;, then -x does not fit the positive range. This means that unchecked { assert(-x == x); } works, and the expression -x when used in checked mode will result in a failing assertion.\n\nDivision\n\nSince the type of the result of an operation is always the type of one of the operands, division on integers always results in an integer. In Solidity, division rounds towards zero. This means that int256(-5) / int256(2) == int256(-2).\n\nNote that in contrast, division on literals results in fractional values of arbitrary precision.\n\nNote\n\nDivision by zero causes a Panic error. This check can not be disabled through unchecked { ... }.\n\nNote\n\nThe expression type(int).min / (-1) is the only case where division causes an overflow. In checked arithmetic mode, this will cause a failing assertion, while in wrapping mode, the value will be type(int).min.\n\nModulo\n\nThe modulo operation a % n yields the remainder r after the division of the operand a by the operand n, where q = int(a / n) and r = a - (n * q). This means that modulo results in the same sign as its left operand (or zero) and a % n == -(-a % n) holds for negative a:\n\nint256(5) % int256(2) == int256(1)\n\nint256(5) % int256(-2) == int256(1)\n\nint256(-5) % int256(2) == int256(-1)\n\nint256(-5) % int256(-2) == int256(-1)\n\nNote\n\nModulo with zero causes a Panic error. This check can not be disabled through unchecked { ... }.\n\nExponentiation\n\nExponentiation is only available for unsigned types in the exponent. The resulting type of an exponentiation is always equal to the type of the base. Please take care that it is large enough to hold the result and prepare for potential assertion failures or wrapping behavior.\n\nNote\n\nIn checked mode, exponentiation only uses the comparatively cheap exp opcode for small bases. For the cases of x**3, the expression x*x*x might be cheaper. In any case, gas cost tests and the use of the optimizer are advisable.\n\nNote\n\nNote that 0**0 is defined by the EVM as 1.\n\nFixed Point Numbers\n\nWarning\n\nFixed point numbers are not fully supported by Solidity yet. They can be declared, but cannot be assigned to or from.\n\nfixed / ufixed: Signed and unsigned fixed point number of various sizes. Keywords ufixedMxN and fixedMxN, where M represents the number of bits taken by the type and N represents how many decimal points are available. M must be divisible by 8 and goes from 8 to 256 bits. N must be between 0 and 80, inclusive. ufixed and fixed are aliases for ufixed128x18 and fixed128x18, respectively.\n\nOperators:\n\nComparisons: <=, <, ==, !=, >=, > (evaluate to bool)\n\nArithmetic operators: +, -, unary -, *, /, % (modulo)\n\nNote\n\nThe main difference between floating point (float and double in many languages, more precisely IEEE 754 numbers) and fixed point numbers is that the number of bits used for the integer and the fractional part (the part after the decimal dot) is flexible in the former, while it is strictly defined in the latter. Generally, in floating point almost the entire space is used to represent the number, while only a small number of bits define where the decimal point is.\n\nAddress\n\nThe address type comes in two largely identical flavors:\n\naddress: Holds a 20 byte value (size of an Ethereum address).\n\naddress payable: Same as address, but with the additional members transfer and send.\n\nThe idea behind this distinction is that address payable is an address you can send Ether to, while you are not supposed to send Ether to a plain address, for example because it might be a smart contract that was not built to accept Ether.\n\nType conversions:\n\nImplicit conversions from address payable to address are allowed, whereas conversions from address to address payable must be explicit via payable(<address>).\n\nExplicit conversions to and from address are allowed for uint160, integer literals, bytes20 and contract types.\n\nOnly expressions of type address and contract-type can be converted to the type address payable via the explicit conversion payable(...). For contract-type, this conversion is only allowed if the contract can receive Ether, i.e., the contract either has a receive or a payable fallback function. Note that payable(0) is valid and is an exception to this rule.\n\nNote\n\nIf you need a variable of type address and plan to send Ether to it, then declare its type as address payable to make this requirement visible. Also, try to make this distinction or conversion as early as possible.\n\nThe distinction between address and address payable was introduced with version 0.5.0. Also starting from that version, contracts are not implicitly convertible to the address type, but can still be explicitly converted to address or to address payable, if they have a receive or payable fallback function.\n\nOperators:\n\n<=, <, ==, !=, >= and >\n\nWarning\n\nIf you convert a type that uses a larger byte size to an address, for example bytes32, then the address is truncated. To reduce conversion ambiguity, starting with version 0.4.24, the compiler will force you to make the truncation explicit in the conversion. Take for example the 32-byte value 0x111122223333444455556666777788889999AAAABBBBCCCCDDDDEEEEFFFFCCCC.\n\nYou can use address(uint160(bytes20(b))), which results in 0x111122223333444455556666777788889999aAaa, or you can use address(uint160(uint256(b))), which results in 0x777788889999AaAAbBbbCcccddDdeeeEfFFfCcCc.\n\nNote\n\nMixed-case hexadecimal numbers conforming to EIP-55 are automatically treated as literals of the address type. See Address Literals.\n\nMembers of Addresses\n\nFor a quick reference of all members of address, see Members of Address Types.\n\nbalance and transfer\n\nIt is possible to query the balance of an address using the property balance and to send Ether (in units of wei) to a payable address using the transfer function:\n\nopen in Remix\n\naddress payable x = payable(0x123);\naddress myAddress = address(this);\nif (x.balance < 10 && myAddress.balance >= 10) x.transfer(10);\n\n\nThe transfer function fails if the balance of the current contract is not large enough or if the Ether transfer is rejected by the receiving account. The transfer function reverts on failure.\n\nNote\n\nIf x is a contract address, its code (more specifically: its Receive Ether Function, if present, or otherwise its Fallback Function, if present) will be executed together with the transfer call (this is a feature of the EVM and cannot be prevented). If that execution runs out of gas or fails in any way, the Ether transfer will be reverted and the current contract will stop with an exception.\n\nsend\n\nsend is the low-level counterpart of transfer. If the execution fails, the current contract will not stop with an exception, but send will return false.\n\nWarning\n\nThere are some dangers in using send: The transfer fails if the call stack depth is at 1024 (this can always be forced by the caller) and it also fails if the recipient runs out of gas. So in order to make safe Ether transfers, always check the return value of send, use transfer or even better: use a pattern where the recipient withdraws the Ether.\n\ncall, delegatecall and staticcall\n\nIn order to interface with contracts that do not adhere to the ABI, or to get more direct control over the encoding, the functions call, delegatecall and staticcall are provided. They all take a single bytes memory parameter and return the success condition (as a bool) and the returned data (bytes memory). The functions abi.encode, abi.encodePacked, abi.encodeWithSelector and abi.encodeWithSignature can be used to encode structured data.\n\nExample:\n\nopen in Remix\n\nbytes memory payload = abi.encodeWithSignature(\"register(string)\", \"MyName\");\n(bool success, bytes memory returnData) = address(nameReg).call(payload);\nrequire(success);\n\n\nWarning\n\nAll these functions are low-level functions and should be used with care. Specifically, any unknown contract might be malicious and if you call it, you hand over control to that contract which could in turn call back into your contract, so be prepared for changes to your state variables when the call returns. The regular way to interact with other contracts is to call a function on a contract object (x.f()).\n\nNote\n\nPrevious versions of Solidity allowed these functions to receive arbitrary arguments and would also handle a first argument of type bytes4 differently. These edge cases were removed in version 0.5.0.\n\nIt is possible to adjust the supplied gas with the gas modifier:\n\nopen in Remix\n\naddress(nameReg).call{gas: 1000000}(abi.encodeWithSignature(\"register(string)\", \"MyName\"));\n\n\nSimilarly, the supplied Ether value can be controlled too:\n\nopen in Remix\n\naddress(nameReg).call{value: 1 ether}(abi.encodeWithSignature(\"register(string)\", \"MyName\"));\n\n\nLastly, these modifiers can be combined. Their order does not matter:\n\nopen in Remix\n\naddress(nameReg).call{gas: 1000000, value: 1 ether}(abi.encodeWithSignature(\"register(string)\", \"MyName\"));\n\n\nIn a similar way, the function delegatecall can be used: the difference is that only the code of the given address is used, all other aspects (storage, balance, …) are taken from the current contract. The purpose of delegatecall is to use library code which is stored in another contract. The user has to ensure that the layout of storage in both contracts is suitable for delegatecall to be used.\n\nNote\n\nPrior to homestead, only a limited variant called callcode was available that did not provide access to the original msg.sender and msg.value values. This function was removed in version 0.5.0.\n\nSince byzantium staticcall can be used as well. This is basically the same as call, but will revert if the called function modifies the state in any way.\n\nAll three functions call, delegatecall and staticcall are very low-level functions and should only be used as a last resort as they break the type-safety of Solidity.\n\nThe gas option is available on all three methods, while the value option is only available on call.\n\nNote\n\nIt is best to avoid relying on hardcoded gas values in your smart contract code, regardless of whether state is read from or written to, as this can have many pitfalls. Also, access to gas might change in the future.\n\ncode and codehash\n\nYou can query the deployed code for any smart contract. Use .code to get the EVM bytecode as a bytes memory, which might be empty. Use .codehash to get the Keccak-256 hash of that code (as a bytes32). Note that addr.codehash is cheaper than using keccak256(addr.code).\n\nNote\n\nAll contracts can be converted to address type, so it is possible to query the balance of the current contract using address(this).balance.\n\nContract Types\n\nEvery contract defines its own type. You can implicitly convert contracts to contracts they inherit from. Contracts can be explicitly converted to and from the address type.\n\nExplicit conversion to and from the address payable type is only possible if the contract type has a receive or payable fallback function. The conversion is still performed using address(x). If the contract type does not have a receive or payable fallback function, the conversion to address payable can be done using payable(address(x)). You can find more information in the section about the address type.\n\nNote\n\nBefore version 0.5.0, contracts directly derived from the address type and there was no distinction between address and address payable.\n\nIf you declare a local variable of contract type (MyContract c), you can call functions on that contract. Take care to assign it from somewhere that is the same contract type.\n\nYou can also instantiate contracts (which means they are newly created). You can find more details in the ‘Contracts via new’ section.\n\nThe data representation of a contract is identical to that of the address type and this type is also used in the ABI.\n\nContracts do not support any operators.\n\nThe members of contract types are the external functions of the contract including any state variables marked as public.\n\nFor a contract C you can use type(C) to access type information about the contract.\n\nFixed-size byte arrays\n\nThe value types bytes1, bytes2, bytes3, …, bytes32 hold a sequence of bytes from one to up to 32.\n\nOperators:\n\nComparisons: <=, <, ==, !=, >=, > (evaluate to bool)\n\nBit operators: &, |, ^ (bitwise exclusive or), ~ (bitwise negation)\n\nShift operators: << (left shift), >> (right shift)\n\nIndex access: If x is of type bytesI, then x[k] for 0 <= k < I returns the k th byte (read-only).\n\nThe shifting operator works with unsigned integer type as right operand (but returns the type of the left operand), which denotes the number of bits to shift by. Shifting by a signed type will produce a compilation error.\n\nMembers:\n\n.length yields the fixed length of the byte array (read-only).\n\nNote\n\nThe type bytes1[] is an array of bytes, but due to padding rules, it wastes 31 bytes of space for each element (except in storage). It is better to use the bytes type instead.\n\nNote\n\nPrior to version 0.8.0, byte used to be an alias for bytes1.\n\nDynamically-sized byte array\nbytes:\n\nDynamically-sized byte array, see Arrays. Not a value-type!\n\nstring:\n\nDynamically-sized UTF-8-encoded string, see Arrays. Not a value-type!\n\nAddress Literals\n\nHexadecimal literals that pass the address checksum test, for example 0xdCad3a6d3569DF655070DEd06cb7A1b2Ccd1D3AF are of address type. Hexadecimal literals that are between 39 and 41 digits long and do not pass the checksum test produce an error. You can prepend (for integer types) or append (for bytesNN types) zeros to remove the error.\n\nNote\n\nThe mixed-case address checksum format is defined in EIP-55.\n\nRational and Integer Literals\n\nInteger literals are formed from a sequence of digits in the range 0-9. They are interpreted as decimals. For example, 69 means sixty nine. Octal literals do not exist in Solidity and leading zeros are invalid.\n\nDecimal fractional literals are formed by a . with at least one number after the decimal point. Examples include .1 and 1.3 (but not 1.).\n\nScientific notation in the form of 2e10 is also supported, where the mantissa can be fractional but the exponent has to be an integer. The literal MeE is equivalent to M * 10**E. Examples include 2e10, -2e10, 2e-10, 2.5e1.\n\nUnderscores can be used to separate the digits of a numeric literal to aid readability. For example, decimal 123_000, hexadecimal 0x2eff_abde, scientific decimal notation 1_2e345_678 are all valid. Underscores are only allowed between two digits and only one consecutive underscore is allowed. There is no additional semantic meaning added to a number literal containing underscores, the underscores are ignored.\n\nNumber literal expressions retain arbitrary precision until they are converted to a non-literal type (i.e. by using them together with anything other than a number literal expression (like boolean literals) or by explicit conversion). This means that computations do not overflow and divisions do not truncate in number literal expressions.\n\nFor example, (2**800 + 1) - 2**800 results in the constant 1 (of type uint8) although intermediate results would not even fit the machine word size. Furthermore, .5 * 8 results in the integer 4 (although non-integers were used in between).\n\nWarning\n\nWhile most operators produce a literal expression when applied to literals, there are certain operators that do not follow this pattern:\n\nTernary operator (... ? ... : ...),\n\nArray subscript (<array>[<index>]).\n\nYou might expect expressions like 255 + (true ? 1 : 0) or 255 + [1, 2, 3][0] to be equivalent to using the literal 256 directly, but in fact they are computed within the type uint8 and can overflow.\n\nAny operator that can be applied to integers can also be applied to number literal expressions as long as the operands are integers. If any of the two is fractional, bit operations are disallowed and exponentiation is disallowed if the exponent is fractional (because that might result in a non-rational number).\n\nShifts and exponentiation with literal numbers as left (or base) operand and integer types as the right (exponent) operand are always performed in the uint256 (for non-negative literals) or int256 (for a negative literals) type, regardless of the type of the right (exponent) operand.\n\nWarning\n\nDivision on integer literals used to truncate in Solidity prior to version 0.4.0, but it now converts into a rational number, i.e. 5 / 2 is not equal to 2, but to 2.5.\n\nNote\n\nSolidity has a number literal type for each rational number. Integer literals and rational number literals belong to number literal types. Moreover, all number literal expressions (i.e. the expressions that contain only number literals and operators) belong to number literal types. So the number literal expressions 1 + 2 and 2 + 1 both belong to the same number literal type for the rational number three.\n\nNote\n\nNumber literal expressions are converted into a non-literal type as soon as they are used with non-literal expressions. Disregarding types, the value of the expression assigned to b below evaluates to an integer. Because a is of type uint128, the expression 2.5 + a has to have a proper type, though. Since there is no common type for the type of 2.5 and uint128, the Solidity compiler does not accept this code.\n\nopen in Remix\n\nuint128 a = 1;\nuint128 b = 2.5 + a + 0.5;\n\nString Literals and Types\n\nString literals are written with either double or single-quotes (\"foo\" or 'bar'), and they can also be split into multiple consecutive parts (\"foo\" \"bar\" is equivalent to \"foobar\") which can be helpful when dealing with long strings. They do not imply trailing zeroes as in C; \"foo\" represents three bytes, not four. As with integer literals, their type can vary, but they are implicitly convertible to bytes1, …, bytes32, if they fit, to bytes and to string.\n\nFor example, with bytes32 samevar = \"stringliteral\" the string literal is interpreted in its raw byte form when assigned to a bytes32 type.\n\nString literals can only contain printable ASCII characters, which means the characters between and including 0x20 .. 0x7E.\n\nAdditionally, string literals also support the following escape characters:\n\n\\<newline> (escapes an actual newline)\n\n\\\\ (backslash)\n\n\\' (single quote)\n\n\\\" (double quote)\n\n\\n (newline)\n\n\\r (carriage return)\n\n\\t (tab)\n\n\\xNN (hex escape, see below)\n\n\\uNNNN (unicode escape, see below)\n\n\\xNN takes a hex value and inserts the appropriate byte, while \\uNNNN takes a Unicode codepoint and inserts an UTF-8 sequence.\n\nNote\n\nUntil version 0.8.0 there were three additional escape sequences: \\b, \\f and \\v. They are commonly available in other languages but rarely needed in practice. If you do need them, they can still be inserted via hexadecimal escapes, i.e. \\x08, \\x0c and \\x0b, respectively, just as any other ASCII character.\n\nThe string in the following example has a length of ten bytes. It starts with a newline byte, followed by a double quote, a single quote a backslash character and then (without separator) the character sequence abcdef.\n\nopen in Remix\n\n\"\\n\\\"\\'\\\\abc\\\ndef\"\n\n\nAny Unicode line terminator which is not a newline (i.e. LF, VF, FF, CR, NEL, LS, PS) is considered to terminate the string literal. Newline only terminates the string literal if it is not preceded by a \\.\n\nUnicode Literals\n\nWhile regular string literals can only contain ASCII, Unicode literals – prefixed with the keyword unicode – can contain any valid UTF-8 sequence. They also support the very same escape sequences as regular string literals.\n\nopen in Remix\n\nstring memory a = unicode\"Hello 😃\";\n\nHexadecimal Literals\n\nHexadecimal literals are prefixed with the keyword hex and are enclosed in double or single-quotes (hex\"001122FF\", hex'0011_22_FF'). Their content must be hexadecimal digits which can optionally use a single underscore as separator between byte boundaries. The value of the literal will be the binary representation of the hexadecimal sequence.\n\nMultiple hexadecimal literals separated by whitespace are concatenated into a single literal: hex\"00112233\" hex\"44556677\" is equivalent to hex\"0011223344556677\"\n\nHexadecimal literals in some ways behave like string literals but are not implicitly convertible to the string type.\n\nEnums\n\nEnums are one way to create a user-defined type in Solidity. They are explicitly convertible to and from all integer types but implicit conversion is not allowed. The explicit conversion from integer checks at runtime that the value lies inside the range of the enum and causes a Panic error otherwise. Enums require at least one member, and its default value when declared is the first member. Enums cannot have more than 256 members.\n\nThe data representation is the same as for enums in C: The options are represented by subsequent unsigned integer values starting from 0.\n\nUsing type(NameOfEnum).min and type(NameOfEnum).max you can get the smallest and respectively largest value of the given enum.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.8;\n\ncontract test {\n    enum ActionChoices { GoLeft, GoRight, GoStraight, SitStill }\n    ActionChoices choice;\n    ActionChoices constant defaultChoice = ActionChoices.GoStraight;\n\n    function setGoStraight() public {\n        choice = ActionChoices.GoStraight;\n    }\n\n    // Since enum types are not part of the ABI, the signature of \"getChoice\"\n    // will automatically be changed to \"getChoice() returns (uint8)\"\n    // for all matters external to Solidity.\n    function getChoice() public view returns (ActionChoices) {\n        return choice;\n    }\n\n    function getDefaultChoice() public pure returns (uint) {\n        return uint(defaultChoice);\n    }\n\n    function getLargestValue() public pure returns (ActionChoices) {\n        return type(ActionChoices).max;\n    }\n\n    function getSmallestValue() public pure returns (ActionChoices) {\n        return type(ActionChoices).min;\n    }\n}\n\n\nNote\n\nEnums can also be declared on the file level, outside of contract or library definitions.\n\nUser-defined Value Types\n\nA user-defined value type allows creating a zero cost abstraction over an elementary value type. This is similar to an alias, but with stricter type requirements.\n\nA user-defined value type is defined using type C is V, where C is the name of the newly introduced type and V has to be a built-in value type (the “underlying type”). The function C.wrap is used to convert from the underlying type to the custom type. Similarly, the function C.unwrap is used to convert from the custom type to the underlying type.\n\nThe type C does not have any operators or attached member functions. In particular, even the operator == is not defined. Explicit and implicit conversions to and from other types are disallowed.\n\nThe data-representation of values of such types are inherited from the underlying type and the underlying type is also used in the ABI.\n\nThe following example illustrates a custom type UFixed256x18 representing a decimal fixed point type with 18 decimals and a minimal library to do arithmetic operations on the type.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.8;\n\n// Represent a 18 decimal, 256 bit wide fixed point type using a user-defined value type.\ntype UFixed256x18 is uint256;\n\n/// A minimal library to do fixed point operations on UFixed256x18.\nlibrary FixedMath {\n    uint constant multiplier = 10**18;\n\n    /// Adds two UFixed256x18 numbers. Reverts on overflow, relying on checked\n    /// arithmetic on uint256.\n    function add(UFixed256x18 a, UFixed256x18 b) internal pure returns (UFixed256x18) {\n        return UFixed256x18.wrap(UFixed256x18.unwrap(a) + UFixed256x18.unwrap(b));\n    }\n    /// Multiplies UFixed256x18 and uint256. Reverts on overflow, relying on checked\n    /// arithmetic on uint256.\n    function mul(UFixed256x18 a, uint256 b) internal pure returns (UFixed256x18) {\n        return UFixed256x18.wrap(UFixed256x18.unwrap(a) * b);\n    }\n    /// Take the floor of a UFixed256x18 number.\n    /// @return the largest integer that does not exceed `a`.\n    function floor(UFixed256x18 a) internal pure returns (uint256) {\n        return UFixed256x18.unwrap(a) / multiplier;\n    }\n    /// Turns a uint256 into a UFixed256x18 of the same value.\n    /// Reverts if the integer is too large.\n    function toUFixed256x18(uint256 a) internal pure returns (UFixed256x18) {\n        return UFixed256x18.wrap(a * multiplier);\n    }\n}\n\n\nNotice how UFixed256x18.wrap and FixedMath.toUFixed256x18 have the same signature but perform two very different operations: The UFixed256x18.wrap function returns a UFixed256x18 that has the same data representation as the input, whereas toUFixed256x18 returns a UFixed256x18 that has the same numerical value.\n\nFunction Types\n\nFunction types are the types of functions. Variables of function type can be assigned from functions and function parameters of function type can be used to pass functions to and return functions from function calls. Function types come in two flavours - internal and external functions:\n\nInternal functions can only be called inside the current contract (more specifically, inside the current code unit, which also includes internal library functions and inherited functions) because they cannot be executed outside of the context of the current contract. Calling an internal function is realized by jumping to its entry label, just like when calling a function of the current contract internally.\n\nExternal functions consist of an address and a function signature and they can be passed via and returned from external function calls.\n\nFunction types are notated as follows:\n\nopen in Remix\n\nfunction (<parameter types>) {internal|external} [pure|view|payable] [returns (<return types>)]\n\n\nIn contrast to the parameter types, the return types cannot be empty - if the function type should not return anything, the whole returns (<return types>) part has to be omitted.\n\nBy default, function types are internal, so the internal keyword can be omitted. Note that this only applies to function types. Visibility has to be specified explicitly for functions defined in contracts, they do not have a default.\n\nConversions:\n\nA function type A is implicitly convertible to a function type B if and only if their parameter types are identical, their return types are identical, their internal/external property is identical and the state mutability of A is more restrictive than the state mutability of B. In particular:\n\npure functions can be converted to view and non-payable functions\n\nview functions can be converted to non-payable functions\n\npayable functions can be converted to non-payable functions\n\nNo other conversions between function types are possible.\n\nThe rule about payable and non-payable might be a little confusing, but in essence, if a function is payable, this means that it also accepts a payment of zero Ether, so it also is non-payable. On the other hand, a non-payable function will reject Ether sent to it, so non-payable functions cannot be converted to payable functions. To clarify, rejecting ether is more restrictive than not rejecting ether. This means you can override a payable function with a non-payable but not the other way around.\n\nAdditionally, When you define a non-payable function pointer, the compiler does not enforce that the pointed function will actually reject ether. Instead, it enforces that the function pointer is never used to send ether. Which makes it possible to assign a payable function pointer to a non-payable function pointer ensuring both types behave the same way, i.e, both cannot be used to send ether.\n\nIf a function type variable is not initialised, calling it results in a Panic error. The same happens if you call a function after using delete on it.\n\nIf external function types are used outside of the context of Solidity, they are treated as the function type, which encodes the address followed by the function identifier together in a single bytes24 type.\n\nNote that public functions of the current contract can be used both as an internal and as an external function. To use f as an internal function, just use f, if you want to use its external form, use this.f.\n\nA function of an internal type can be assigned to a variable of an internal function type regardless of where it is defined. This includes private, internal and public functions of both contracts and libraries as well as free functions. External function types, on the other hand, are only compatible with public and external contract functions.\n\nNote\n\nExternal functions with calldata parameters are incompatible with external function types with calldata parameters. They are compatible with the corresponding types with memory parameters instead. For example, there is no function that can be pointed at by a value of type function (string calldata) external while function (string memory) external can point at both function f(string memory) external {} and function g(string calldata) external {}. This is because for both locations the arguments are passed to the function in the same way. The caller cannot pass its calldata directly to an external function and always ABI-encodes the arguments into memory. Marking the parameters as calldata only affects the implementation of the external function and is meaningless in a function pointer on the caller’s side.\n\nLibraries are excluded because they require a delegatecall and use a different ABI convention for their selectors. Functions declared in interfaces do not have definitions so pointing at them does not make sense either.\n\nMembers:\n\nExternal (or public) functions have the following members:\n\n.address returns the address of the contract of the function.\n\n.selector returns the ABI function selector\n\nNote\n\nExternal (or public) functions used to have the additional members .gas(uint) and .value(uint). These were deprecated in Solidity 0.6.2 and removed in Solidity 0.7.0. Instead use {gas: ...} and {value: ...} to specify the amount of gas or the amount of wei sent to a function, respectively. See External Function Calls for more information.\n\nExample that shows how to use the members:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.4 <0.9.0;\n\ncontract Example {\n    function f() public payable returns (bytes4) {\n        assert(this.f.address == address(this));\n        return this.f.selector;\n    }\n\n    function g() public {\n        this.f{gas: 10, value: 800}();\n    }\n}\n\n\nExample that shows how to use internal function types:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\nlibrary ArrayUtils {\n    // internal functions can be used in internal library functions because\n    // they will be part of the same code context\n    function map(uint[] memory self, function (uint) pure returns (uint) f)\n        internal\n        pure\n        returns (uint[] memory r)\n    {\n        r = new uint[](self.length);\n        for (uint i = 0; i < self.length; i++) {\n            r[i] = f(self[i]);\n        }\n    }\n\n    function reduce(\n        uint[] memory self,\n        function (uint, uint) pure returns (uint) f\n    )\n        internal\n        pure\n        returns (uint r)\n    {\n        r = self[0];\n        for (uint i = 1; i < self.length; i++) {\n            r = f(r, self[i]);\n        }\n    }\n\n    function range(uint length) internal pure returns (uint[] memory r) {\n        r = new uint[](length);\n        for (uint i = 0; i < r.length; i++) {\n            r[i] = i;\n        }\n    }\n}\n\n\ncontract Pyramid {\n    using ArrayUtils for *;\n\n    function pyramid(uint l) public pure returns (uint) {\n        return ArrayUtils.range(l).map(square).reduce(sum);\n    }\n\n    function square(uint x) internal pure returns (uint) {\n        return x * x;\n    }\n\n    function sum(uint x, uint y) internal pure returns (uint) {\n        return x + y;\n    }\n}\n\n\nAnother example that uses external function types:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\n\ncontract Oracle {\n    struct Request {\n        bytes data;\n        function(uint) external callback;\n    }\n\n    Request[] private requests;\n    event NewRequest(uint);\n\n    function query(bytes memory data, function(uint) external callback) public {\n        requests.push(Request(data, callback));\n        emit NewRequest(requests.length - 1);\n    }\n\n    function reply(uint requestID, uint response) public {\n        // Here goes the check that the reply comes from a trusted source\n        requests[requestID].callback(response);\n    }\n}\n\n\ncontract OracleUser {\n    Oracle constant private ORACLE_CONST = Oracle(address(0x00000000219ab540356cBB839Cbe05303d7705Fa)); // known contract\n    uint private exchangeRate;\n\n    function buySomething() public {\n        ORACLE_CONST.query(\"USD\", this.oracleResponse);\n    }\n\n    function oracleResponse(uint response) public {\n        require(\n            msg.sender == address(ORACLE_CONST),\n            \"Only oracle can call this.\"\n        );\n        exchangeRate = response;\n    }\n}\n\n\nNote\n\nLambda or inline functions are planned but not yet supported.\n\nReference Types\n\nValues of reference type can be modified through multiple different names. Contrast this with value types where you get an independent copy whenever a variable of value type is used. Because of that, reference types have to be handled more carefully than value types. Currently, reference types comprise structs, arrays and mappings. If you use a reference type, you always have to explicitly provide the data area where the type is stored: memory (whose lifetime is limited to an external function call), storage (the location where the state variables are stored, where the lifetime is limited to the lifetime of a contract) or calldata (special data location that contains the function arguments).\n\nAn assignment or type conversion that changes the data location will always incur an automatic copy operation, while assignments inside the same data location only copy in some cases for storage types.\n\nData location\n\nEvery reference type has an additional annotation, the “data location”, about where it is stored. There are three data locations: memory, storage and calldata. Calldata is a non-modifiable, non-persistent area where function arguments are stored, and behaves mostly like memory.\n\nNote\n\nIf you can, try to use calldata as data location because it will avoid copies and also makes sure that the data cannot be modified. Arrays and structs with calldata data location can also be returned from functions, but it is not possible to allocate such types.\n\nNote\n\nPrior to version 0.6.9 data location for reference-type arguments was limited to calldata in external functions, memory in public functions and either memory or storage in internal and private ones. Now memory and calldata are allowed in all functions regardless of their visibility.\n\nNote\n\nPrior to version 0.5.0 the data location could be omitted, and would default to different locations depending on the kind of variable, function type, etc., but all complex types must now give an explicit data location.\n\nData location and assignment behavior\n\nData locations are not only relevant for persistency of data, but also for the semantics of assignments:\n\nAssignments between storage and memory (or from calldata) always create an independent copy.\n\nAssignments from memory to memory only create references. This means that changes to one memory variable are also visible in all other memory variables that refer to the same data.\n\nAssignments from storage to a local storage variable also only assign a reference.\n\nAll other assignments to storage always copy. Examples for this case are assignments to state variables or to members of local variables of storage struct type, even if the local variable itself is just a reference.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\ncontract C {\n    // The data location of x is storage.\n    // This is the only place where the\n    // data location can be omitted.\n    uint[] x;\n\n    // The data location of memoryArray is memory.\n    function f(uint[] memory memoryArray) public {\n        x = memoryArray; // works, copies the whole array to storage\n        uint[] storage y = x; // works, assigns a pointer, data location of y is storage\n        y[7]; // fine, returns the 8th element\n        y.pop(); // fine, modifies x through y\n        delete x; // fine, clears the array, also modifies y\n        // The following does not work; it would need to create a new temporary /\n        // unnamed array in storage, but storage is \"statically\" allocated:\n        // y = memoryArray;\n        // Similarly, \"delete y\" is not valid, as assignments to local variables\n        // referencing storage objects can only be made from existing storage objects.\n        // It would \"reset\" the pointer, but there is no sensible location it could point to.\n        // For more details see the documentation of the \"delete\" operator.\n        // delete y;\n        g(x); // calls g, handing over a reference to x\n        h(x); // calls h and creates an independent, temporary copy in memory\n    }\n\n    function g(uint[] storage) internal pure {}\n    function h(uint[] memory) public pure {}\n}\n\nArrays\n\nArrays can have a compile-time fixed size, or they can have a dynamic size.\n\nThe type of an array of fixed size k and element type T is written as T[k], and an array of dynamic size as T[].\n\nFor example, an array of 5 dynamic arrays of uint is written as uint[][5]. The notation is reversed compared to some other languages. In Solidity, X[3] is always an array containing three elements of type X, even if X is itself an array. This is not the case in other languages such as C.\n\nIndices are zero-based, and access is in the opposite direction of the declaration.\n\nFor example, if you have a variable uint[][5] memory x, you access the seventh uint in the third dynamic array using x[2][6], and to access the third dynamic array, use x[2]. Again, if you have an array T[5] a for a type T that can also be an array, then a[2] always has type T.\n\nArray elements can be of any type, including mapping or struct. The general restrictions for types apply, in that mappings can only be stored in the storage data location and publicly-visible functions need parameters that are ABI types.\n\nIt is possible to mark state variable arrays public and have Solidity create a getter. The numeric index becomes a required parameter for the getter.\n\nAccessing an array past its end causes a failing assertion. Methods .push() and .push(value) can be used to append a new element at the end of a dynamically-sized array, where .push() appends a zero-initialized element and returns a reference to it.\n\nNote\n\nDynamically-sized arrays can only be resized in storage. In memory, such arrays can be of arbitrary size but the size cannot be changed once an array is allocated.\n\nbytes and string as Arrays\n\nVariables of type bytes and string are special arrays. The bytes type is similar to bytes1[], but it is packed tightly in calldata and memory. string is equal to bytes but does not allow length or index access.\n\nSolidity does not have string manipulation functions, but there are third-party string libraries. You can also compare two strings by their keccak256-hash using keccak256(abi.encodePacked(s1)) == keccak256(abi.encodePacked(s2)) and concatenate two strings using string.concat(s1, s2).\n\nYou should use bytes over bytes1[] because it is cheaper, since using bytes1[] in memory adds 31 padding bytes between the elements. Note that in storage, the padding is absent due to tight packing, see bytes and string. As a general rule, use bytes for arbitrary-length raw byte data and string for arbitrary-length string (UTF-8) data. If you can limit the length to a certain number of bytes, always use one of the value types bytes1 to bytes32 because they are much cheaper.\n\nNote\n\nIf you want to access the byte-representation of a string s, use bytes(s).length / bytes(s)[7] = 'x';. Keep in mind that you are accessing the low-level bytes of the UTF-8 representation, and not the individual characters.\n\nThe functions bytes.concat and string.concat\n\nYou can concatenate an arbitrary number of string values using string.concat. The function returns a single string memory array that contains the contents of the arguments without padding. If you want to use parameters of other types that are not implicitly convertible to string, you need to convert them to string first.\n\nAnalogously, the bytes.concat function can concatenate an arbitrary number of bytes or bytes1 ... bytes32 values. The function returns a single bytes memory array that contains the contents of the arguments without padding. If you want to use string parameters or other types that are not implicitly convertible to bytes, you need to convert them to bytes or bytes1/…/bytes32 first.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.12;\n\ncontract C {\n    string s = \"Storage\";\n    function f(bytes calldata bc, string memory sm, bytes16 b) public view {\n        string memory concatString = string.concat(s, string(bc), \"Literal\", sm);\n        assert((bytes(s).length + bc.length + 7 + bytes(sm).length) == bytes(concatString).length);\n\n        bytes memory concatBytes = bytes.concat(bytes(s), bc, bc[:2], \"Literal\", bytes(sm), b);\n        assert((bytes(s).length + bc.length + 2 + 7 + bytes(sm).length + b.length) == concatBytes.length);\n    }\n}\n\n\nIf you call string.concat or bytes.concat without arguments they return an empty array.\n\nAllocating Memory Arrays\n\nMemory arrays with dynamic length can be created using the new operator. As opposed to storage arrays, it is not possible to resize memory arrays (e.g. the .push member functions are not available). You either have to calculate the required size in advance or create a new memory array and copy every element.\n\nAs all variables in Solidity, the elements of newly allocated arrays are always initialized with the default value.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f(uint len) public pure {\n        uint[] memory a = new uint[](7);\n        bytes memory b = new bytes(len);\n        assert(a.length == 7);\n        assert(b.length == len);\n        a[6] = 8;\n    }\n}\n\nArray Literals\n\nAn array literal is a comma-separated list of one or more expressions, enclosed in square brackets ([...]). For example [1, a, f(3)]. The type of the array literal is determined as follows:\n\nIt is always a statically-sized memory array whose length is the number of expressions.\n\nThe base type of the array is the type of the first expression on the list such that all other expressions can be implicitly converted to it. It is a type error if this is not possible.\n\nIt is not enough that there is a type all the elements can be converted to. One of the elements has to be of that type.\n\nIn the example below, the type of [1, 2, 3] is uint8[3] memory, because the type of each of these constants is uint8. If you want the result to be a uint[3] memory type, you need to convert the first element to uint.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f() public pure {\n        g([uint(1), 2, 3]);\n    }\n    function g(uint[3] memory) public pure {\n        // ...\n    }\n}\n\n\nThe array literal [1, -1] is invalid because the type of the first expression is uint8 while the type of the second is int8 and they cannot be implicitly converted to each other. To make it work, you can use [int8(1), -1], for example.\n\nSince fixed-size memory arrays of different type cannot be converted into each other (even if the base types can), you always have to specify a common base type explicitly if you want to use two-dimensional array literals:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f() public pure returns (uint24[2][4] memory) {\n        uint24[2][4] memory x = [[uint24(0x1), 1], [0xffffff, 2], [uint24(0xff), 3], [uint24(0xffff), 4]];\n        // The following does not work, because some of the inner arrays are not of the right type.\n        // uint[2][4] memory x = [[0x1, 1], [0xffffff, 2], [0xff, 3], [0xffff, 4]];\n        return x;\n    }\n}\n\n\nFixed size memory arrays cannot be assigned to dynamically-sized memory arrays, i.e. the following is not possible:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\n// This will not compile.\ncontract C {\n    function f() public {\n        // The next line creates a type error because uint[3] memory\n        // cannot be converted to uint[] memory.\n        uint[] memory x = [uint(1), 3, 4];\n    }\n}\n\n\nIt is planned to remove this restriction in the future, but it creates some complications because of how arrays are passed in the ABI.\n\nIf you want to initialize dynamically-sized arrays, you have to assign the individual elements:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract C {\n    function f() public pure {\n        uint[] memory x = new uint[](3);\n        x[0] = 1;\n        x[1] = 3;\n        x[2] = 4;\n    }\n}\n\nArray Members\nlength:\n\nArrays have a length member that contains their number of elements. The length of memory arrays is fixed (but dynamic, i.e. it can depend on runtime parameters) once they are created.\n\npush():\n\nDynamic storage arrays and bytes (not string) have a member function called push() that you can use to append a zero-initialised element at the end of the array. It returns a reference to the element, so that it can be used like x.push().t = 2 or x.push() = b.\n\npush(x):\n\nDynamic storage arrays and bytes (not string) have a member function called push(x) that you can use to append a given element at the end of the array. The function returns nothing.\n\npop():\n\nDynamic storage arrays and bytes (not string) have a member function called pop() that you can use to remove an element from the end of the array. This also implicitly calls delete on the removed element. The function returns nothing.\n\nNote\n\nIncreasing the length of a storage array by calling push() has constant gas costs because storage is zero-initialised, while decreasing the length by calling pop() has a cost that depends on the “size” of the element being removed. If that element is an array, it can be very costly, because it includes explicitly clearing the removed elements similar to calling delete on them.\n\nNote\n\nTo use arrays of arrays in external (instead of public) functions, you need to activate ABI coder v2.\n\nNote\n\nIn EVM versions before Byzantium, it was not possible to access dynamic arrays returned from function calls. If you call functions that return dynamic arrays, make sure to use an EVM that is set to Byzantium mode.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\ncontract ArrayContract {\n    uint[2**20] aLotOfIntegers;\n    // Note that the following is not a pair of dynamic arrays but a\n    // dynamic array of pairs (i.e. of fixed size arrays of length two).\n    // In Solidity, T[k] and T[] are always arrays with elements of type T,\n    // even if T itself is an array.\n    // Because of that, bool[2][] is a dynamic array of elements\n    // that are bool[2]. This is different from other languages, like C.\n    // Data location for all state variables is storage.\n    bool[2][] pairsOfFlags;\n\n    // newPairs is stored in memory - the only possibility\n    // for public contract function arguments\n    function setAllFlagPairs(bool[2][] memory newPairs) public {\n        // assignment to a storage array performs a copy of ``newPairs`` and\n        // replaces the complete array ``pairsOfFlags``.\n        pairsOfFlags = newPairs;\n    }\n\n    struct StructType {\n        uint[] contents;\n        uint moreInfo;\n    }\n    StructType s;\n\n    function f(uint[] memory c) public {\n        // stores a reference to ``s`` in ``g``\n        StructType storage g = s;\n        // also changes ``s.moreInfo``.\n        g.moreInfo = 2;\n        // assigns a copy because ``g.contents``\n        // is not a local variable, but a member of\n        // a local variable.\n        g.contents = c;\n    }\n\n    function setFlagPair(uint index, bool flagA, bool flagB) public {\n        // access to a non-existing index will throw an exception\n        pairsOfFlags[index][0] = flagA;\n        pairsOfFlags[index][1] = flagB;\n    }\n\n    function changeFlagArraySize(uint newSize) public {\n        // using push and pop is the only way to change the\n        // length of an array\n        if (newSize < pairsOfFlags.length) {\n            while (pairsOfFlags.length > newSize)\n                pairsOfFlags.pop();\n        } else if (newSize > pairsOfFlags.length) {\n            while (pairsOfFlags.length < newSize)\n                pairsOfFlags.push();\n        }\n    }\n\n    function clear() public {\n        // these clear the arrays completely\n        delete pairsOfFlags;\n        delete aLotOfIntegers;\n        // identical effect here\n        pairsOfFlags = new bool[2][](0);\n    }\n\n    bytes byteData;\n\n    function byteArrays(bytes memory data) public {\n        // byte arrays (\"bytes\") are different as they are stored without padding,\n        // but can be treated identical to \"uint8[]\"\n        byteData = data;\n        for (uint i = 0; i < 7; i++)\n            byteData.push();\n        byteData[3] = 0x08;\n        delete byteData[2];\n    }\n\n    function addFlag(bool[2] memory flag) public returns (uint) {\n        pairsOfFlags.push(flag);\n        return pairsOfFlags.length;\n    }\n\n    function createMemoryArray(uint size) public pure returns (bytes memory) {\n        // Dynamic memory arrays are created using `new`:\n        uint[2][] memory arrayOfPairs = new uint[2][](size);\n\n        // Inline arrays are always statically-sized and if you only\n        // use literals, you have to provide at least one type.\n        arrayOfPairs[0] = [uint(1), 2];\n\n        // Create a dynamic byte array:\n        bytes memory b = new bytes(200);\n        for (uint i = 0; i < b.length; i++)\n            b[i] = bytes1(uint8(i));\n        return b;\n    }\n}\n\nDangling References to Storage Array Elements\n\nWhen working with storage arrays, you need to take care to avoid dangling references. A dangling reference is a reference that points to something that no longer exists or has been moved without updating the reference. A dangling reference can for example occur, if you store a reference to an array element in a local variable and then .pop() from the containing array:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\ncontract C {\n    uint[][] s;\n\n    function f() public {\n        // Stores a pointer to the last array element of s.\n        uint[] storage ptr = s[s.length - 1];\n        // Removes the last array element of s.\n        s.pop();\n        // Writes to the array element that is no longer within the array.\n        ptr.push(0x42);\n        // Adding a new element to ``s`` now will not add an empty array, but\n        // will result in an array of length 1 with ``0x42`` as element.\n        s.push();\n        assert(s[s.length - 1][0] == 0x42);\n    }\n}\n\n\nThe write in ptr.push(0x42) will not revert, despite the fact that ptr no longer refers to a valid element of s. Since the compiler assumes that unused storage is always zeroed, a subsequent s.push() will not explicitly write zeroes to storage, so the last element of s after that push() will have length 1 and contain 0x42 as its first element.\n\nNote that Solidity does not allow to declare references to value types in storage. These kinds of explicit dangling references are restricted to nested reference types. However, dangling references can also occur temporarily when using complex expressions in tuple assignments:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\ncontract C {\n    uint[] s;\n    uint[] t;\n    constructor() {\n        // Push some initial values to the storage arrays.\n        s.push(0x07);\n        t.push(0x03);\n    }\n\n    function g() internal returns (uint[] storage) {\n        s.pop();\n        return t;\n    }\n\n    function f() public returns (uint[] memory) {\n        // The following will first evaluate ``s.push()`` to a reference to a new element\n        // at index 1. Afterwards, the call to ``g`` pops this new element, resulting in\n        // the left-most tuple element to become a dangling reference. The assignment still\n        // takes place and will write outside the data area of ``s``.\n        (s.push(), g()[0]) = (0x42, 0x17);\n        // A subsequent push to ``s`` will reveal the value written by the previous\n        // statement, i.e. the last element of ``s`` at the end of this function will have\n        // the value ``0x42``.\n        s.push();\n        return s;\n    }\n}\n\n\nIt is always safer to only assign to storage once per statement and to avoid complex expressions on the left-hand-side of an assignment.\n\nYou need to take particular care when dealing with references to elements of bytes arrays, since a .push() on a bytes array may switch from short to long layout in storage.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.0 <0.9.0;\n\n// This will report a warning\ncontract C {\n    bytes x = \"012345678901234567890123456789\";\n\n    function test() external returns(uint) {\n        (x.push(), x.push()) = (0x01, 0x02);\n        return x.length;\n    }\n}\n\n\nHere, when the first x.push() is evaluated, x is still stored in short layout, thereby x.push() returns a reference to an element in the first storage slot of x. However, the second x.push() switches the bytes array to large layout. Now the element that x.push() referred to is in the data area of the array while the reference still points at its original location, which is now a part of the length field and the assignment will effectively garble the length of x. To be safe, only enlarge bytes arrays by at most one element during a single assignment and do not simultaneously index-access the array in the same statement.\n\nWhile the above describes the behavior of dangling storage references in the current version of the compiler, any code with dangling references should be considered to have undefined behavior. In particular, this means that any future version of the compiler may change the behavior of code that involves dangling references.\n\nBe sure to avoid dangling references in your code!\n\nArray Slices\n\nArray slices are a view on a contiguous portion of an array. They are written as x[start:end], where start and end are expressions resulting in a uint256 type (or implicitly convertible to it). The first element of the slice is x[start] and the last element is x[end - 1].\n\nIf start is greater than end or if end is greater than the length of the array, an exception is thrown.\n\nBoth start and end are optional: start defaults to 0 and end defaults to the length of the array.\n\nArray slices do not have any members. They are implicitly convertible to arrays of their underlying type and support index access. Index access is not absolute in the underlying array, but relative to the start of the slice.\n\nArray slices do not have a type name which means no variable can have an array slices as type, they only exist in intermediate expressions.\n\nNote\n\nAs of now, array slices are only implemented for calldata arrays.\n\nArray slices are useful to ABI-decode secondary data passed in function parameters:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.8.5 <0.9.0;\ncontract Proxy {\n    /// @dev Address of the client contract managed by proxy i.e., this contract\n    address client;\n\n    constructor(address client_) {\n        client = client_;\n    }\n\n    /// Forward call to \"setOwner(address)\" that is implemented by client\n    /// after doing basic validation on the address argument.\n    function forward(bytes calldata payload) external {\n        bytes4 sig = bytes4(payload[:4]);\n        // Due to truncating behavior, bytes4(payload) performs identically.\n        // bytes4 sig = bytes4(payload);\n        if (sig == bytes4(keccak256(\"setOwner(address)\"))) {\n            address owner = abi.decode(payload[4:], (address));\n            require(owner != address(0), \"Address of owner cannot be zero.\");\n        }\n        (bool status,) = client.delegatecall(payload);\n        require(status, \"Forwarded call failed.\");\n    }\n}\n\nStructs\n\nSolidity provides a way to define new types in the form of structs, which is shown in the following example:\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.6.0 <0.9.0;\n\n// Defines a new type with two fields.\n// Declaring a struct outside of a contract allows\n// it to be shared by multiple contracts.\n// Here, this is not really needed.\nstruct Funder {\n    address addr;\n    uint amount;\n}\n\ncontract CrowdFunding {\n    // Structs can also be defined inside contracts, which makes them\n    // visible only there and in derived contracts.\n    struct Campaign {\n        address payable beneficiary;\n        uint fundingGoal;\n        uint numFunders;\n        uint amount;\n        mapping(uint => Funder) funders;\n    }\n\n    uint numCampaigns;\n    mapping(uint => Campaign) campaigns;\n\n    function newCampaign(address payable beneficiary, uint goal) public returns (uint campaignID) {\n        campaignID = numCampaigns++; // campaignID is return variable\n        // We cannot use \"campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0)\"\n        // because the right hand side creates a memory-struct \"Campaign\" that contains a mapping.\n        Campaign storage c = campaigns[campaignID];\n        c.beneficiary = beneficiary;\n        c.fundingGoal = goal;\n    }\n\n    function contribute(uint campaignID) public payable {\n        Campaign storage c = campaigns[campaignID];\n        // Creates a new temporary memory struct, initialised with the given values\n        // and copies it over to storage.\n        // Note that you can also use Funder(msg.sender, msg.value) to initialise.\n        c.funders[c.numFunders++] = Funder({addr: msg.sender, amount: msg.value});\n        c.amount += msg.value;\n    }\n\n    function checkGoalReached(uint campaignID) public returns (bool reached) {\n        Campaign storage c = campaigns[campaignID];\n        if (c.amount < c.fundingGoal)\n            return false;\n        uint amount = c.amount;\n        c.amount = 0;\n        c.beneficiary.transfer(amount);\n        return true;\n    }\n}\n\n\nThe contract does not provide the full functionality of a crowdfunding contract, but it contains the basic concepts necessary to understand structs. Struct types can be used inside mappings and arrays and they can themselves contain mappings and arrays.\n\nIt is not possible for a struct to contain a member of its own type, although the struct itself can be the value type of a mapping member or it can contain a dynamically-sized array of its type. This restriction is necessary, as the size of the struct has to be finite.\n\nNote how in all the functions, a struct type is assigned to a local variable with data location storage. This does not copy the struct but only stores a reference so that assignments to members of the local variable actually write to the state.\n\nOf course, you can also directly access the members of the struct without assigning it to a local variable, as in campaigns[campaignID].amount = 0.\n\nNote\n\nUntil Solidity 0.7.0, memory-structs containing members of storage-only types (e.g. mappings) were allowed and assignments like campaigns[campaignID] = Campaign(beneficiary, goal, 0, 0) in the example above would work and just silently skip those members.\n\nMapping Types\n\nMapping types use the syntax mapping(KeyType KeyName? => ValueType ValueName?) and variables of mapping type are declared using the syntax mapping(KeyType KeyName? => ValueType ValueName?) VariableName. The KeyType can be any built-in value type, bytes, string, or any contract or enum type. Other user-defined or complex types, such as mappings, structs or array types are not allowed. ValueType can be any type, including mappings, arrays and structs. KeyName and ValueName are optional (so mapping(KeyType => ValueType) works as well) and can be any valid identifier that is not a type.\n\nYou can think of mappings as hash tables, which are virtually initialised such that every possible key exists and is mapped to a value whose byte-representation is all zeros, a type’s default value. The similarity ends there, the key data is not stored in a mapping, only its keccak256 hash is used to look up the value.\n\nBecause of this, mappings do not have a length or a concept of a key or value being set, and therefore cannot be erased without extra information regarding the assigned keys (see Clearing Mappings).\n\nMappings can only have a data location of storage and thus are allowed for state variables, as storage reference types in functions, or as parameters for library functions. They cannot be used as parameters or return parameters of contract functions that are publicly visible. These restrictions are also true for arrays and structs that contain mappings.\n\nYou can mark state variables of mapping type as public and Solidity creates a getter for you. The KeyType becomes a parameter with name KeyName (if specified) for the getter. If ValueType is a value type or a struct, the getter returns ValueType with name ValueName (if specified). If ValueType is an array or a mapping, the getter has one parameter for each KeyType, recursively.\n\nIn the example below, the MappingExample contract defines a public balances mapping, with the key type an address, and a value type a uint, mapping an Ethereum address to an unsigned integer value. As uint is a value type, the getter returns a value that matches the type, which you can see in the MappingUser contract that returns the value at the specified address.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract MappingExample {\n    mapping(address => uint) public balances;\n\n    function update(uint newBalance) public {\n        balances[msg.sender] = newBalance;\n    }\n}\n\ncontract MappingUser {\n    function f() public returns (uint) {\n        MappingExample m = new MappingExample();\n        m.update(100);\n        return m.balances(address(this));\n    }\n}\n\n\nThe example below is a simplified version of an ERC20 token. _allowances is an example of a mapping type inside another mapping type.\n\nIn the example below, the optional KeyName and ValueName are provided for the mapping. It does not affect any contract functionality or bytecode, it only sets the name field for the inputs and outputs in the ABI for the mapping’s getter.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.18;\n\ncontract MappingExampleWithNames {\n    mapping(address user => uint balance) public balances;\n\n    function update(uint newBalance) public {\n        balances[msg.sender] = newBalance;\n    }\n}\n\n\nThe example below uses _allowances to record the amount someone else is allowed to withdraw from your account.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\ncontract MappingExample {\n\n    mapping(address => uint256) private _balances;\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    event Transfer(address indexed from, address indexed to, uint256 value);\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    function allowance(address owner, address spender) public view returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function transferFrom(address sender, address recipient, uint256 amount) public returns (bool) {\n        require(_allowances[sender][msg.sender] >= amount, \"ERC20: Allowance not high enough.\");\n        _allowances[sender][msg.sender] -= amount;\n        _transfer(sender, recipient, amount);\n        return true;\n    }\n\n    function approve(address spender, uint256 amount) public returns (bool) {\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[msg.sender][spender] = amount;\n        emit Approval(msg.sender, spender, amount);\n        return true;\n    }\n\n    function _transfer(address sender, address recipient, uint256 amount) internal {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n        require(_balances[sender] >= amount, \"ERC20: Not enough funds.\");\n\n        _balances[sender] -= amount;\n        _balances[recipient] += amount;\n        emit Transfer(sender, recipient, amount);\n    }\n}\n\nIterable Mappings\n\nYou cannot iterate over mappings, i.e. you cannot enumerate their keys. It is possible, though, to implement a data structure on top of them and iterate over that. For example, the code below implements an IterableMapping library that the User contract then adds data to, and the sum function iterates over to sum all the values.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.8;\n\nstruct IndexValue { uint keyIndex; uint value; }\nstruct KeyFlag { uint key; bool deleted; }\n\nstruct itmap {\n    mapping(uint => IndexValue) data;\n    KeyFlag[] keys;\n    uint size;\n}\n\ntype Iterator is uint;\n\nlibrary IterableMapping {\n    function insert(itmap storage self, uint key, uint value) internal returns (bool replaced) {\n        uint keyIndex = self.data[key].keyIndex;\n        self.data[key].value = value;\n        if (keyIndex > 0)\n            return true;\n        else {\n            keyIndex = self.keys.length;\n            self.keys.push();\n            self.data[key].keyIndex = keyIndex + 1;\n            self.keys[keyIndex].key = key;\n            self.size++;\n            return false;\n        }\n    }\n\n    function remove(itmap storage self, uint key) internal returns (bool success) {\n        uint keyIndex = self.data[key].keyIndex;\n        if (keyIndex == 0)\n            return false;\n        delete self.data[key];\n        self.keys[keyIndex - 1].deleted = true;\n        self.size --;\n    }\n\n    function contains(itmap storage self, uint key) internal view returns (bool) {\n        return self.data[key].keyIndex > 0;\n    }\n\n    function iterateStart(itmap storage self) internal view returns (Iterator) {\n        return iteratorSkipDeleted(self, 0);\n    }\n\n    function iterateValid(itmap storage self, Iterator iterator) internal view returns (bool) {\n        return Iterator.unwrap(iterator) < self.keys.length;\n    }\n\n    function iterateNext(itmap storage self, Iterator iterator) internal view returns (Iterator) {\n        return iteratorSkipDeleted(self, Iterator.unwrap(iterator) + 1);\n    }\n\n    function iterateGet(itmap storage self, Iterator iterator) internal view returns (uint key, uint value) {\n        uint keyIndex = Iterator.unwrap(iterator);\n        key = self.keys[keyIndex].key;\n        value = self.data[key].value;\n    }\n\n    function iteratorSkipDeleted(itmap storage self, uint keyIndex) private view returns (Iterator) {\n        while (keyIndex < self.keys.length && self.keys[keyIndex].deleted)\n            keyIndex++;\n        return Iterator.wrap(keyIndex);\n    }\n}\n\n// How to use it\ncontract User {\n    // Just a struct holding our data.\n    itmap data;\n    // Apply library functions to the data type.\n    using IterableMapping for itmap;\n\n    // Insert something\n    function insert(uint k, uint v) public returns (uint size) {\n        // This calls IterableMapping.insert(data, k, v)\n        data.insert(k, v);\n        // We can still access members of the struct,\n        // but we should take care not to mess with them.\n        return data.size;\n    }\n\n    // Computes the sum of all stored data.\n    function sum() public view returns (uint s) {\n        for (\n            Iterator i = data.iterateStart();\n            data.iterateValid(i);\n            i = data.iterateNext(i)\n        ) {\n            (, uint value) = data.iterateGet(i);\n            s += value;\n        }\n    }\n}\n\nOperators\n\nArithmetic and bit operators can be applied even if the two operands do not have the same type. For example, you can compute y = x + z, where x is a uint8 and z has the type uint32. In these cases, the following mechanism will be used to determine the type in which the operation is computed (this is important in case of overflow) and the type of the operator’s result:\n\nIf the type of the right operand can be implicitly converted to the type of the left operand, use the type of the left operand,\n\nif the type of the left operand can be implicitly converted to the type of the right operand, use the type of the right operand,\n\notherwise, the operation is not allowed.\n\nIn case one of the operands is a literal number it is first converted to its “mobile type”, which is the smallest type that can hold the value (unsigned types of the same bit-width are considered “smaller” than the signed types). If both are literal numbers, the operation is computed with effectively unlimited precision in that the expression is evaluated to whatever precision is necessary so that none is lost when the result is used with a non-literal type.\n\nThe operator’s result type is the same as the type the operation is performed in, except for comparison operators where the result is always bool.\n\nThe operators ** (exponentiation), << and >> use the type of the left operand for the operation and the result.\n\nTernary Operator\n\nThe ternary operator is used in expressions of the form <expression> ? <trueExpression> : <falseExpression>. It evaluates one of the latter two given expressions depending upon the result of the evaluation of the main <expression>. If <expression> evaluates to true, then <trueExpression> will be evaluated, otherwise <falseExpression> is evaluated.\n\nThe result of the ternary operator does not have a rational number type, even if all of its operands are rational number literals. The result type is determined from the types of the two operands in the same way as above, converting to their mobile type first if required.\n\nAs a consequence, 255 + (true ? 1 : 0) will revert due to arithmetic overflow. The reason is that (true ? 1 : 0) is of uint8 type, which forces the addition to be performed in uint8 as well, and 256 exceeds the range allowed for this type.\n\nAnother consequence is that an expression like 1.5 + 1.5 is valid but 1.5 + (true ? 1.5 : 2.5) is not. This is because the former is a rational expression evaluated in unlimited precision and only its final value matters. The latter involves a conversion of a fractional rational number to an integer, which is currently disallowed.\n\nCompound and Increment/Decrement Operators\n\nIf a is an LValue (i.e. a variable or something that can be assigned to), the following operators are available as shorthands:\n\na += e is equivalent to a = a + e. The operators -=, *=, /=, %=, |=, &=, ^=, <<= and >>= are defined accordingly. a++ and a-- are equivalent to a += 1 / a -= 1 but the expression itself still has the previous value of a. In contrast, --a and ++a have the same effect on a but return the value after the change.\n\ndelete\n\ndelete a assigns the initial value for the type to a. I.e. for integers it is equivalent to a = 0, but it can also be used on arrays, where it assigns a dynamic array of length zero or a static array of the same length with all elements set to their initial value. delete a[x] deletes the item at index x of the array and leaves all other elements and the length of the array untouched. This especially means that it leaves a gap in the array. If you plan to remove items, a mapping is probably a better choice.\n\nFor structs, it assigns a struct with all members reset. In other words, the value of a after delete a is the same as if a would be declared without assignment, with the following caveat:\n\ndelete has no effect on mappings (as the keys of mappings may be arbitrary and are generally unknown). So if you delete a struct, it will reset all members that are not mappings and also recurse into the members unless they are mappings. However, individual keys and what they map to can be deleted: If a is a mapping, then delete a[x] will delete the value stored at x.\n\nIt is important to note that delete a really behaves like an assignment to a, i.e. it stores a new object in a. This distinction is visible when a is reference variable: It will only reset a itself, not the value it referred to previously.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract DeleteExample {\n    uint data;\n    uint[] dataArray;\n\n    function f() public {\n        uint x = data;\n        delete x; // sets x to 0, does not affect data\n        delete data; // sets data to 0, does not affect x\n        uint[] storage y = dataArray;\n        delete dataArray; // this sets dataArray.length to zero, but as uint[] is a complex object, also\n        // y is affected which is an alias to the storage object\n        // On the other hand: \"delete y\" is not valid, as assignments to local variables\n        // referencing storage objects can only be made from existing storage objects.\n        assert(y.length == 0);\n    }\n}\n\nOrder of Precedence of Operators\n\nThe following is the order of precedence for operators, listed in order of evaluation.\n\nPrecedence\n\n\t\n\nDescription\n\n\t\n\nOperator\n\n\n\n\n1\n\n\t\n\nPostfix increment and decrement\n\n\t\n\n++, --\n\n\n\n\nNew expression\n\n\t\n\nnew <typename>\n\n\n\n\nArray subscripting\n\n\t\n\n<array>[<index>]\n\n\n\n\nMember access\n\n\t\n\n<object>.<member>\n\n\n\n\nFunction-like call\n\n\t\n\n<func>(<args...>)\n\n\n\n\nParentheses\n\n\t\n\n(<statement>)\n\n\n\n\n2\n\n\t\n\nPrefix increment and decrement\n\n\t\n\n++, --\n\n\n\n\nUnary minus\n\n\t\n\n-\n\n\n\n\nUnary operations\n\n\t\n\ndelete\n\n\n\n\nLogical NOT\n\n\t\n\n!\n\n\n\n\nBitwise NOT\n\n\t\n\n~\n\n\n\n\n3\n\n\t\n\nExponentiation\n\n\t\n\n**\n\n\n\n\n4\n\n\t\n\nMultiplication, division and modulo\n\n\t\n\n*, /, %\n\n\n\n\n5\n\n\t\n\nAddition and subtraction\n\n\t\n\n+, -\n\n\n\n\n6\n\n\t\n\nBitwise shift operators\n\n\t\n\n<<, >>\n\n\n\n\n7\n\n\t\n\nBitwise AND\n\n\t\n\n&\n\n\n\n\n8\n\n\t\n\nBitwise XOR\n\n\t\n\n^\n\n\n\n\n9\n\n\t\n\nBitwise OR\n\n\t\n\n|\n\n\n\n\n10\n\n\t\n\nInequality operators\n\n\t\n\n<, >, <=, >=\n\n\n\n\n11\n\n\t\n\nEquality operators\n\n\t\n\n==, !=\n\n\n\n\n12\n\n\t\n\nLogical AND\n\n\t\n\n&&\n\n\n\n\n13\n\n\t\n\nLogical OR\n\n\t\n\n||\n\n\n\n\n14\n\n\t\n\nTernary operator\n\n\t\n\n<conditional> ? <if-true> : <if-false>\n\n\n\n\nAssignment operators\n\n\t\n\n=, |=, ^=, &=, <<=, >>=, +=, -=, *=, /=, %=\n\n\n\n\n15\n\n\t\n\nComma operator\n\n\t\n\n,\n\nConversions between Elementary Types\nImplicit Conversions\n\nAn implicit type conversion is automatically applied by the compiler in some cases during assignments, when passing arguments to functions and when applying operators. In general, an implicit conversion between value-types is possible if it makes sense semantically and no information is lost.\n\nFor example, uint8 is convertible to uint16 and int128 to int256, but int8 is not convertible to uint256, because uint256 cannot hold values such as -1.\n\nIf an operator is applied to different types, the compiler tries to implicitly convert one of the operands to the type of the other (the same is true for assignments). This means that operations are always performed in the type of one of the operands.\n\nFor more details about which implicit conversions are possible, please consult the sections about the types themselves.\n\nIn the example below, y and z, the operands of the addition, do not have the same type, but uint8 can be implicitly converted to uint16 and not vice-versa. Because of that, y is converted to the type of z before the addition is performed in the uint16 type. The resulting type of the expression y + z is uint16. Because it is assigned to a variable of type uint32 another implicit conversion is performed after the addition.\n\nopen in Remix\n\nuint8 y;\nuint16 z;\nuint32 x = y + z;\n\nExplicit Conversions\n\nIf the compiler does not allow implicit conversion but you are confident a conversion will work, an explicit type conversion is sometimes possible. This may result in unexpected behavior and allows you to bypass some security features of the compiler, so be sure to test that the result is what you want and expect!\n\nTake the following example that converts a negative int to a uint:\n\nopen in Remix\n\nint  y = -3;\nuint x = uint(y);\n\n\nAt the end of this code snippet, x will have the value 0xfffff..fd (64 hex characters), which is -3 in the two’s complement representation of 256 bits.\n\nIf an integer is explicitly converted to a smaller type, higher-order bits are cut off:\n\nopen in Remix\n\nuint32 a = 0x12345678;\nuint16 b = uint16(a); // b will be 0x5678 now\n\n\nIf an integer is explicitly converted to a larger type, it is padded on the left (i.e., at the higher order end). The result of the conversion will compare equal to the original integer:\n\nopen in Remix\n\nuint16 a = 0x1234;\nuint32 b = uint32(a); // b will be 0x00001234 now\nassert(a == b);\n\n\nFixed-size bytes types behave differently during conversions. They can be thought of as sequences of individual bytes and converting to a smaller type will cut off the sequence:\n\nopen in Remix\n\nbytes2 a = 0x1234;\nbytes1 b = bytes1(a); // b will be 0x12\n\n\nIf a fixed-size bytes type is explicitly converted to a larger type, it is padded on the right. Accessing the byte at a fixed index will result in the same value before and after the conversion (if the index is still in range):\n\nopen in Remix\n\nbytes2 a = 0x1234;\nbytes4 b = bytes4(a); // b will be 0x12340000\nassert(a[0] == b[0]);\nassert(a[1] == b[1]);\n\n\nSince integers and fixed-size byte arrays behave differently when truncating or padding, explicit conversions between integers and fixed-size byte arrays are only allowed, if both have the same size. If you want to convert between integers and fixed-size byte arrays of different size, you have to use intermediate conversions that make the desired truncation and padding rules explicit:\n\nopen in Remix\n\nbytes2 a = 0x1234;\nuint32 b = uint16(a); // b will be 0x00001234\nuint32 c = uint32(bytes4(a)); // c will be 0x12340000\nuint8 d = uint8(uint16(a)); // d will be 0x34\nuint8 e = uint8(bytes1(a)); // e will be 0x12\n\n\nbytes arrays and bytes calldata slices can be converted explicitly to fixed bytes types (bytes1/…/bytes32). In case the array is longer than the target fixed bytes type, truncation at the end will happen. If the array is shorter than the target type, it will be padded with zeros at the end.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.5;\n\ncontract C {\n    bytes s = \"abcdefgh\";\n    function f(bytes calldata c, bytes memory m) public view returns (bytes16, bytes3) {\n        require(c.length == 16, \"\");\n        bytes16 b = bytes16(m);  // if length of m is greater than 16, truncation will happen\n        b = bytes16(s);  // padded on the right, so result is \"abcdefgh\\0\\0\\0\\0\\0\\0\\0\\0\"\n        bytes3 b1 = bytes3(s); // truncated, b1 equals to \"abc\"\n        b = bytes16(c[:8]);  // also padded with zeros\n        return (b, b1);\n    }\n}\n\nConversions between Literals and Elementary Types\nInteger Types\n\nDecimal and hexadecimal number literals can be implicitly converted to any integer type that is large enough to represent it without truncation:\n\nopen in Remix\n\nuint8 a = 12; // fine\nuint32 b = 1234; // fine\nuint16 c = 0x123456; // fails, since it would have to truncate to 0x3456\n\n\nNote\n\nPrior to version 0.8.0, any decimal or hexadecimal number literals could be explicitly converted to an integer type. From 0.8.0, such explicit conversions are as strict as implicit conversions, i.e., they are only allowed if the literal fits in the resulting range.\n\nFixed-Size Byte Arrays\n\nDecimal number literals cannot be implicitly converted to fixed-size byte arrays. Hexadecimal number literals can be, but only if the number of hex digits exactly fits the size of the bytes type. As an exception both decimal and hexadecimal literals which have a value of zero can be converted to any fixed-size bytes type:\n\nopen in Remix\n\nbytes2 a = 54321; // not allowed\nbytes2 b = 0x12; // not allowed\nbytes2 c = 0x123; // not allowed\nbytes2 d = 0x1234; // fine\nbytes2 e = 0x0012; // fine\nbytes4 f = 0; // fine\nbytes4 g = 0x0; // fine\n\n\nString literals and hex string literals can be implicitly converted to fixed-size byte arrays, if their number of characters matches the size of the bytes type:\n\nopen in Remix\n\nbytes2 a = hex\"1234\"; // fine\nbytes2 b = \"xy\"; // fine\nbytes2 c = hex\"12\"; // not allowed\nbytes2 d = hex\"123\"; // not allowed\nbytes2 e = \"x\"; // not allowed\nbytes2 f = \"xyz\"; // not allowed\n\nAddresses\n\nAs described in Address Literals, hex literals of the correct size that pass the checksum test are of address type. No other literals can be implicitly converted to the address type.\n\nExplicit conversions to address are allowed only from bytes20 and uint160.\n\nAn address a can be converted explicitly to address payable via payable(a).\n\nNote\n\nPrior to version 0.8.0, it was possible to explicitly convert from any integer type (of any size, signed or unsigned) to address or address payable. Starting with in 0.8.0 only conversion from uint160 is allowed.\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Structure of a Contract — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/structure-of-a-contract.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nState Variables\nFunctions\nFunction Modifiers\nEvents\nErrors\nStruct Types\nEnum Types\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Structure of a Contract\n Edit on GitHub\nStructure of a Contract\n\nContracts in Solidity are similar to classes in object-oriented languages. Each contract can contain declarations of State Variables, Functions, Function Modifiers, Events, Errors, Struct Types and Enum Types. Furthermore, contracts can inherit from other contracts.\n\nThere are also special kinds of contracts called libraries and interfaces.\n\nThe section about contracts contains more details than this section, which serves to provide a quick overview.\n\nState Variables\n\nState variables are variables whose values are permanently stored in contract storage.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract SimpleStorage {\n    uint storedData; // State variable\n    // ...\n}\n\n\nSee the Types section for valid state variable types and Visibility and Getters for possible choices for visibility.\n\nFunctions\n\nFunctions are the executable units of code. Functions are usually defined inside a contract, but they can also be defined outside of contracts.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.1 <0.9.0;\n\ncontract SimpleAuction {\n    function bid() public payable { // Function\n        // ...\n    }\n}\n\n// Helper function defined outside of a contract\nfunction helper(uint x) pure returns (uint) {\n    return x * 2;\n}\n\n\nFunction Calls can happen internally or externally and have different levels of visibility towards other contracts. Functions accept parameters and return variables to pass parameters and values between them.\n\nFunction Modifiers\n\nFunction modifiers can be used to amend the semantics of functions in a declarative way (see Function Modifiers in the contracts section).\n\nOverloading, that is, having the same modifier name with different parameters, is not possible.\n\nLike functions, modifiers can be overridden.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.22 <0.9.0;\n\ncontract Purchase {\n    address public seller;\n\n    modifier onlySeller() { // Modifier\n        require(\n            msg.sender == seller,\n            \"Only seller can call this.\"\n        );\n        _;\n    }\n\n    function abort() public view onlySeller { // Modifier usage\n        // ...\n    }\n}\n\nEvents\n\nEvents are convenience interfaces with the EVM logging facilities.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.22;\n\nevent HighestBidIncreased(address bidder, uint amount); // Event\n\ncontract SimpleAuction {\n    function bid() public payable {\n        // ...\n        emit HighestBidIncreased(msg.sender, msg.value); // Triggering event\n    }\n}\n\n\nSee Events in contracts section for information on how events are declared and can be used from within a dapp.\n\nErrors\n\nErrors allow you to define descriptive names and data for failure situations. Errors can be used in revert statements. In comparison to string descriptions, errors are much cheaper and allow you to encode additional data. You can use NatSpec to describe the error to the user.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\n/// Not enough funds for transfer. Requested `requested`,\n/// but only `available` available.\nerror NotEnoughFunds(uint requested, uint available);\n\ncontract Token {\n    mapping(address => uint) balances;\n    function transfer(address to, uint amount) public {\n        uint balance = balances[msg.sender];\n        if (balance < amount)\n            revert NotEnoughFunds(amount, balance);\n        balances[msg.sender] -= amount;\n        balances[to] += amount;\n        // ...\n    }\n}\n\n\nSee Errors and the Revert Statement in the contracts section for more information.\n\nStruct Types\n\nStructs are custom defined types that can group several variables (see Structs in types section).\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract Ballot {\n    struct Voter { // Struct\n        uint weight;\n        bool voted;\n        address delegate;\n        uint vote;\n    }\n}\n\nEnum Types\n\nEnums can be used to create custom types with a finite set of ‘constant values’ (see Enums in types section).\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.0 <0.9.0;\n\ncontract Purchase {\n    enum State { Created, Locked, Inactive } // Enum\n}\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Layout of a Solidity Source File — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/layout-of-source-files.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nSPDX License Identifier\nPragmas\nImporting other Source Files\nComments\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Layout of a Solidity Source File\n Edit on GitHub\nLayout of a Solidity Source File\n\nSource files can contain an arbitrary number of contract definitions, import , pragma and using for directives and struct, enum, function, error and constant variable definitions.\n\nSPDX License Identifier\n\nTrust in smart contracts can be better established if their source code is available. Since making source code available always touches on legal problems with regards to copyright, the Solidity compiler encourages the use of machine-readable SPDX license identifiers. Every source file should start with a comment indicating its license:\n\n// SPDX-License-Identifier: MIT\n\nThe compiler does not validate that the license is part of the list allowed by SPDX, but it does include the supplied string in the bytecode metadata.\n\nIf you do not want to specify a license or if the source code is not open-source, please use the special value UNLICENSED. Note that UNLICENSED (no usage allowed, not present in SPDX license list) is different from UNLICENSE (grants all rights to everyone). Solidity follows the npm recommendation.\n\nSupplying this comment of course does not free you from other obligations related to licensing like having to mention a specific license header in each source file or the original copyright holder.\n\nThe comment is recognized by the compiler anywhere in the file at the file level, but it is recommended to put it at the top of the file.\n\nMore information about how to use SPDX license identifiers can be found at the SPDX website.\n\nPragmas\n\nThe pragma keyword is used to enable certain compiler features or checks. A pragma directive is always local to a source file, so you have to add the pragma to all your files if you want to enable it in your whole project. If you import another file, the pragma from that file does not automatically apply to the importing file.\n\nVersion Pragma\n\nSource files can (and should) be annotated with a version pragma to reject compilation with future compiler versions that might introduce incompatible changes. We try to keep these to an absolute minimum and introduce them in a way that changes in semantics also require changes in the syntax, but this is not always possible. Because of this, it is always a good idea to read through the changelog at least for releases that contain breaking changes. These releases always have versions of the form 0.x.0 or x.0.0.\n\nThe version pragma is used as follows: pragma solidity ^0.5.2;\n\nA source file with the line above does not compile with a compiler earlier than version 0.5.2, and it also does not work on a compiler starting from version 0.6.0 (this second condition is added by using ^). Because there will be no breaking changes until version 0.6.0, you can be sure that your code compiles the way you intended. The exact version of the compiler is not fixed, so that bugfix releases are still possible.\n\nIt is possible to specify more complex rules for the compiler version, these follow the same syntax used by npm.\n\nNote\n\nUsing the version pragma does not change the version of the compiler. It also does not enable or disable features of the compiler. It just instructs the compiler to check whether its version matches the one required by the pragma. If it does not match, the compiler issues an error.\n\nABI Coder Pragma\n\nBy using pragma abicoder v1 or pragma abicoder v2 you can select between the two implementations of the ABI encoder and decoder.\n\nThe new ABI coder (v2) is able to encode and decode arbitrarily nested arrays and structs. Apart from supporting more types, it involves more extensive validation and safety checks, which may result in higher gas costs, but also heightened security. It is considered non-experimental as of Solidity 0.6.0 and it is enabled by default starting with Solidity 0.8.0. The old ABI coder can still be selected using pragma abicoder v1;.\n\nThe set of types supported by the new encoder is a strict superset of the ones supported by the old one. Contracts that use it can interact with ones that do not without limitations. The reverse is possible only as long as the non-abicoder v2 contract does not try to make calls that would require decoding types only supported by the new encoder. The compiler can detect this and will issue an error. Simply enabling abicoder v2 for your contract is enough to make the error go away.\n\nNote\n\nThis pragma applies to all the code defined in the file where it is activated, regardless of where that code ends up eventually. This means that a contract whose source file is selected to compile with ABI coder v1 can still contain code that uses the new encoder by inheriting it from another contract. This is allowed if the new types are only used internally and not in external function signatures.\n\nNote\n\nUp to Solidity 0.7.4, it was possible to select the ABI coder v2 by using pragma experimental ABIEncoderV2, but it was not possible to explicitly select coder v1 because it was the default.\n\nExperimental Pragma\n\nThe second pragma is the experimental pragma. It can be used to enable features of the compiler or language that are not yet enabled by default. The following experimental pragmas are currently supported:\n\nABIEncoderV2\n\nBecause the ABI coder v2 is not considered experimental anymore, it can be selected via pragma abicoder v2 (please see above) since Solidity 0.7.4.\n\nSMTChecker\n\nThis component has to be enabled when the Solidity compiler is built and therefore it is not available in all Solidity binaries. The build instructions explain how to activate this option. It is activated for the Ubuntu PPA releases in most versions, but not for the Docker images, Windows binaries or the statically-built Linux binaries. It can be activated for solc-js via the smtCallback if you have an SMT solver installed locally and run solc-js via node (not via the browser).\n\nIf you use pragma experimental SMTChecker;, then you get additional safety warnings which are obtained by querying an SMT solver. The component does not yet support all features of the Solidity language and likely outputs many warnings. In case it reports unsupported features, the analysis may not be fully sound.\n\nImporting other Source Files\nSyntax and Semantics\n\nSolidity supports import statements to help modularise your code that are similar to those available in JavaScript (from ES6 on). However, Solidity does not support the concept of a default export.\n\nAt a global level, you can use import statements of the following form:\n\nopen in Remix\n\nimport \"filename\";\n\n\nThe filename part is called an import path. This statement imports all global symbols from “filename” (and symbols imported there) into the current global scope (different than in ES6 but backwards-compatible for Solidity). This form is not recommended for use, because it unpredictably pollutes the namespace. If you add new top-level items inside “filename”, they automatically appear in all files that import like this from “filename”. It is better to import specific symbols explicitly.\n\nThe following example creates a new global symbol symbolName whose members are all the global symbols from \"filename\":\n\nopen in Remix\n\nimport * as symbolName from \"filename\";\n\n\nwhich results in all global symbols being available in the format symbolName.symbol.\n\nA variant of this syntax that is not part of ES6, but possibly useful is:\n\nopen in Remix\n\nimport \"filename\" as symbolName;\n\n\nwhich is equivalent to import * as symbolName from \"filename\";.\n\nIf there is a naming collision, you can rename symbols while importing. For example, the code below creates new global symbols alias and symbol2 which reference symbol1 and symbol2 from inside \"filename\", respectively.\n\nopen in Remix\n\nimport {symbol1 as alias, symbol2} from \"filename\";\n\nImport Paths\n\nIn order to be able to support reproducible builds on all platforms, the Solidity compiler has to abstract away the details of the filesystem where source files are stored. For this reason import paths do not refer directly to files in the host filesystem. Instead the compiler maintains an internal database (virtual filesystem or VFS for short) where each source unit is assigned a unique source unit name which is an opaque and unstructured identifier. The import path specified in an import statement is translated into a source unit name and used to find the corresponding source unit in this database.\n\nUsing the Standard JSON API it is possible to directly provide the names and content of all the source files as a part of the compiler input. In this case source unit names are truly arbitrary. If, however, you want the compiler to automatically find and load source code into the VFS, your source unit names need to be structured in a way that makes it possible for an import callback to locate them. When using the command-line compiler the default import callback supports only loading source code from the host filesystem, which means that your source unit names must be paths. Some environments provide custom callbacks that are more versatile. For example the Remix IDE provides one that lets you import files from HTTP, IPFS and Swarm URLs or refer directly to packages in NPM registry.\n\nFor a complete description of the virtual filesystem and the path resolution logic used by the compiler see Path Resolution.\n\nComments\n\nSingle-line comments (//) and multi-line comments (/*...*/) are possible.\n\nopen in Remix\n\n// This is a single-line comment.\n\n/*\nThis is a\nmulti-line comment.\n*/\n\n\nNote\n\nA single-line comment is terminated by any unicode line terminator (LF, VF, FF, CR, NEL, LS or PS) in UTF-8 encoding. The terminator is still part of the source code after the comment, so if it is not an ASCII symbol (these are NEL, LS and PS), it will lead to a parser error.\n\nAdditionally, there is another type of comment called a NatSpec comment, which is detailed in the style guide. They are written with a triple slash (///) or a double asterisk block (/** ... */) and they should be used directly above function declarations or statements.\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Installing the Solidity Compiler — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/installing-solidity.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\nVersioning\nRemix\nnpm / Node.js\nDocker\nLinux Packages\nmacOS Packages\nStatic Binaries\nBuilding from Source\nCMake Options\nThe Version String in Detail\nImportant Information About Versioning\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Installing the Solidity Compiler\n Edit on GitHub\nInstalling the Solidity Compiler\nVersioning\n\nSolidity versions follow Semantic Versioning. In addition, patch-level releases with major release 0 (i.e. 0.x.y) will not contain breaking changes. That means code that compiles with version 0.x.y can be expected to compile with 0.x.z where z > y.\n\nIn addition to releases, we provide nightly development builds to make it easy for developers to try out upcoming features and provide early feedback. Note, however, that while the nightly builds are usually very stable, they contain bleeding-edge code from the development branch and are not guaranteed to be always working. Despite our best efforts, they might contain undocumented and/or broken changes that will not become a part of an actual release. They are not meant for production use.\n\nWhen deploying contracts, you should use the latest released version of Solidity. This is because breaking changes, as well as new features and bug fixes are introduced regularly. We currently use a 0.x version number to indicate this fast pace of change.\n\nRemix\n\nWe recommend Remix for small contracts and for quickly learning Solidity.\n\nAccess Remix online, you do not need to install anything. If you want to use it without connection to the Internet, go to https://github.com/ethereum/remix-live/tree/gh-pages#readme and follow the instructions on that page. Remix is also a convenient option for testing nightly builds without installing multiple Solidity versions.\n\nFurther options on this page detail installing command-line Solidity compiler software on your computer. Choose a command-line compiler if you are working on a larger contract or if you require more compilation options.\n\nnpm / Node.js\n\nUse npm for a convenient and portable way to install solcjs, a Solidity compiler. The solcjs program has fewer features than the ways to access the compiler described further down this page. The Using the Commandline Compiler documentation assumes you are using the full-featured compiler, solc. The usage of solcjs is documented inside its own repository.\n\nNote: The solc-js project is derived from the C++ solc by using Emscripten, which means that both use the same compiler source code. solc-js can be used in JavaScript projects directly (such as Remix). Please refer to the solc-js repository for instructions.\n\nnpm install -g solc\n\n\nNote\n\nThe command-line executable is named solcjs.\n\nThe command-line options of solcjs are not compatible with solc and tools (such as geth) expecting the behavior of solc will not work with solcjs.\n\nDocker\n\nDocker images of Solidity builds are available using the solc image from the ethereum organization. Use the stable tag for the latest released version, and nightly for potentially unstable changes in the develop branch.\n\nThe Docker image runs the compiler executable so that you can pass all compiler arguments to it. For example, the command below pulls the stable version of the solc image (if you do not have it already), and runs it in a new container, passing the --help argument.\n\ndocker run ethereum/solc:stable --help\n\n\nFor example, You can specify release build versions in the tag for the 0.5.4 release.\n\ndocker run ethereum/solc:0.5.4 --help\n\n\nTo use the Docker image to compile Solidity files on the host machine, mount a local folder for input and output, and specify the contract to compile. For example.\n\ndocker run -v /local/path:/sources ethereum/solc:stable -o /sources/output --abi --bin /sources/Contract.sol\n\n\nYou can also use the standard JSON interface (which is recommended when using the compiler with tooling). When using this interface, it is not necessary to mount any directories as long as the JSON input is self-contained (i.e. it does not refer to any external files that would have to be loaded by the import callback).\n\ndocker run ethereum/solc:stable --standard-json < input.json > output.json\n\nLinux Packages\n\nBinary packages of Solidity are available at solidity/releases.\n\nWe also have PPAs for Ubuntu, you can get the latest stable version using the following commands:\n\nsudo add-apt-repository ppa:ethereum/ethereum\nsudo apt-get update\nsudo apt-get install solc\n\n\nThe nightly version can be installed using these commands:\n\nsudo add-apt-repository ppa:ethereum/ethereum\nsudo add-apt-repository ppa:ethereum/ethereum-dev\nsudo apt-get update\nsudo apt-get install solc\n\n\nFurthermore, some Linux distributions provide their own packages. These packages are not directly maintained by us but usually kept up-to-date by the respective package maintainers.\n\nFor example, Arch Linux has packages for the latest development version as AUR packages: solidity and solidity-bin.\n\nNote\n\nPlease be aware that AUR packages are user-produced content and unofficial packages. Exercise caution when using them.\n\nThere is also a snap package, however, it is currently unmaintained. It is installable in all the supported Linux distros. To install the latest stable version of solc:\n\nsudo snap install solc\n\n\nIf you want to help testing the latest development version of Solidity with the most recent changes, please use the following:\n\nsudo snap install solc --edge\n\n\nNote\n\nThe solc snap uses strict confinement. This is the most secure mode for snap packages but it comes with limitations, like accessing only the files in your /home and /media directories. For more information, go to Demystifying Snap Confinement.\n\nmacOS Packages\n\nWe distribute the Solidity compiler through Homebrew as a build-from-source version. Pre-built bottles are currently not supported.\n\nbrew update\nbrew upgrade\nbrew tap ethereum/ethereum\nbrew install solidity\n\n\nTo install the most recent 0.4.x / 0.5.x version of Solidity you can also use brew install solidity@4 and brew install solidity@5, respectively.\n\nIf you need a specific version of Solidity you can install a Homebrew formula directly from Github.\n\nView solidity.rb commits on Github.\n\nCopy the commit hash of the version you want and check it out on your machine.\n\ngit clone https://github.com/ethereum/homebrew-ethereum.git\ncd homebrew-ethereum\ngit checkout <your-hash-goes-here>\n\n\nInstall it using brew:\n\nbrew unlink solidity\n# eg. Install 0.4.8\nbrew install solidity.rb\n\nStatic Binaries\n\nWe maintain a repository containing static builds of past and current compiler versions for all supported platforms at solc-bin. This is also the location where you can find the nightly builds.\n\nThe repository is not only a quick and easy way for end users to get binaries ready to be used out-of-the-box but it is also meant to be friendly to third-party tools:\n\nThe content is mirrored to https://binaries.soliditylang.org where it can be easily downloaded over HTTPS without any authentication, rate limiting or the need to use git.\n\nContent is served with correct Content-Type headers and lenient CORS configuration so that it can be directly loaded by tools running in the browser.\n\nBinaries do not require installation or unpacking (exception for older Windows builds bundled with necessary DLLs).\n\nWe strive for a high level of backward-compatibility. Files, once added, are not removed or moved without providing a symlink/redirect at the old location. They are also never modified in place and should always match the original checksum. The only exception would be broken or unusable files with the potential to cause more harm than good if left as is.\n\nFiles are served over both HTTP and HTTPS. As long as you obtain the file list in a secure way (via git, HTTPS, IPFS or just have it cached locally) and verify hashes of the binaries after downloading them, you do not have to use HTTPS for the binaries themselves.\n\nThe same binaries are in most cases available on the Solidity release page on Github. The difference is that we do not generally update old releases on the Github release page. This means that we do not rename them if the naming convention changes and we do not add builds for platforms that were not supported at the time of release. This only happens in solc-bin.\n\nThe solc-bin repository contains several top-level directories, each representing a single platform. Each one includes a list.json file listing the available binaries. For example in emscripten-wasm32/list.json you will find the following information about version 0.7.4:\n\n{\n  \"path\": \"solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js\",\n  \"version\": \"0.7.4\",\n  \"build\": \"commit.3f05b770\",\n  \"longVersion\": \"0.7.4+commit.3f05b770\",\n  \"keccak256\": \"0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3\",\n  \"sha256\": \"0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2\",\n  \"urls\": [\n    \"bzzr://16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1\",\n    \"dweb:/ipfs/QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS\"\n  ]\n}\n\n\nThis means that:\n\nYou can find the binary in the same directory under the name solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js. Note that the file might be a symlink, and you will need to resolve it yourself if you are not using git to download it or your file system does not support symlinks.\n\nThe binary is also mirrored at https://binaries.soliditylang.org/emscripten-wasm32/solc-emscripten-wasm32-v0.7.4+commit.3f05b770.js. In this case git is not necessary and symlinks are resolved transparently, either by serving a copy of the file or returning a HTTP redirect.\n\nThe file is also available on IPFS at QmTLs5MuLEWXQkths41HiACoXDiH8zxyqBHGFDRSzVE5CS.\n\nThe file might in future be available on Swarm at 16c5f09109c793db99fe35f037c6092b061bd39260ee7a677c8a97f18c955ab1.\n\nYou can verify the integrity of the binary by comparing its keccak256 hash to 0x300330ecd127756b824aa13e843cb1f43c473cb22eaf3750d5fb9c99279af8c3. The hash can be computed on the command-line using keccak256sum utility provided by sha3sum or keccak256() function from ethereumjs-util in JavaScript.\n\nYou can also verify the integrity of the binary by comparing its sha256 hash to 0x2b55ed5fec4d9625b6c7b3ab1abd2b7fb7dd2a9c68543bf0323db2c7e2d55af2.\n\nWarning\n\nDue to the strong backwards compatibility requirement the repository contains some legacy elements but you should avoid using them when writing new tools:\n\nUse emscripten-wasm32/ (with a fallback to emscripten-asmjs/) instead of bin/ if you want the best performance. Until version 0.6.1 we only provided asm.js binaries. Starting with 0.6.2 we switched to WebAssembly builds with much better performance. We have rebuilt the older versions for wasm but the original asm.js files remain in bin/. The new ones had to be placed in a separate directory to avoid name clashes.\n\nUse emscripten-asmjs/ and emscripten-wasm32/ instead of bin/ and wasm/ directories if you want to be sure whether you are downloading a wasm or an asm.js binary.\n\nUse list.json instead of list.js and list.txt. The JSON list format contains all the information from the old ones and more.\n\nUse https://binaries.soliditylang.org instead of https://solc-bin.ethereum.org. To keep things simple we moved almost everything related to the compiler under the new soliditylang.org domain and this applies to solc-bin too. While the new domain is recommended, the old one is still fully supported and guaranteed to point at the same location.\n\nWarning\n\nThe binaries are also available at https://ethereum.github.io/solc-bin/ but this page stopped being updated just after the release of version 0.7.2, will not receive any new releases or nightly builds for any platform and does not serve the new directory structure, including non-emscripten builds.\n\nIf you are using it, please switch to https://binaries.soliditylang.org, which is a drop-in replacement. This allows us to make changes to the underlying hosting in a transparent way and minimize disruption. Unlike the ethereum.github.io domain, which we do not have any control over, binaries.soliditylang.org is guaranteed to work and maintain the same URL structure in the long-term.\n\nBuilding from Source\nPrerequisites - All Operating Systems\n\nThe following are dependencies for all builds of Solidity:\n\nSoftware\n\n\t\n\nNotes\n\n\n\n\nCMake (version 3.21.3+ on Windows, 3.13+ otherwise)\n\n\t\n\nCross-platform build file generator.\n\n\n\n\nBoost (version 1.77+ on Windows, 1.65+ otherwise)\n\n\t\n\nC++ libraries.\n\n\n\n\nGit\n\n\t\n\nCommand-line tool for retrieving source code.\n\n\n\n\nz3 (version 4.8.16+, Optional)\n\n\t\n\nFor use with SMT checker.\n\n\n\n\ncvc4 (Optional)\n\n\t\n\nFor use with SMT checker.\n\nNote\n\nSolidity versions prior to 0.5.10 can fail to correctly link against Boost versions 1.70+. A possible workaround is to temporarily rename <Boost install path>/lib/cmake/Boost-1.70.0 prior to running the cmake command to configure Solidity.\n\nStarting from 0.5.10 linking against Boost 1.70+ should work without manual intervention.\n\nNote\n\nThe default build configuration requires a specific Z3 version (the latest one at the time the code was last updated). Changes introduced between Z3 releases often result in slightly different (but still valid) results being returned. Our SMT tests do not account for these differences and will likely fail with a different version than the one they were written for. This does not mean that a build using a different version is faulty. If you pass -DSTRICT_Z3_VERSION=OFF option to CMake, you can build with any version that satisfies the requirement given in the table above. If you do this, however, please remember to pass the --no-smt option to scripts/tests.sh to skip the SMT tests.\n\nNote\n\nBy default the build is performed in pedantic mode, which enables extra warnings and tells the compiler to treat all warnings as errors. This forces developers to fix warnings as they arise, so they do not accumulate “to be fixed later”. If you are only interested in creating a release build and do not intend to modify the source code to deal with such warnings, you can pass -DPEDANTIC=OFF option to CMake to disable this mode. Doing this is not recommended for general use but may be necessary when using a toolchain we are not testing with or trying to build an older version with newer tools. If you encounter such warnings, please consider reporting them.\n\nMinimum Compiler Versions\n\nThe following C++ compilers and their minimum versions can build the Solidity codebase:\n\nGCC, version 8+\n\nClang, version 7+\n\nMSVC, version 2019+\n\nPrerequisites - macOS\n\nFor macOS builds, ensure that you have the latest version of Xcode installed. This contains the Clang C++ compiler, the Xcode IDE and other Apple development tools that are required for building C++ applications on OS X. If you are installing Xcode for the first time, or have just installed a new version then you will need to agree to the license before you can do command-line builds:\n\nsudo xcodebuild -license accept\n\n\nOur OS X build script uses the Homebrew package manager for installing external dependencies. Here’s how to uninstall Homebrew, if you ever want to start again from scratch.\n\nPrerequisites - Windows\n\nYou need to install the following dependencies for Windows builds of Solidity:\n\nSoftware\n\n\t\n\nNotes\n\n\n\n\nVisual Studio 2019 Build Tools\n\n\t\n\nC++ compiler\n\n\n\n\nVisual Studio 2019 (Optional)\n\n\t\n\nC++ compiler and dev environment.\n\n\n\n\nBoost (version 1.77+)\n\n\t\n\nC++ libraries.\n\nIf you already have one IDE and only need the compiler and libraries, you could install Visual Studio 2019 Build Tools.\n\nVisual Studio 2019 provides both IDE and necessary compiler and libraries. So if you have not got an IDE and prefer to develop Solidity, Visual Studio 2019 may be a choice for you to get everything setup easily.\n\nHere is the list of components that should be installed in Visual Studio 2019 Build Tools or Visual Studio 2019:\n\nVisual Studio C++ core features\n\nVC++ 2019 v141 toolset (x86,x64)\n\nWindows Universal CRT SDK\n\nWindows 8.1 SDK\n\nC++/CLI support\n\nWe have a helper script which you can use to install all required external dependencies:\n\nscripts\\install_deps.ps1\n\n\nThis will install boost and cmake to the deps subdirectory.\n\nClone the Repository\n\nTo clone the source code, execute the following command:\n\ngit clone --recursive https://github.com/ethereum/solidity.git\ncd solidity\n\n\nIf you want to help develop Solidity, you should fork Solidity and add your personal fork as a second remote:\n\ngit remote add personal git@github.com:[username]/solidity.git\n\n\nNote\n\nThis method will result in a pre-release build leading to e.g. a flag being set in each bytecode produced by such a compiler. If you want to re-build a released Solidity compiler, then please use the source tarball on the github release page:\n\nhttps://github.com/ethereum/solidity/releases/download/v0.X.Y/solidity_0.X.Y.tar.gz\n\n(not the “Source code” provided by github).\n\nCommand-Line Build\n\nBe sure to install External Dependencies (see above) before build.\n\nSolidity project uses CMake to configure the build. You might want to install ccache to speed up repeated builds. CMake will pick it up automatically. Building Solidity is quite similar on Linux, macOS and other Unices:\n\nmkdir build\ncd build\ncmake .. && make\n\n\nor even easier on Linux and macOS, you can run:\n\n#note: this will install binaries solc and soltest at usr/local/bin\n./scripts/build.sh\n\n\nWarning\n\nBSD builds should work, but are untested by the Solidity team.\n\nAnd for Windows:\n\nmkdir build\ncd build\ncmake -G \"Visual Studio 16 2019\" ..\n\n\nIn case you want to use the version of boost installed by scripts\\install_deps.ps1, you will additionally need to pass -DBoost_DIR=\"deps\\boost\\lib\\cmake\\Boost-*\" and -DCMAKE_MSVC_RUNTIME_LIBRARY=MultiThreaded as arguments to the call to cmake.\n\nThis should result in the creation of solidity.sln in that build directory. Double-clicking on that file should result in Visual Studio firing up. We suggest building Release configuration, but all others work.\n\nAlternatively, you can build for Windows on the command-line, like so:\n\ncmake --build . --config Release\n\nCMake Options\n\nIf you are interested what CMake options are available run cmake .. -LH.\n\nSMT Solvers\n\nSolidity can be built against SMT solvers and will do so by default if they are found in the system. Each solver can be disabled by a cmake option.\n\nNote: In some cases, this can also be a potential workaround for build failures.\n\nInside the build folder you can disable them, since they are enabled by default:\n\n# disables only Z3 SMT Solver.\ncmake .. -DUSE_Z3=OFF\n\n# disables only CVC4 SMT Solver.\ncmake .. -DUSE_CVC4=OFF\n\n# disables both Z3 and CVC4\ncmake .. -DUSE_CVC4=OFF -DUSE_Z3=OFF\n\nThe Version String in Detail\n\nThe Solidity version string contains four parts:\n\nthe version number\n\npre-release tag, usually set to develop.YYYY.MM.DD or nightly.YYYY.MM.DD\n\ncommit in the format of commit.GITHASH\n\nplatform, which has an arbitrary number of items, containing details about the platform and compiler\n\nIf there are local modifications, the commit will be postfixed with .mod.\n\nThese parts are combined as required by SemVer, where the Solidity pre-release tag equals to the SemVer pre-release and the Solidity commit and platform combined make up the SemVer build metadata.\n\nA release example: 0.4.8+commit.60cc1668.Emscripten.clang.\n\nA pre-release example: 0.4.9-nightly.2017.1.17+commit.6ecb4aa3.Emscripten.clang\n\nImportant Information About Versioning\n\nAfter a release is made, the patch version level is bumped, because we assume that only patch level changes follow. When changes are merged, the version should be bumped according to SemVer and the severity of the change. Finally, a release is always made with the version of the current nightly build, but without the prerelease specifier.\n\nExample:\n\nThe 0.4.0 release is made.\n\nThe nightly build has a version of 0.4.1 from now on.\n\nNon-breaking changes are introduced –> no change in version.\n\nA breaking change is introduced –> version is bumped to 0.5.0.\n\nThe 0.5.0 release is made.\n\nThis behavior works well with the version pragma.\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Solidity by Example — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/solidity-by-example.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nVoting\nBlind Auction\nSafe Remote Purchase\nMicropayment Channel\nModular Contracts\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Solidity by Example\n Edit on GitHub\nSolidity by Example\nVoting\n\nThe following contract is quite complex, but showcases a lot of Solidity’s features. It implements a voting contract. Of course, the main problems of electronic voting is how to assign voting rights to the correct persons and how to prevent manipulation. We will not solve all problems here, but at least we will show how delegated voting can be done so that vote counting is automatic and completely transparent at the same time.\n\nThe idea is to create one contract per ballot, providing a short name for each option. Then the creator of the contract who serves as chairperson will give the right to vote to each address individually.\n\nThe persons behind the addresses can then choose to either vote themselves or to delegate their vote to a person they trust.\n\nAt the end of the voting time, winningProposal() will return the proposal with the largest number of votes.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n/// @title Voting with delegation.\ncontract Ballot {\n    // This declares a new complex type which will\n    // be used for variables later.\n    // It will represent a single voter.\n    struct Voter {\n        uint weight; // weight is accumulated by delegation\n        bool voted;  // if true, that person already voted\n        address delegate; // person delegated to\n        uint vote;   // index of the voted proposal\n    }\n\n    // This is a type for a single proposal.\n    struct Proposal {\n        bytes32 name;   // short name (up to 32 bytes)\n        uint voteCount; // number of accumulated votes\n    }\n\n    address public chairperson;\n\n    // This declares a state variable that\n    // stores a `Voter` struct for each possible address.\n    mapping(address => Voter) public voters;\n\n    // A dynamically-sized array of `Proposal` structs.\n    Proposal[] public proposals;\n\n    /// Create a new ballot to choose one of `proposalNames`.\n    constructor(bytes32[] memory proposalNames) {\n        chairperson = msg.sender;\n        voters[chairperson].weight = 1;\n\n        // For each of the provided proposal names,\n        // create a new proposal object and add it\n        // to the end of the array.\n        for (uint i = 0; i < proposalNames.length; i++) {\n            // `Proposal({...})` creates a temporary\n            // Proposal object and `proposals.push(...)`\n            // appends it to the end of `proposals`.\n            proposals.push(Proposal({\n                name: proposalNames[i],\n                voteCount: 0\n            }));\n        }\n    }\n\n    // Give `voter` the right to vote on this ballot.\n    // May only be called by `chairperson`.\n    function giveRightToVote(address voter) external {\n        // If the first argument of `require` evaluates\n        // to `false`, execution terminates and all\n        // changes to the state and to Ether balances\n        // are reverted.\n        // This used to consume all gas in old EVM versions, but\n        // not anymore.\n        // It is often a good idea to use `require` to check if\n        // functions are called correctly.\n        // As a second argument, you can also provide an\n        // explanation about what went wrong.\n        require(\n            msg.sender == chairperson,\n            \"Only chairperson can give right to vote.\"\n        );\n        require(\n            !voters[voter].voted,\n            \"The voter already voted.\"\n        );\n        require(voters[voter].weight == 0);\n        voters[voter].weight = 1;\n    }\n\n    /// Delegate your vote to the voter `to`.\n    function delegate(address to) external {\n        // assigns reference\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"You have no right to vote\");\n        require(!sender.voted, \"You already voted.\");\n\n        require(to != msg.sender, \"Self-delegation is disallowed.\");\n\n        // Forward the delegation as long as\n        // `to` also delegated.\n        // In general, such loops are very dangerous,\n        // because if they run too long, they might\n        // need more gas than is available in a block.\n        // In this case, the delegation will not be executed,\n        // but in other situations, such loops might\n        // cause a contract to get \"stuck\" completely.\n        while (voters[to].delegate != address(0)) {\n            to = voters[to].delegate;\n\n            // We found a loop in the delegation, not allowed.\n            require(to != msg.sender, \"Found loop in delegation.\");\n        }\n\n        Voter storage delegate_ = voters[to];\n\n        // Voters cannot delegate to accounts that cannot vote.\n        require(delegate_.weight >= 1);\n\n        // Since `sender` is a reference, this\n        // modifies `voters[msg.sender]`.\n        sender.voted = true;\n        sender.delegate = to;\n\n        if (delegate_.voted) {\n            // If the delegate already voted,\n            // directly add to the number of votes\n            proposals[delegate_.vote].voteCount += sender.weight;\n        } else {\n            // If the delegate did not vote yet,\n            // add to her weight.\n            delegate_.weight += sender.weight;\n        }\n    }\n\n    /// Give your vote (including votes delegated to you)\n    /// to proposal `proposals[proposal].name`.\n    function vote(uint proposal) external {\n        Voter storage sender = voters[msg.sender];\n        require(sender.weight != 0, \"Has no right to vote\");\n        require(!sender.voted, \"Already voted.\");\n        sender.voted = true;\n        sender.vote = proposal;\n\n        // If `proposal` is out of the range of the array,\n        // this will throw automatically and revert all\n        // changes.\n        proposals[proposal].voteCount += sender.weight;\n    }\n\n    /// @dev Computes the winning proposal taking all\n    /// previous votes into account.\n    function winningProposal() public view\n            returns (uint winningProposal_)\n    {\n        uint winningVoteCount = 0;\n        for (uint p = 0; p < proposals.length; p++) {\n            if (proposals[p].voteCount > winningVoteCount) {\n                winningVoteCount = proposals[p].voteCount;\n                winningProposal_ = p;\n            }\n        }\n    }\n\n    // Calls winningProposal() function to get the index\n    // of the winner contained in the proposals array and then\n    // returns the name of the winner\n    function winnerName() external view\n            returns (bytes32 winnerName_)\n    {\n        winnerName_ = proposals[winningProposal()].name;\n    }\n}\n\nPossible Improvements\n\nCurrently, many transactions are needed to assign the rights to vote to all participants. Moreover, if two or more proposals have the same number of votes, winningProposal() is not able to register a tie. Can you think of a way to fix these issues?\n\nBlind Auction\n\nIn this section, we will show how easy it is to create a completely blind auction contract on Ethereum. We will start with an open auction where everyone can see the bids that are made and then extend this contract into a blind auction where it is not possible to see the actual bid until the bidding period ends.\n\nSimple Open Auction\n\nThe general idea of the following simple auction contract is that everyone can send their bids during a bidding period. The bids already include sending some compensation, e.g. Ether, in order to bind the bidders to their bid. If the highest bid is raised, the previous highest bidder gets their Ether back. After the end of the bidding period, the contract has to be called manually for the beneficiary to receive their Ether - contracts cannot activate themselves.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\ncontract SimpleAuction {\n    // Parameters of the auction. Times are either\n    // absolute unix timestamps (seconds since 1970-01-01)\n    // or time periods in seconds.\n    address payable public beneficiary;\n    uint public auctionEndTime;\n\n    // Current state of the auction.\n    address public highestBidder;\n    uint public highestBid;\n\n    // Allowed withdrawals of previous bids\n    mapping(address => uint) pendingReturns;\n\n    // Set to true at the end, disallows any change.\n    // By default initialized to `false`.\n    bool ended;\n\n    // Events that will be emitted on changes.\n    event HighestBidIncreased(address bidder, uint amount);\n    event AuctionEnded(address winner, uint amount);\n\n    // Errors that describe failures.\n\n    // The triple-slash comments are so-called natspec\n    // comments. They will be shown when the user\n    // is asked to confirm a transaction or\n    // when an error is displayed.\n\n    /// The auction has already ended.\n    error AuctionAlreadyEnded();\n    /// There is already a higher or equal bid.\n    error BidNotHighEnough(uint highestBid);\n    /// The auction has not ended yet.\n    error AuctionNotYetEnded();\n    /// The function auctionEnd has already been called.\n    error AuctionEndAlreadyCalled();\n\n    /// Create a simple auction with `biddingTime`\n    /// seconds bidding time on behalf of the\n    /// beneficiary address `beneficiaryAddress`.\n    constructor(\n        uint biddingTime,\n        address payable beneficiaryAddress\n    ) {\n        beneficiary = beneficiaryAddress;\n        auctionEndTime = block.timestamp + biddingTime;\n    }\n\n    /// Bid on the auction with the value sent\n    /// together with this transaction.\n    /// The value will only be refunded if the\n    /// auction is not won.\n    function bid() external payable {\n        // No arguments are necessary, all\n        // information is already part of\n        // the transaction. The keyword payable\n        // is required for the function to\n        // be able to receive Ether.\n\n        // Revert the call if the bidding\n        // period is over.\n        if (block.timestamp > auctionEndTime)\n            revert AuctionAlreadyEnded();\n\n        // If the bid is not higher, send the\n        // Ether back (the revert statement\n        // will revert all changes in this\n        // function execution including\n        // it having received the Ether).\n        if (msg.value <= highestBid)\n            revert BidNotHighEnough(highestBid);\n\n        if (highestBid != 0) {\n            // Sending back the Ether by simply using\n            // highestBidder.send(highestBid) is a security risk\n            // because it could execute an untrusted contract.\n            // It is always safer to let the recipients\n            // withdraw their Ether themselves.\n            pendingReturns[highestBidder] += highestBid;\n        }\n        highestBidder = msg.sender;\n        highestBid = msg.value;\n        emit HighestBidIncreased(msg.sender, msg.value);\n    }\n\n    /// Withdraw a bid that was overbid.\n    function withdraw() external returns (bool) {\n        uint amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            // It is important to set this to zero because the recipient\n            // can call this function again as part of the receiving call\n            // before `send` returns.\n            pendingReturns[msg.sender] = 0;\n\n            // msg.sender is not of type `address payable` and must be\n            // explicitly converted using `payable(msg.sender)` in order\n            // use the member function `send()`.\n            if (!payable(msg.sender).send(amount)) {\n                // No need to call throw here, just reset the amount owing\n                pendingReturns[msg.sender] = amount;\n                return false;\n            }\n        }\n        return true;\n    }\n\n    /// End the auction and send the highest bid\n    /// to the beneficiary.\n    function auctionEnd() external {\n        // It is a good guideline to structure functions that interact\n        // with other contracts (i.e. they call functions or send Ether)\n        // into three phases:\n        // 1. checking conditions\n        // 2. performing actions (potentially changing conditions)\n        // 3. interacting with other contracts\n        // If these phases are mixed up, the other contract could call\n        // back into the current contract and modify the state or cause\n        // effects (ether payout) to be performed multiple times.\n        // If functions called internally include interaction with external\n        // contracts, they also have to be considered interaction with\n        // external contracts.\n\n        // 1. Conditions\n        if (block.timestamp < auctionEndTime)\n            revert AuctionNotYetEnded();\n        if (ended)\n            revert AuctionEndAlreadyCalled();\n\n        // 2. Effects\n        ended = true;\n        emit AuctionEnded(highestBidder, highestBid);\n\n        // 3. Interaction\n        beneficiary.transfer(highestBid);\n    }\n}\n\nBlind Auction\n\nThe previous open auction is extended to a blind auction in the following. The advantage of a blind auction is that there is no time pressure towards the end of the bidding period. Creating a blind auction on a transparent computing platform might sound like a contradiction, but cryptography comes to the rescue.\n\nDuring the bidding period, a bidder does not actually send their bid, but only a hashed version of it. Since it is currently considered practically impossible to find two (sufficiently long) values whose hash values are equal, the bidder commits to the bid by that. After the end of the bidding period, the bidders have to reveal their bids: They send their values unencrypted, and the contract checks that the hash value is the same as the one provided during the bidding period.\n\nAnother challenge is how to make the auction binding and blind at the same time: The only way to prevent the bidder from just not sending the Ether after they won the auction is to make them send it together with the bid. Since value transfers cannot be blinded in Ethereum, anyone can see the value.\n\nThe following contract solves this problem by accepting any value that is larger than the highest bid. Since this can of course only be checked during the reveal phase, some bids might be invalid, and this is on purpose (it even provides an explicit flag to place invalid bids with high-value transfers): Bidders can confuse competition by placing several high or low invalid bids.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\ncontract BlindAuction {\n    struct Bid {\n        bytes32 blindedBid;\n        uint deposit;\n    }\n\n    address payable public beneficiary;\n    uint public biddingEnd;\n    uint public revealEnd;\n    bool public ended;\n\n    mapping(address => Bid[]) public bids;\n\n    address public highestBidder;\n    uint public highestBid;\n\n    // Allowed withdrawals of previous bids\n    mapping(address => uint) pendingReturns;\n\n    event AuctionEnded(address winner, uint highestBid);\n\n    // Errors that describe failures.\n\n    /// The function has been called too early.\n    /// Try again at `time`.\n    error TooEarly(uint time);\n    /// The function has been called too late.\n    /// It cannot be called after `time`.\n    error TooLate(uint time);\n    /// The function auctionEnd has already been called.\n    error AuctionEndAlreadyCalled();\n\n    // Modifiers are a convenient way to validate inputs to\n    // functions. `onlyBefore` is applied to `bid` below:\n    // The new function body is the modifier's body where\n    // `_` is replaced by the old function body.\n    modifier onlyBefore(uint time) {\n        if (block.timestamp >= time) revert TooLate(time);\n        _;\n    }\n    modifier onlyAfter(uint time) {\n        if (block.timestamp <= time) revert TooEarly(time);\n        _;\n    }\n\n    constructor(\n        uint biddingTime,\n        uint revealTime,\n        address payable beneficiaryAddress\n    ) {\n        beneficiary = beneficiaryAddress;\n        biddingEnd = block.timestamp + biddingTime;\n        revealEnd = biddingEnd + revealTime;\n    }\n\n    /// Place a blinded bid with `blindedBid` =\n    /// keccak256(abi.encodePacked(value, fake, secret)).\n    /// The sent ether is only refunded if the bid is correctly\n    /// revealed in the revealing phase. The bid is valid if the\n    /// ether sent together with the bid is at least \"value\" and\n    /// \"fake\" is not true. Setting \"fake\" to true and sending\n    /// not the exact amount are ways to hide the real bid but\n    /// still make the required deposit. The same address can\n    /// place multiple bids.\n    function bid(bytes32 blindedBid)\n        external\n        payable\n        onlyBefore(biddingEnd)\n    {\n        bids[msg.sender].push(Bid({\n            blindedBid: blindedBid,\n            deposit: msg.value\n        }));\n    }\n\n    /// Reveal your blinded bids. You will get a refund for all\n    /// correctly blinded invalid bids and for all bids except for\n    /// the totally highest.\n    function reveal(\n        uint[] calldata values,\n        bool[] calldata fakes,\n        bytes32[] calldata secrets\n    )\n        external\n        onlyAfter(biddingEnd)\n        onlyBefore(revealEnd)\n    {\n        uint length = bids[msg.sender].length;\n        require(values.length == length);\n        require(fakes.length == length);\n        require(secrets.length == length);\n\n        uint refund;\n        for (uint i = 0; i < length; i++) {\n            Bid storage bidToCheck = bids[msg.sender][i];\n            (uint value, bool fake, bytes32 secret) =\n                    (values[i], fakes[i], secrets[i]);\n            if (bidToCheck.blindedBid != keccak256(abi.encodePacked(value, fake, secret))) {\n                // Bid was not actually revealed.\n                // Do not refund deposit.\n                continue;\n            }\n            refund += bidToCheck.deposit;\n            if (!fake && bidToCheck.deposit >= value) {\n                if (placeBid(msg.sender, value))\n                    refund -= value;\n            }\n            // Make it impossible for the sender to re-claim\n            // the same deposit.\n            bidToCheck.blindedBid = bytes32(0);\n        }\n        payable(msg.sender).transfer(refund);\n    }\n\n    /// Withdraw a bid that was overbid.\n    function withdraw() external {\n        uint amount = pendingReturns[msg.sender];\n        if (amount > 0) {\n            // It is important to set this to zero because the recipient\n            // can call this function again as part of the receiving call\n            // before `transfer` returns (see the remark above about\n            // conditions -> effects -> interaction).\n            pendingReturns[msg.sender] = 0;\n\n            payable(msg.sender).transfer(amount);\n        }\n    }\n\n    /// End the auction and send the highest bid\n    /// to the beneficiary.\n    function auctionEnd()\n        external\n        onlyAfter(revealEnd)\n    {\n        if (ended) revert AuctionEndAlreadyCalled();\n        emit AuctionEnded(highestBidder, highestBid);\n        ended = true;\n        beneficiary.transfer(highestBid);\n    }\n\n    // This is an \"internal\" function which means that it\n    // can only be called from the contract itself (or from\n    // derived contracts).\n    function placeBid(address bidder, uint value) internal\n            returns (bool success)\n    {\n        if (value <= highestBid) {\n            return false;\n        }\n        if (highestBidder != address(0)) {\n            // Refund the previously highest bidder.\n            pendingReturns[highestBidder] += highestBid;\n        }\n        highestBid = value;\n        highestBidder = bidder;\n        return true;\n    }\n}\n\nSafe Remote Purchase\n\nPurchasing goods remotely currently requires multiple parties that need to trust each other. The simplest configuration involves a seller and a buyer. The buyer would like to receive an item from the seller and the seller would like to get some compensation, e.g. Ether, in return. The problematic part is the shipment here: There is no way to determine for sure that the item arrived at the buyer.\n\nThere are multiple ways to solve this problem, but all fall short in one or the other way. In the following example, both parties have to put twice the value of the item into the contract as escrow. As soon as this happened, the Ether will stay locked inside the contract until the buyer confirms that they received the item. After that, the buyer is returned the value (half of their deposit) and the seller gets three times the value (their deposit plus the value). The idea behind this is that both parties have an incentive to resolve the situation or otherwise their Ether is locked forever.\n\nThis contract of course does not solve the problem, but gives an overview of how you can use state machine-like constructs inside a contract.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\ncontract Purchase {\n    uint public value;\n    address payable public seller;\n    address payable public buyer;\n\n    enum State { Created, Locked, Release, Inactive }\n    // The state variable has a default value of the first member, `State.created`\n    State public state;\n\n    modifier condition(bool condition_) {\n        require(condition_);\n        _;\n    }\n\n    /// Only the buyer can call this function.\n    error OnlyBuyer();\n    /// Only the seller can call this function.\n    error OnlySeller();\n    /// The function cannot be called at the current state.\n    error InvalidState();\n    /// The provided value has to be even.\n    error ValueNotEven();\n\n    modifier onlyBuyer() {\n        if (msg.sender != buyer)\n            revert OnlyBuyer();\n        _;\n    }\n\n    modifier onlySeller() {\n        if (msg.sender != seller)\n            revert OnlySeller();\n        _;\n    }\n\n    modifier inState(State state_) {\n        if (state != state_)\n            revert InvalidState();\n        _;\n    }\n\n    event Aborted();\n    event PurchaseConfirmed();\n    event ItemReceived();\n    event SellerRefunded();\n\n    // Ensure that `msg.value` is an even number.\n    // Division will truncate if it is an odd number.\n    // Check via multiplication that it wasn't an odd number.\n    constructor() payable {\n        seller = payable(msg.sender);\n        value = msg.value / 2;\n        if ((2 * value) != msg.value)\n            revert ValueNotEven();\n    }\n\n    /// Abort the purchase and reclaim the ether.\n    /// Can only be called by the seller before\n    /// the contract is locked.\n    function abort()\n        external\n        onlySeller\n        inState(State.Created)\n    {\n        emit Aborted();\n        state = State.Inactive;\n        // We use transfer here directly. It is\n        // reentrancy-safe, because it is the\n        // last call in this function and we\n        // already changed the state.\n        seller.transfer(address(this).balance);\n    }\n\n    /// Confirm the purchase as buyer.\n    /// Transaction has to include `2 * value` ether.\n    /// The ether will be locked until confirmReceived\n    /// is called.\n    function confirmPurchase()\n        external\n        inState(State.Created)\n        condition(msg.value == (2 * value))\n        payable\n    {\n        emit PurchaseConfirmed();\n        buyer = payable(msg.sender);\n        state = State.Locked;\n    }\n\n    /// Confirm that you (the buyer) received the item.\n    /// This will release the locked ether.\n    function confirmReceived()\n        external\n        onlyBuyer\n        inState(State.Locked)\n    {\n        emit ItemReceived();\n        // It is important to change the state first because\n        // otherwise, the contracts called using `send` below\n        // can call in again here.\n        state = State.Release;\n\n        buyer.transfer(value);\n    }\n\n    /// This function refunds the seller, i.e.\n    /// pays back the locked funds of the seller.\n    function refundSeller()\n        external\n        onlySeller\n        inState(State.Release)\n    {\n        emit SellerRefunded();\n        // It is important to change the state first because\n        // otherwise, the contracts called using `send` below\n        // can call in again here.\n        state = State.Inactive;\n\n        seller.transfer(3 * value);\n    }\n}\n\nMicropayment Channel\n\nIn this section, we will learn how to build an example implementation of a payment channel. It uses cryptographic signatures to make repeated transfers of Ether between the same parties secure, instantaneous, and without transaction fees. For the example, we need to understand how to sign and verify signatures, and setup the payment channel.\n\nCreating and verifying signatures\n\nImagine Alice wants to send some Ether to Bob, i.e. Alice is the sender and Bob is the recipient.\n\nAlice only needs to send cryptographically signed messages off-chain (e.g. via email) to Bob and it is similar to writing checks.\n\nAlice and Bob use signatures to authorize transactions, which is possible with smart contracts on Ethereum. Alice will build a simple smart contract that lets her transmit Ether, but instead of calling a function herself to initiate a payment, she will let Bob do that, and therefore pay the transaction fee.\n\nThe contract will work as follows:\n\nAlice deploys the ReceiverPays contract, attaching enough Ether to cover the payments that will be made.\n\nAlice authorizes a payment by signing a message with her private key.\n\nAlice sends the cryptographically signed message to Bob. The message does not need to be kept secret (explained later), and the mechanism for sending it does not matter.\n\nBob claims his payment by presenting the signed message to the smart contract, it verifies the authenticity of the message and then releases the funds.\n\nCreating the signature\n\nAlice does not need to interact with the Ethereum network to sign the transaction, the process is completely offline. In this tutorial, we will sign messages in the browser using web3.js and MetaMask, using the method described in EIP-712, as it provides a number of other security benefits.\n\n/// Hashing first makes things easier\nvar hash = web3.utils.sha3(\"message to sign\");\nweb3.eth.personal.sign(hash, web3.eth.defaultAccount, function () { console.log(\"Signed\"); });\n\n\nNote\n\nThe web3.eth.personal.sign prepends the length of the message to the signed data. Since we hash first, the message will always be exactly 32 bytes long, and thus this length prefix is always the same.\n\nWhat to Sign\n\nFor a contract that fulfils payments, the signed message must include:\n\nThe recipient’s address.\n\nThe amount to be transferred.\n\nProtection against replay attacks.\n\nA replay attack is when a signed message is reused to claim authorization for a second action. To avoid replay attacks we use the same technique as in Ethereum transactions themselves, a so-called nonce, which is the number of transactions sent by an account. The smart contract checks if a nonce is used multiple times.\n\nAnother type of replay attack can occur when the owner deploys a ReceiverPays smart contract, makes some payments, and then destroys the contract. Later, they decide to deploy the RecipientPays smart contract again, but the new contract does not know the nonces used in the previous deployment, so the attacker can use the old messages again.\n\nAlice can protect against this attack by including the contract’s address in the message, and only messages containing the contract’s address itself will be accepted. You can find an example of this in the first two lines of the claimPayment() function of the full contract at the end of this section.\n\nPacking arguments\n\nNow that we have identified what information to include in the signed message, we are ready to put the message together, hash it, and sign it. For simplicity, we concatenate the data. The ethereumjs-abi library provides a function called soliditySHA3 that mimics the behavior of Solidity’s keccak256 function applied to arguments encoded using abi.encodePacked. Here is a JavaScript function that creates the proper signature for the ReceiverPays example:\n\n// recipient is the address that should be paid.\n// amount, in wei, specifies how much ether should be sent.\n// nonce can be any unique number to prevent replay attacks\n// contractAddress is used to prevent cross-contract replay attacks\nfunction signPayment(recipient, amount, nonce, contractAddress, callback) {\n    var hash = \"0x\" + abi.soliditySHA3(\n        [\"address\", \"uint256\", \"uint256\", \"address\"],\n        [recipient, amount, nonce, contractAddress]\n    ).toString(\"hex\");\n\n    web3.eth.personal.sign(hash, web3.eth.defaultAccount, callback);\n}\n\nRecovering the Message Signer in Solidity\n\nIn general, ECDSA signatures consist of two parameters, r and s. Signatures in Ethereum include a third parameter called v, that you can use to verify which account’s private key was used to sign the message, and the transaction’s sender. Solidity provides a built-in function ecrecover that accepts a message along with the r, s and v parameters and returns the address that was used to sign the message.\n\nExtracting the Signature Parameters\n\nSignatures produced by web3.js are the concatenation of r, s and v, so the first step is to split these parameters apart. You can do this on the client-side, but doing it inside the smart contract means you only need to send one signature parameter rather than three. Splitting apart a byte array into its constituent parts is a mess, so we use inline assembly to do the job in the splitSignature function (the third function in the full contract at the end of this section).\n\nComputing the Message Hash\n\nThe smart contract needs to know exactly what parameters were signed, and so it must recreate the message from the parameters and use that for signature verification. The functions prefixed and recoverSigner do this in the claimPayment function.\n\nThe full contract\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n// This will report a warning due to deprecated selfdestruct\ncontract ReceiverPays {\n    address owner = msg.sender;\n\n    mapping(uint256 => bool) usedNonces;\n\n    constructor() payable {}\n\n    function claimPayment(uint256 amount, uint256 nonce, bytes memory signature) external {\n        require(!usedNonces[nonce]);\n        usedNonces[nonce] = true;\n\n        // this recreates the message that was signed on the client\n        bytes32 message = prefixed(keccak256(abi.encodePacked(msg.sender, amount, nonce, this)));\n\n        require(recoverSigner(message, signature) == owner);\n\n        payable(msg.sender).transfer(amount);\n    }\n\n    /// destroy the contract and reclaim the leftover funds.\n    function shutdown() external {\n        require(msg.sender == owner);\n        selfdestruct(payable(msg.sender));\n    }\n\n    /// signature methods.\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        require(sig.length == 65);\n\n        assembly {\n            // first 32 bytes, after the length prefix.\n            r := mload(add(sig, 32))\n            // second 32 bytes.\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes).\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\n\n        return ecrecover(message, v, r, s);\n    }\n\n    /// builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\nWriting a Simple Payment Channel\n\nAlice now builds a simple but complete implementation of a payment channel. Payment channels use cryptographic signatures to make repeated transfers of Ether securely, instantaneously, and without transaction fees.\n\nWhat is a Payment Channel?\n\nPayment channels allow participants to make repeated transfers of Ether without using transactions. This means that you can avoid the delays and fees associated with transactions. We are going to explore a simple unidirectional payment channel between two parties (Alice and Bob). It involves three steps:\n\nAlice funds a smart contract with Ether. This “opens” the payment channel.\n\nAlice signs messages that specify how much of that Ether is owed to the recipient. This step is repeated for each payment.\n\nBob “closes” the payment channel, withdrawing his portion of the Ether and sending the remainder back to the sender.\n\nNote\n\nOnly steps 1 and 3 require Ethereum transactions, step 2 means that the sender transmits a cryptographically signed message to the recipient via off chain methods (e.g. email). This means only two transactions are required to support any number of transfers.\n\nBob is guaranteed to receive his funds because the smart contract escrows the Ether and honours a valid signed message. The smart contract also enforces a timeout, so Alice is guaranteed to eventually recover her funds even if the recipient refuses to close the channel. It is up to the participants in a payment channel to decide how long to keep it open. For a short-lived transaction, such as paying an internet café for each minute of network access, the payment channel may be kept open for a limited duration. On the other hand, for a recurring payment, such as paying an employee an hourly wage, the payment channel may be kept open for several months or years.\n\nOpening the Payment Channel\n\nTo open the payment channel, Alice deploys the smart contract, attaching the Ether to be escrowed and specifying the intended recipient and a maximum duration for the channel to exist. This is the function SimplePaymentChannel in the contract, at the end of this section.\n\nMaking Payments\n\nAlice makes payments by sending signed messages to Bob. This step is performed entirely outside of the Ethereum network. Messages are cryptographically signed by the sender and then transmitted directly to the recipient.\n\nEach message includes the following information:\n\nThe smart contract’s address, used to prevent cross-contract replay attacks.\n\nThe total amount of Ether that is owed to the recipient so far.\n\nA payment channel is closed just once, at the end of a series of transfers. Because of this, only one of the messages sent is redeemed. This is why each message specifies a cumulative total amount of Ether owed, rather than the amount of the individual micropayment. The recipient will naturally choose to redeem the most recent message because that is the one with the highest total. The nonce per-message is not needed anymore, because the smart contract only honours a single message. The address of the smart contract is still used to prevent a message intended for one payment channel from being used for a different channel.\n\nHere is the modified JavaScript code to cryptographically sign a message from the previous section:\n\nfunction constructPaymentMessage(contractAddress, amount) {\n    return abi.soliditySHA3(\n        [\"address\", \"uint256\"],\n        [contractAddress, amount]\n    );\n}\n\nfunction signMessage(message, callback) {\n    web3.eth.personal.sign(\n        \"0x\" + message.toString(\"hex\"),\n        web3.eth.defaultAccount,\n        callback\n    );\n}\n\n// contractAddress is used to prevent cross-contract replay attacks.\n// amount, in wei, specifies how much Ether should be sent.\n\nfunction signPayment(contractAddress, amount, callback) {\n    var message = constructPaymentMessage(contractAddress, amount);\n    signMessage(message, callback);\n}\n\nClosing the Payment Channel\n\nWhen Bob is ready to receive his funds, it is time to close the payment channel by calling a close function on the smart contract. Closing the channel pays the recipient the Ether they are owed and destroys the contract, sending any remaining Ether back to Alice. To close the channel, Bob needs to provide a message signed by Alice.\n\nThe smart contract must verify that the message contains a valid signature from the sender. The process for doing this verification is the same as the process the recipient uses. The Solidity functions isValidSignature and recoverSigner work just like their JavaScript counterparts in the previous section, with the latter function borrowed from the ReceiverPays contract.\n\nOnly the payment channel recipient can call the close function, who naturally passes the most recent payment message because that message carries the highest total owed. If the sender were allowed to call this function, they could provide a message with a lower amount and cheat the recipient out of what they are owed.\n\nThe function verifies the signed message matches the given parameters. If everything checks out, the recipient is sent their portion of the Ether, and the sender is sent the rest via a selfdestruct. You can see the close function in the full contract.\n\nChannel Expiration\n\nBob can close the payment channel at any time, but if they fail to do so, Alice needs a way to recover her escrowed funds. An expiration time was set at the time of contract deployment. Once that time is reached, Alice can call claimTimeout to recover her funds. You can see the claimTimeout function in the full contract.\n\nAfter this function is called, Bob can no longer receive any Ether, so it is important that Bob closes the channel before the expiration is reached.\n\nThe full contract\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.7.0 <0.9.0;\n// This will report a warning due to deprecated selfdestruct\ncontract SimplePaymentChannel {\n    address payable public sender;      // The account sending payments.\n    address payable public recipient;   // The account receiving the payments.\n    uint256 public expiration;  // Timeout in case the recipient never closes.\n\n    constructor (address payable recipientAddress, uint256 duration)\n        payable\n    {\n        sender = payable(msg.sender);\n        recipient = recipientAddress;\n        expiration = block.timestamp + duration;\n    }\n\n    /// the recipient can close the channel at any time by presenting a\n    /// signed amount from the sender. the recipient will be sent that amount,\n    /// and the remainder will go back to the sender\n    function close(uint256 amount, bytes memory signature) external {\n        require(msg.sender == recipient);\n        require(isValidSignature(amount, signature));\n\n        recipient.transfer(amount);\n        selfdestruct(sender);\n    }\n\n    /// the sender can extend the expiration at any time\n    function extend(uint256 newExpiration) external {\n        require(msg.sender == sender);\n        require(newExpiration > expiration);\n\n        expiration = newExpiration;\n    }\n\n    /// if the timeout is reached without the recipient closing the channel,\n    /// then the Ether is released back to the sender.\n    function claimTimeout() external {\n        require(block.timestamp >= expiration);\n        selfdestruct(sender);\n    }\n\n    function isValidSignature(uint256 amount, bytes memory signature)\n        internal\n        view\n        returns (bool)\n    {\n        bytes32 message = prefixed(keccak256(abi.encodePacked(this, amount)));\n\n        // check that the signature is from the payment sender\n        return recoverSigner(message, signature) == sender;\n    }\n\n    /// All functions below this are just taken from the chapter\n    /// 'creating and verifying signatures' chapter.\n\n    function splitSignature(bytes memory sig)\n        internal\n        pure\n        returns (uint8 v, bytes32 r, bytes32 s)\n    {\n        require(sig.length == 65);\n\n        assembly {\n            // first 32 bytes, after the length prefix\n            r := mload(add(sig, 32))\n            // second 32 bytes\n            s := mload(add(sig, 64))\n            // final byte (first byte of the next 32 bytes)\n            v := byte(0, mload(add(sig, 96)))\n        }\n\n        return (v, r, s);\n    }\n\n    function recoverSigner(bytes32 message, bytes memory sig)\n        internal\n        pure\n        returns (address)\n    {\n        (uint8 v, bytes32 r, bytes32 s) = splitSignature(sig);\n\n        return ecrecover(message, v, r, s);\n    }\n\n    /// builds a prefixed hash to mimic the behavior of eth_sign.\n    function prefixed(bytes32 hash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n\n\nNote\n\nThe function splitSignature does not use all security checks. A real implementation should use a more rigorously tested library, such as openzepplin’s version of this code.\n\nVerifying Payments\n\nUnlike in the previous section, messages in a payment channel aren’t redeemed right away. The recipient keeps track of the latest message and redeems it when it’s time to close the payment channel. This means it’s critical that the recipient perform their own verification of each message. Otherwise there is no guarantee that the recipient will be able to get paid in the end.\n\nThe recipient should verify each message using the following process:\n\nVerify that the contract address in the message matches the payment channel.\n\nVerify that the new total is the expected amount.\n\nVerify that the new total does not exceed the amount of Ether escrowed.\n\nVerify that the signature is valid and comes from the payment channel sender.\n\nWe’ll use the ethereumjs-util library to write this verification. The final step can be done a number of ways, and we use JavaScript. The following code borrows the constructPaymentMessage function from the signing JavaScript code above:\n\n// this mimics the prefixing behavior of the eth_sign JSON-RPC method.\nfunction prefixed(hash) {\n    return ethereumjs.ABI.soliditySHA3(\n        [\"string\", \"bytes32\"],\n        [\"\\x19Ethereum Signed Message:\\n32\", hash]\n    );\n}\n\nfunction recoverSigner(message, signature) {\n    var split = ethereumjs.Util.fromRpcSig(signature);\n    var publicKey = ethereumjs.Util.ecrecover(message, split.v, split.r, split.s);\n    var signer = ethereumjs.Util.pubToAddress(publicKey).toString(\"hex\");\n    return signer;\n}\n\nfunction isValidSignature(contractAddress, amount, signature, expectedSigner) {\n    var message = prefixed(constructPaymentMessage(contractAddress, amount));\n    var signer = recoverSigner(message, signature);\n    return signer.toLowerCase() ==\n        ethereumjs.Util.stripHexPrefix(expectedSigner).toLowerCase();\n}\n\nModular Contracts\n\nA modular approach to building your contracts helps you reduce the complexity and improve the readability which will help to identify bugs and vulnerabilities during development and code review. If you specify and control the behavior of each module in isolation, the interactions you have to consider are only those between the module specifications and not every other moving part of the contract. In the example below, the contract uses the move method of the Balances library to check that balances sent between addresses match what you expect. In this way, the Balances library provides an isolated component that properly tracks balances of accounts. It is easy to verify that the Balances library never produces negative balances or overflows and the sum of all balances is an invariant across the lifetime of the contract.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.5.0 <0.9.0;\n\nlibrary Balances {\n    function move(mapping(address => uint256) storage balances, address from, address to, uint amount) internal {\n        require(balances[from] >= amount);\n        require(balances[to] + amount >= balances[to]);\n        balances[from] -= amount;\n        balances[to] += amount;\n    }\n}\n\ncontract Token {\n    mapping(address => uint256) balances;\n    using Balances for *;\n    mapping(address => mapping(address => uint256)) allowed;\n\n    event Transfer(address from, address to, uint amount);\n    event Approval(address owner, address spender, uint amount);\n\n    function transfer(address to, uint amount) external returns (bool success) {\n        balances.move(msg.sender, to, amount);\n        emit Transfer(msg.sender, to, amount);\n        return true;\n\n    }\n\n    function transferFrom(address from, address to, uint amount) external returns (bool success) {\n        require(allowed[from][msg.sender] >= amount);\n        allowed[from][msg.sender] -= amount;\n        balances.move(from, to, amount);\n        emit Transfer(from, to, amount);\n        return true;\n    }\n\n    function approve(address spender, uint tokens) external returns (bool success) {\n        require(allowed[msg.sender][spender] == 0, \"\");\n        allowed[msg.sender][spender] = tokens;\n        emit Approval(msg.sender, spender, tokens);\n        return true;\n    }\n\n    function balanceOf(address tokenOwner) external view returns (uint balance) {\n        return balances[tokenOwner];\n    }\n}\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Introduction to Smart Contracts — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/introduction-to-smart-contracts.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nA Simple Smart Contract\nBlockchain Basics\nThe Ethereum Virtual Machine\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nExpressions and Control Structures\nContracts\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Introduction to Smart Contracts\n Edit on GitHub\nIntroduction to Smart Contracts\nA Simple Smart Contract\n\nLet us begin with a basic example that sets the value of a variable and exposes it for other contracts to access. It is fine if you do not understand everything right now, we will go into more details later.\n\nStorage Example\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity >=0.4.16 <0.9.0;\n\ncontract SimpleStorage {\n    uint storedData;\n\n    function set(uint x) public {\n        storedData = x;\n    }\n\n    function get() public view returns (uint) {\n        return storedData;\n    }\n}\n\n\nThe first line tells you that the source code is licensed under the GPL version 3.0. Machine-readable license specifiers are important in a setting where publishing the source code is the default.\n\nThe next line specifies that the source code is written for Solidity version 0.4.16, or a newer version of the language up to, but not including version 0.9.0. This is to ensure that the contract is not compilable with a new (breaking) compiler version, where it could behave differently. Pragmas are common instructions for compilers about how to treat the source code (e.g. pragma once).\n\nA contract in the sense of Solidity is a collection of code (its functions) and data (its state) that resides at a specific address on the Ethereum blockchain. The line uint storedData; declares a state variable called storedData of type uint (unsigned integer of 256 bits). You can think of it as a single slot in a database that you can query and alter by calling functions of the code that manages the database. In this example, the contract defines the functions set and get that can be used to modify or retrieve the value of the variable.\n\nTo access a member (like a state variable) of the current contract, you do not typically add the this. prefix, you just access it directly via its name. Unlike in some other languages, omitting it is not just a matter of style, it results in a completely different way to access the member, but more on this later.\n\nThis contract does not do much yet apart from (due to the infrastructure built by Ethereum) allowing anyone to store a single number that is accessible by anyone in the world without a (feasible) way to prevent you from publishing this number. Anyone could call set again with a different value and overwrite your number, but the number is still stored in the history of the blockchain. Later, you will see how you can impose access restrictions so that only you can alter the number.\n\nWarning\n\nBe careful with using Unicode text, as similar looking (or even identical) characters can have different code points and as such are encoded as a different byte array.\n\nNote\n\nAll identifiers (contract names, function names and variable names) are restricted to the ASCII character set. It is possible to store UTF-8 encoded data in string variables.\n\nSubcurrency Example\n\nThe following contract implements the simplest form of a cryptocurrency. The contract allows only its creator to create new coins (different issuance schemes are possible). Anyone can send coins to each other without a need for registering with a username and password, all you need is an Ethereum keypair.\n\nopen in Remix\n\n// SPDX-License-Identifier: GPL-3.0\npragma solidity ^0.8.4;\n\ncontract Coin {\n    // The keyword \"public\" makes variables\n    // accessible from other contracts\n    address public minter;\n    mapping(address => uint) public balances;\n\n    // Events allow clients to react to specific\n    // contract changes you declare\n    event Sent(address from, address to, uint amount);\n\n    // Constructor code is only run when the contract\n    // is created\n    constructor() {\n        minter = msg.sender;\n    }\n\n    // Sends an amount of newly created coins to an address\n    // Can only be called by the contract creator\n    function mint(address receiver, uint amount) public {\n        require(msg.sender == minter);\n        balances[receiver] += amount;\n    }\n\n    // Errors allow you to provide information about\n    // why an operation failed. They are returned\n    // to the caller of the function.\n    error InsufficientBalance(uint requested, uint available);\n\n    // Sends an amount of existing coins\n    // from any caller to an address\n    function send(address receiver, uint amount) public {\n        if (amount > balances[msg.sender])\n            revert InsufficientBalance({\n                requested: amount,\n                available: balances[msg.sender]\n            });\n\n        balances[msg.sender] -= amount;\n        balances[receiver] += amount;\n        emit Sent(msg.sender, receiver, amount);\n    }\n}\n\n\nThis contract introduces some new concepts, let us go through them one by one.\n\nThe line address public minter; declares a state variable of type address. The address type is a 160-bit value that does not allow any arithmetic operations. It is suitable for storing addresses of contracts, or a hash of the public half of a keypair belonging to external accounts.\n\nThe keyword public automatically generates a function that allows you to access the current value of the state variable from outside of the contract. Without this keyword, other contracts have no way to access the variable. The code of the function generated by the compiler is equivalent to the following (ignore external and view for now):\n\nopen in Remix\n\nfunction minter() external view returns (address) { return minter; }\n\n\nYou could add a function like the above yourself, but you would have a function and state variable with the same name. You do not need to do this, the compiler figures it out for you.\n\nThe next line, mapping(address => uint) public balances; also creates a public state variable, but it is a more complex datatype. The mapping type maps addresses to unsigned integers.\n\nMappings can be seen as hash tables which are virtually initialised such that every possible key exists from the start and is mapped to a value whose byte-representation is all zeros. However, it is neither possible to obtain a list of all keys of a mapping, nor a list of all values. Record what you added to the mapping, or use it in a context where this is not needed. Or even better, keep a list, or use a more suitable data type.\n\nThe getter function created by the public keyword is more complex in the case of a mapping. It looks like the following:\n\nopen in Remix\n\nfunction balances(address account) external view returns (uint) {\n    return balances[account];\n}\n\n\nYou can use this function to query the balance of a single account.\n\nThe line event Sent(address from, address to, uint amount); declares an “event”, which is emitted in the last line of the function send. Ethereum clients such as web applications can listen for these events emitted on the blockchain without much cost. As soon as it is emitted, the listener receives the arguments from, to and amount, which makes it possible to track transactions.\n\nTo listen for this event, you could use the following JavaScript code, which uses web3.js to create the Coin contract object, and any user interface calls the automatically generated balances function from above:\n\nCoin.Sent().watch({}, '', function(error, result) {\n    if (!error) {\n        console.log(\"Coin transfer: \" + result.args.amount +\n            \" coins were sent from \" + result.args.from +\n            \" to \" + result.args.to + \".\");\n        console.log(\"Balances now:\\n\" +\n            \"Sender: \" + Coin.balances.call(result.args.from) +\n            \"Receiver: \" + Coin.balances.call(result.args.to));\n    }\n})\n\n\nThe constructor is a special function that is executed during the creation of the contract and cannot be called afterwards. In this case, it permanently stores the address of the person creating the contract. The msg variable (together with tx and block) is a special global variable that contains properties which allow access to the blockchain. msg.sender is always the address where the current (external) function call came from.\n\nThe functions that make up the contract, and that users and contracts can call are mint and send.\n\nThe mint function sends an amount of newly created coins to another address. The require function call defines conditions that reverts all changes if not met. In this example, require(msg.sender == minter); ensures that only the creator of the contract can call mint. In general, the creator can mint as many tokens as they like, but at some point, this will lead to a phenomenon called “overflow”. Note that because of the default Checked arithmetic, the transaction would revert if the expression balances[receiver] += amount; overflows, i.e., when balances[receiver] + amount in arbitrary precision arithmetic is larger than the maximum value of uint (2**256 - 1). This is also true for the statement balances[receiver] += amount; in the function send.\n\nErrors allow you to provide more information to the caller about why a condition or operation failed. Errors are used together with the revert statement. The revert statement unconditionally aborts and reverts all changes similar to the require function, but it also allows you to provide the name of an error and additional data which will be supplied to the caller (and eventually to the front-end application or block explorer) so that a failure can more easily be debugged or reacted upon.\n\nThe send function can be used by anyone (who already has some of these coins) to send coins to anyone else. If the sender does not have enough coins to send, the if condition evaluates to true. As a result, the revert will cause the operation to fail while providing the sender with error details using the InsufficientBalance error.\n\nNote\n\nIf you use this contract to send coins to an address, you will not see anything when you look at that address on a blockchain explorer, because the record that you sent coins and the changed balances are only stored in the data storage of this particular coin contract. By using events, you can create a “blockchain explorer” that tracks transactions and balances of your new coin, but you have to inspect the coin contract address and not the addresses of the coin owners.\n\nBlockchain Basics\n\nBlockchains as a concept are not too hard to understand for programmers. The reason is that most of the complications (mining, hashing, elliptic-curve cryptography, peer-to-peer networks, etc.) are just there to provide a certain set of features and promises for the platform. Once you accept these features as given, you do not have to worry about the underlying technology - or do you have to know how Amazon’s AWS works internally in order to use it?\n\nTransactions\n\nA blockchain is a globally shared, transactional database. This means that everyone can read entries in the database just by participating in the network. If you want to change something in the database, you have to create a so-called transaction which has to be accepted by all others. The word transaction implies that the change you want to make (assume you want to change two values at the same time) is either not done at all or completely applied. Furthermore, while your transaction is being applied to the database, no other transaction can alter it.\n\nAs an example, imagine a table that lists the balances of all accounts in an electronic currency. If a transfer from one account to another is requested, the transactional nature of the database ensures that if the amount is subtracted from one account, it is always added to the other account. If due to whatever reason, adding the amount to the target account is not possible, the source account is also not modified.\n\nFurthermore, a transaction is always cryptographically signed by the sender (creator). This makes it straightforward to guard access to specific modifications of the database. In the example of the electronic currency, a simple check ensures that only the person holding the keys to the account can transfer some compensation, e.g. Ether, from it.\n\nBlocks\n\nOne major obstacle to overcome is what (in Bitcoin terms) is called a “double-spend attack”: What happens if two transactions exist in the network that both want to empty an account? Only one of the transactions can be valid, typically the one that is accepted first. The problem is that “first” is not an objective term in a peer-to-peer network.\n\nThe abstract answer to this is that you do not have to care. A globally accepted order of the transactions will be selected for you, solving the conflict. The transactions will be bundled into what is called a “block” and then they will be executed and distributed among all participating nodes. If two transactions contradict each other, the one that ends up being second will be rejected and not become part of the block.\n\nThese blocks form a linear sequence in time, and that is where the word “blockchain” derives from. Blocks are added to the chain at regular intervals, although these intervals may be subject to change in the future. For the most up-to-date information, it is recommended to monitor the network, for example, on Etherscan.\n\nAs part of the “order selection mechanism” (which is called “mining”) it may happen that blocks are reverted from time to time, but only at the “tip” of the chain. The more blocks are added on top of a particular block, the less likely this block will be reverted. So it might be that your transactions are reverted and even removed from the blockchain, but the longer you wait, the less likely it will be.\n\nNote\n\nTransactions are not guaranteed to be included in the next block or any specific future block, since it is not up to the submitter of a transaction, but up to the miners to determine in which block the transaction is included.\n\nIf you want to schedule future calls of your contract, you can use a smart contract automation tool or an oracle service.\n\nThe Ethereum Virtual Machine\nOverview\n\nThe Ethereum Virtual Machine or EVM is the runtime environment for smart contracts in Ethereum. It is not only sandboxed but actually completely isolated, which means that code running inside the EVM has no access to network, filesystem or other processes. Smart contracts even have limited access to other smart contracts.\n\nAccounts\n\nThere are two kinds of accounts in Ethereum which share the same address space: External accounts that are controlled by public-private key pairs (i.e. humans) and contract accounts which are controlled by the code stored together with the account.\n\nThe address of an external account is determined from the public key while the address of a contract is determined at the time the contract is created (it is derived from the creator address and the number of transactions sent from that address, the so-called “nonce”).\n\nRegardless of whether or not the account stores code, the two types are treated equally by the EVM.\n\nEvery account has a persistent key-value store mapping 256-bit words to 256-bit words called storage.\n\nFurthermore, every account has a balance in Ether (in “Wei” to be exact, 1 ether is 10**18 wei) which can be modified by sending transactions that include Ether.\n\nTransactions\n\nA transaction is a message that is sent from one account to another account (which might be the same or empty, see below). It can include binary data (which is called “payload”) and Ether.\n\nIf the target account contains code, that code is executed and the payload is provided as input data.\n\nIf the target account is not set (the transaction does not have a recipient or the recipient is set to null), the transaction creates a new contract. As already mentioned, the address of that contract is not the zero address but an address derived from the sender and its number of transactions sent (the “nonce”). The payload of such a contract creation transaction is taken to be EVM bytecode and executed. The output data of this execution is permanently stored as the code of the contract. This means that in order to create a contract, you do not send the actual code of the contract, but in fact code that returns that code when executed.\n\nNote\n\nWhile a contract is being created, its code is still empty. Because of that, you should not call back into the contract under construction until its constructor has finished executing.\n\nGas\n\nUpon creation, each transaction is charged with a certain amount of gas that has to be paid for by the originator of the transaction (tx.origin). While the EVM executes the transaction, the gas is gradually depleted according to specific rules. If the gas is used up at any point (i.e. it would be negative), an out-of-gas exception is triggered, which ends execution and reverts all modifications made to the state in the current call frame.\n\nThis mechanism incentivizes economical use of EVM execution time and also compensates EVM executors (i.e. miners / stakers) for their work. Since each block has a maximum amount of gas, it also limits the amount of work needed to validate a block.\n\nThe gas price is a value set by the originator of the transaction, who has to pay gas_price * gas up front to the EVM executor. If some gas is left after execution, it is refunded to the transaction originator. In case of an exception that reverts changes, already used up gas is not refunded.\n\nSince EVM executors can choose to include a transaction or not, transaction senders cannot abuse the system by setting a low gas price.\n\nStorage, Memory and the Stack\n\nThe Ethereum Virtual Machine has three areas where it can store data: storage, memory and the stack.\n\nEach account has a data area called storage, which is persistent between function calls and transactions. Storage is a key-value store that maps 256-bit words to 256-bit words. It is not possible to enumerate storage from within a contract, it is comparatively costly to read, and even more to initialise and modify storage. Because of this cost, you should minimize what you store in persistent storage to what the contract needs to run. Store data like derived calculations, caching, and aggregates outside of the contract. A contract can neither read nor write to any storage apart from its own.\n\nThe second data area is called memory, of which a contract obtains a freshly cleared instance for each message call. Memory is linear and can be addressed at byte level, but reads are limited to a width of 256 bits, while writes can be either 8 bits or 256 bits wide. Memory is expanded by a word (256-bit), when accessing (either reading or writing) a previously untouched memory word (i.e. any offset within a word). At the time of expansion, the cost in gas must be paid. Memory is more costly the larger it grows (it scales quadratically).\n\nThe EVM is not a register machine but a stack machine, so all computations are performed on a data area called the stack. It has a maximum size of 1024 elements and contains words of 256 bits. Access to the stack is limited to the top end in the following way: It is possible to copy one of the topmost 16 elements to the top of the stack or swap the topmost element with one of the 16 elements below it. All other operations take the topmost two (or one, or more, depending on the operation) elements from the stack and push the result onto the stack. Of course it is possible to move stack elements to storage or memory in order to get deeper access to the stack, but it is not possible to just access arbitrary elements deeper in the stack without first removing the top of the stack.\n\nInstruction Set\n\nThe instruction set of the EVM is kept minimal in order to avoid incorrect or inconsistent implementations which could cause consensus problems. All instructions operate on the basic data type, 256-bit words or on slices of memory (or other byte arrays). The usual arithmetic, bit, logical and comparison operations are present. Conditional and unconditional jumps are possible. Furthermore, contracts can access relevant properties of the current block like its number and timestamp.\n\nFor a complete list, please see the list of opcodes as part of the inline assembly documentation.\n\nMessage Calls\n\nContracts can call other contracts or send Ether to non-contract accounts by the means of message calls. Message calls are similar to transactions, in that they have a source, a target, data payload, Ether, gas and return data. In fact, every transaction consists of a top-level message call which in turn can create further message calls.\n\nA contract can decide how much of its remaining gas should be sent with the inner message call and how much it wants to retain. If an out-of-gas exception happens in the inner call (or any other exception), this will be signaled by an error value put onto the stack. In this case, only the gas sent together with the call is used up. In Solidity, the calling contract causes a manual exception by default in such situations, so that exceptions “bubble up” the call stack.\n\nAs already said, the called contract (which can be the same as the caller) will receive a freshly cleared instance of memory and has access to the call payload - which will be provided in a separate area called the calldata. After it has finished execution, it can return data which will be stored at a location in the caller’s memory preallocated by the caller. All such calls are fully synchronous.\n\nCalls are limited to a depth of 1024, which means that for more complex operations, loops should be preferred over recursive calls. Furthermore, only 63/64th of the gas can be forwarded in a message call, which causes a depth limit of a little less than 1000 in practice.\n\nDelegatecall and Libraries\n\nThere exists a special variant of a message call, named delegatecall which is identical to a message call apart from the fact that the code at the target address is executed in the context (i.e. at the address) of the calling contract and msg.sender and msg.value do not change their values.\n\nThis means that a contract can dynamically load code from a different address at runtime. Storage, current address and balance still refer to the calling contract, only the code is taken from the called address.\n\nThis makes it possible to implement the “library” feature in Solidity: Reusable library code that can be applied to a contract’s storage, e.g. in order to implement a complex data structure.\n\nLogs\n\nIt is possible to store data in a specially indexed data structure that maps all the way up to the block level. This feature called logs is used by Solidity in order to implement events. Contracts cannot access log data after it has been created, but they can be efficiently accessed from outside the blockchain. Since some part of the log data is stored in bloom filters, it is possible to search for this data in an efficient and cryptographically secure way, so network peers that do not download the whole blockchain (so-called “light clients”) can still find these logs.\n\nCreate\n\nContracts can even create other contracts using a special opcode (i.e. they do not simply call the zero address as a transaction would). The only difference between these create calls and normal message calls is that the payload data is executed and the result stored as code and the caller / creator receives the address of the new contract on the stack.\n\nDeactivate and Self-destruct\n\nThe only way to remove code from the blockchain is when a contract at that address performs the selfdestruct operation. The remaining Ether stored at that address is sent to a designated target and then the storage and code is removed from the state. Removing the contract in theory sounds like a good idea, but it is potentially dangerous, as if someone sends Ether to removed contracts, the Ether is forever lost.\n\nWarning\n\nFrom version 0.8.18 and up, the use of selfdestruct in both Solidity and Yul will trigger a deprecation warning, since the SELFDESTRUCT opcode will eventually undergo breaking changes in behavior as stated in EIP-6049.\n\nWarning\n\nEven if a contract is removed by selfdestruct, it is still part of the history of the blockchain and probably retained by most Ethereum nodes. So using selfdestruct is not the same as deleting data from a hard disk.\n\nNote\n\nEven if a contract’s code does not contain a call to selfdestruct, it can still perform that operation using delegatecall or callcode.\n\nIf you want to deactivate your contracts, you should instead disable them by changing some internal state which causes all functions to revert. This makes it impossible to use the contract, as it returns Ether immediately.\n\nPrecompiled Contracts\n\nThere is a small set of contract addresses that are special: The address range between 1 and (including) 8 contains “precompiled contracts” that can be called as any other contract but their behavior (and their gas consumption) is not defined by EVM code stored at that address (they do not contain code) but instead is implemented in the EVM execution environment itself.\n\nDifferent EVM-compatible chains might use a different set of precompiled contracts. It might also be possible that new precompiled contracts are added to the Ethereum main chain in the future, but you can reasonably expect them to always be in the range between 1 and 0xffff (inclusive).\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  },
  {
    "title": "Units and Globally Available Variables — Solidity 0.8.23 documentation",
    "url": "https://docs.soliditylang.org/en/v0.8.23/units-and-global-variables.html",
    "html": "{skip to content}\nBlog\nDocumentation\nUse cases\nContribute\nAbout\nForum\nv0.8.23\n\nBASICS\n\nIntroduction to Smart Contracts\nSolidity by Example\nInstalling the Solidity Compiler\n\nLANGUAGE DESCRIPTION\n\nLayout of a Solidity Source File\nStructure of a Contract\nTypes\nUnits and Globally Available Variables\nEther Units\nTime Units\nSpecial Variables and Functions\nReserved Keywords\nExpressions and Control Structures\nContracts\nInline Assembly\nCheatsheet\nLanguage Grammar\n\nCOMPILER\n\nUsing the Compiler\nAnalysing the Compiler Output\nSolidity IR-based Codegen Changes\n\nINTERNALS\n\nLayout of State Variables in Storage\nLayout in Memory\nLayout of Call Data\nCleaning Up Variables\nSource Mappings\nThe Optimizer\nContract Metadata\nContract ABI Specification\n\nADVISORY CONTENT\n\nSecurity Considerations\nList of Known Bugs\nSolidity v0.5.0 Breaking Changes\nSolidity v0.6.0 Breaking Changes\nSolidity v0.7.0 Breaking Changes\nSolidity v0.8.0 Breaking Changes\n\nADDITIONAL MATERIAL\n\nNatSpec Format\nSMTChecker and Formal Verification\nYul\nImport Path Resolution\n\nRESOURCES\n\nStyle Guide\nCommon Patterns\nResources\nContributing\nLanguage Influences\nSolidity Brand Guide\nKeyword Index\n RTD\nv: v0.8.23 \n Units and Globally Available Variables\n Edit on GitHub\nUnits and Globally Available Variables\nEther Units\n\nA literal number can take a suffix of wei, gwei or ether to specify a subdenomination of Ether, where Ether numbers without a postfix are assumed to be Wei.\n\nopen in Remix\n\nassert(1 wei == 1);\nassert(1 gwei == 1e9);\nassert(1 ether == 1e18);\n\n\nThe only effect of the subdenomination suffix is a multiplication by a power of ten.\n\nNote\n\nThe denominations finney and szabo have been removed in version 0.7.0.\n\nTime Units\n\nSuffixes like seconds, minutes, hours, days and weeks after literal numbers can be used to specify units of time where seconds are the base unit and units are considered naively in the following way:\n\n1 == 1 seconds\n\n1 minutes == 60 seconds\n\n1 hours == 60 minutes\n\n1 days == 24 hours\n\n1 weeks == 7 days\n\nTake care if you perform calendar calculations using these units, because not every year equals 365 days and not even every day has 24 hours because of leap seconds. Due to the fact that leap seconds cannot be predicted, an exact calendar library has to be updated by an external oracle.\n\nNote\n\nThe suffix years has been removed in version 0.5.0 due to the reasons above.\n\nThese suffixes cannot be applied to variables. For example, if you want to interpret a function parameter in days, you can in the following way:\n\nopen in Remix\n\nfunction f(uint start, uint daysAfter) public {\n    if (block.timestamp >= start + daysAfter * 1 days) {\n        // ...\n    }\n}\n\nSpecial Variables and Functions\n\nThere are special variables and functions which always exist in the global namespace and are mainly used to provide information about the blockchain or are general-use utility functions.\n\nBlock and Transaction Properties\n\nblockhash(uint blockNumber) returns (bytes32): hash of the given block when blocknumber is one of the 256 most recent blocks; otherwise returns zero\n\nblock.basefee (uint): current block’s base fee (EIP-3198 and EIP-1559)\n\nblock.chainid (uint): current chain id\n\nblock.coinbase (address payable): current block miner’s address\n\nblock.difficulty (uint): current block difficulty (EVM < Paris). For other EVM versions it behaves as a deprecated alias for block.prevrandao (EIP-4399 )\n\nblock.gaslimit (uint): current block gaslimit\n\nblock.number (uint): current block number\n\nblock.prevrandao (uint): random number provided by the beacon chain (EVM >= Paris)\n\nblock.timestamp (uint): current block timestamp as seconds since unix epoch\n\ngasleft() returns (uint256): remaining gas\n\nmsg.data (bytes calldata): complete calldata\n\nmsg.sender (address): sender of the message (current call)\n\nmsg.sig (bytes4): first four bytes of the calldata (i.e. function identifier)\n\nmsg.value (uint): number of wei sent with the message\n\ntx.gasprice (uint): gas price of the transaction\n\ntx.origin (address): sender of the transaction (full call chain)\n\nNote\n\nThe values of all members of msg, including msg.sender and msg.value can change for every external function call. This includes calls to library functions.\n\nNote\n\nWhen contracts are evaluated off-chain rather than in context of a transaction included in a block, you should not assume that block.* and tx.* refer to values from any specific block or transaction. These values are provided by the EVM implementation that executes the contract and can be arbitrary.\n\nNote\n\nDo not rely on block.timestamp or blockhash as a source of randomness, unless you know what you are doing.\n\nBoth the timestamp and the block hash can be influenced by miners to some degree. Bad actors in the mining community can for example run a casino payout function on a chosen hash and just retry a different hash if they did not receive any compensation, e.g. Ether.\n\nThe current block timestamp must be strictly larger than the timestamp of the last block, but the only guarantee is that it will be somewhere between the timestamps of two consecutive blocks in the canonical chain.\n\nNote\n\nThe block hashes are not available for all blocks for scalability reasons. You can only access the hashes of the most recent 256 blocks, all other values will be zero.\n\nNote\n\nThe function blockhash was previously known as block.blockhash, which was deprecated in version 0.4.22 and removed in version 0.5.0.\n\nNote\n\nThe function gasleft was previously known as msg.gas, which was deprecated in version 0.4.21 and removed in version 0.5.0.\n\nNote\n\nIn version 0.7.0, the alias now (for block.timestamp) was removed.\n\nABI Encoding and Decoding Functions\n\nabi.decode(bytes memory encodedData, (...)) returns (...): ABI-decodes the given data, while the types are given in parentheses as second argument. Example: (uint a, uint[2] memory b, bytes memory c) = abi.decode(data, (uint, uint[2], bytes))\n\nabi.encode(...) returns (bytes memory): ABI-encodes the given arguments\n\nabi.encodePacked(...) returns (bytes memory): Performs packed encoding of the given arguments. Note that packed encoding can be ambiguous!\n\nabi.encodeWithSelector(bytes4 selector, ...) returns (bytes memory): ABI-encodes the given arguments starting from the second and prepends the given four-byte selector\n\nabi.encodeWithSignature(string memory signature, ...) returns (bytes memory): Equivalent to abi.encodeWithSelector(bytes4(keccak256(bytes(signature))), ...)\n\nabi.encodeCall(function functionPointer, (...)) returns (bytes memory): ABI-encodes a call to functionPointer with the arguments found in the tuple. Performs a full type-check, ensuring the types match the function signature. Result equals abi.encodeWithSelector(functionPointer.selector, (...))\n\nNote\n\nThese encoding functions can be used to craft data for external function calls without actually calling an external function. Furthermore, keccak256(abi.encodePacked(a, b)) is a way to compute the hash of structured data (although be aware that it is possible to craft a “hash collision” using different function parameter types).\n\nSee the documentation about the ABI and the tightly packed encoding for details about the encoding.\n\nMembers of bytes\n\nbytes.concat(...) returns (bytes memory): Concatenates variable number of bytes and bytes1, …, bytes32 arguments to one byte array\n\nMembers of string\n\nstring.concat(...) returns (string memory): Concatenates variable number of string arguments to one string array\n\nError Handling\n\nSee the dedicated section on assert and require for more details on error handling and when to use which function.\n\nassert(bool condition)\n\ncauses a Panic error and thus state change reversion if the condition is not met - to be used for internal errors.\n\nrequire(bool condition)\n\nreverts if the condition is not met - to be used for errors in inputs or external components.\n\nrequire(bool condition, string memory message)\n\nreverts if the condition is not met - to be used for errors in inputs or external components. Also provides an error message.\n\nrevert()\n\nabort execution and revert state changes\n\nrevert(string memory reason)\n\nabort execution and revert state changes, providing an explanatory string\n\nMathematical and Cryptographic Functions\naddmod(uint x, uint y, uint k) returns (uint)\n\ncompute (x + y) % k where the addition is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.\n\nmulmod(uint x, uint y, uint k) returns (uint)\n\ncompute (x * y) % k where the multiplication is performed with arbitrary precision and does not wrap around at 2**256. Assert that k != 0 starting from version 0.5.0.\n\nkeccak256(bytes memory) returns (bytes32)\n\ncompute the Keccak-256 hash of the input\n\nNote\n\nThere used to be an alias for keccak256 called sha3, which was removed in version 0.5.0.\n\nsha256(bytes memory) returns (bytes32)\n\ncompute the SHA-256 hash of the input\n\nripemd160(bytes memory) returns (bytes20)\n\ncompute RIPEMD-160 hash of the input\n\necrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) returns (address)\n\nrecover the address associated with the public key from elliptic curve signature or return zero on error. The function parameters correspond to ECDSA values of the signature:\n\nr = first 32 bytes of signature\n\ns = second 32 bytes of signature\n\nv = final 1 byte of signature\n\necrecover returns an address, and not an address payable. See address payable for conversion, in case you need to transfer funds to the recovered address.\n\nFor further details, read example usage.\n\nWarning\n\nIf you use ecrecover, be aware that a valid signature can be turned into a different valid signature without requiring knowledge of the corresponding private key. In the Homestead hard fork, this issue was fixed for _transaction_ signatures (see EIP-2), but the ecrecover function remained unchanged.\n\nThis is usually not a problem unless you require signatures to be unique or use them to identify items. OpenZeppelin has an ECDSA helper library that you can use as a wrapper for ecrecover without this issue.\n\nNote\n\nWhen running sha256, ripemd160 or ecrecover on a private blockchain, you might encounter Out-of-Gas. This is because these functions are implemented as “precompiled contracts” and only really exist after they receive the first message (although their contract code is hardcoded). Messages to non-existing contracts are more expensive and thus the execution might run into an Out-of-Gas error. A workaround for this problem is to first send Wei (1 for example) to each of the contracts before you use them in your actual contracts. This is not an issue on the main or test net.\n\nMembers of Address Types\n<address>.balance (uint256)\n\nbalance of the Address in Wei\n\n<address>.code (bytes memory)\n\ncode at the Address (can be empty)\n\n<address>.codehash (bytes32)\n\nthe codehash of the Address\n\n<address payable>.transfer(uint256 amount)\n\nsend given amount of Wei to Address, reverts on failure, forwards 2300 gas stipend, not adjustable\n\n<address payable>.send(uint256 amount) returns (bool)\n\nsend given amount of Wei to Address, returns false on failure, forwards 2300 gas stipend, not adjustable\n\n<address>.call(bytes memory) returns (bool, bytes memory)\n\nissue low-level CALL with the given payload, returns success condition and return data, forwards all available gas, adjustable\n\n<address>.delegatecall(bytes memory) returns (bool, bytes memory)\n\nissue low-level DELEGATECALL with the given payload, returns success condition and return data, forwards all available gas, adjustable\n\n<address>.staticcall(bytes memory) returns (bool, bytes memory)\n\nissue low-level STATICCALL with the given payload, returns success condition and return data, forwards all available gas, adjustable\n\nFor more information, see the section on Address.\n\nWarning\n\nYou should avoid using .call() whenever possible when executing another contract function as it bypasses type checking, function existence check, and argument packing.\n\nWarning\n\nThere are some dangers in using send: The transfer fails if the call stack depth is at 1024 (this can always be forced by the caller) and it also fails if the recipient runs out of gas. So in order to make safe Ether transfers, always check the return value of send, use transfer or even better: Use a pattern where the recipient withdraws the Ether.\n\nWarning\n\nDue to the fact that the EVM considers a call to a non-existing contract to always succeed, Solidity includes an extra check using the extcodesize opcode when performing external calls. This ensures that the contract that is about to be called either actually exists (it contains code) or an exception is raised.\n\nThe low-level calls which operate on addresses rather than contract instances (i.e. .call(), .delegatecall(), .staticcall(), .send() and .transfer()) do not include this check, which makes them cheaper in terms of gas but also less safe.\n\nNote\n\nPrior to version 0.5.0, Solidity allowed address members to be accessed by a contract instance, for example this.balance. This is now forbidden and an explicit conversion to address must be done: address(this).balance.\n\nNote\n\nIf state variables are accessed via a low-level delegatecall, the storage layout of the two contracts must align in order for the called contract to correctly access the storage variables of the calling contract by name. This is of course not the case if storage pointers are passed as function arguments as in the case for the high-level libraries.\n\nNote\n\nPrior to version 0.5.0, .call, .delegatecall and .staticcall only returned the success condition and not the return data.\n\nNote\n\nPrior to version 0.5.0, there was a member called callcode with similar but slightly different semantics than delegatecall.\n\nContract-related\nthis (current contract’s type)\n\nThe current contract, explicitly convertible to Address\n\nsuper\n\nA contract one level higher in the inheritance hierarchy\n\nselfdestruct(address payable recipient)\n\nDestroy the current contract, sending its funds to the given Address and end execution. Note that selfdestruct has some peculiarities inherited from the EVM:\n\nthe receiving contract’s receive function is not executed.\n\nthe contract is only really destroyed at the end of the transaction and revert s might “undo” the destruction.\n\nFurthermore, all functions of the current contract are callable directly including the current function.\n\nWarning\n\nFrom version 0.8.18 and up, the use of selfdestruct in both Solidity and Yul will trigger a deprecation warning, since the SELFDESTRUCT opcode will eventually undergo breaking changes in behavior as stated in EIP-6049.\n\nNote\n\nPrior to version 0.5.0, there was a function called suicide with the same semantics as selfdestruct.\n\nType Information\n\nThe expression type(X) can be used to retrieve information about the type X. Currently, there is limited support for this feature (X can be either a contract or an integer type) but it might be expanded in the future.\n\nThe following properties are available for a contract type C:\n\ntype(C).name\n\nThe name of the contract.\n\ntype(C).creationCode\n\nMemory byte array that contains the creation bytecode of the contract. This can be used in inline assembly to build custom creation routines, especially by using the create2 opcode. This property can not be accessed in the contract itself or any derived contract. It causes the bytecode to be included in the bytecode of the call site and thus circular references like that are not possible.\n\ntype(C).runtimeCode\n\nMemory byte array that contains the runtime bytecode of the contract. This is the code that is usually deployed by the constructor of C. If C has a constructor that uses inline assembly, this might be different from the actually deployed bytecode. Also note that libraries modify their runtime bytecode at time of deployment to guard against regular calls. The same restrictions as with .creationCode also apply for this property.\n\nIn addition to the properties above, the following properties are available for an interface type I:\n\ntype(I).interfaceId\n\nA bytes4 value containing the EIP-165 interface identifier of the given interface I. This identifier is defined as the XOR of all function selectors defined within the interface itself - excluding all inherited functions.\n\nThe following properties are available for an integer type T:\n\ntype(T).min\n\nThe smallest value representable by type T.\n\ntype(T).max\n\nThe largest value representable by type T.\n\nReserved Keywords\n\nThese keywords are reserved in Solidity. They might become part of the syntax in the future:\n\nafter, alias, apply, auto, byte, case, copyof, default, define, final, implements, in, inline, let, macro, match, mutable, null, of, partial, promise, reference, relocatable, sealed, sizeof, static, supports, switch, typedef, typeof, var.\n\n Previous\nNext \n\n© Copyright 2016-2023, The Solidity Authors. Revision f704f362.\n\nCustomized with ❤️ by the ethereum.org team.\n\nCredits and attribution."
  }
]